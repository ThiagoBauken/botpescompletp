#!/usr/bin/env python3
"""
üßô‚Äç‚ôÇÔ∏è Ultimate Fishing Bot v3.0 - BOT_MAIN
Bot de Pesca Avan√ßado com Interface Simplificada
"""

import time
import threading
import pyautogui
import keyboard
import tkinter as tk
from tkinter import messagebox, simpledialog, ttk
import json
import os
import hashlib
import requests
import platform
import psutil
import cv2
import numpy as np
# Importa√ß√µes opcionais para Windows
try:
    import win32gui
    import win32con
    WIN32_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è win32gui n√£o dispon√≠vel - funcionalidades de foco de janela limitadas")
    WIN32_AVAILABLE = False

# üéØ Sistema otimizado apenas com OpenCV Template Matching - SEM YOLOsemiscanam
print("üéØ Sistema configurado para usar APENAS Template Matching (OpenCV)")
print("üöÄ YOLO removido - performance otimizada!")

# üåç Sistema de Internacionaliza√ß√£o
try:
    from i18n import i18n, _
    print(f"üåç Sistema multilingual inicializado: {i18n.get_language_name()}")
    i18n.load_language_preference()
except ImportError:
    print("‚ö†Ô∏è Sistema i18n n√£o encontrado - usando textos padr√£o")
    def _(key, **kwargs):
        return key
import mss
import ctypes
import ctypes.wintypes
import subprocess
from record_macro import record_chest_macro
import pickle

# Importar sistema de log de sess√£o (comentado - m√≥dulo n√£o dispon√≠vel)
# try:
#     from session_logger import init_session_logger, get_session_logger
#     SESSION_LOG = init_session_logger()
#     SESSION_LOG.info("üîç Sistema de log inicializado")
# except ImportError:
#     print("‚ö†Ô∏è Sistema de log n√£o encontrado - continuando sem logging detalhado")
#     SESSION_LOG = None
SESSION_LOG = None  # Desabilitado por padr√£o

VERSION = "3.0.0"
ACTIVATION_SERVER = "https://private-keygen.pbzgje.easypanel.host"
PROJECT_ID = "67a4a76a-d71b-4d07-9ba8-f7e794ce0578"

# Nome da janela do jogo (ajuste conforme necess√°rio)
GAME_WINDOW_TITLE = None  # Ser√° configurado dinamicamente

# Fun√ß√£o para prints seguros sem problemas de encoding
def safe_print(text):
    """Print seguro que remove caracteres problem√°ticos"""
    try:
        print(text)
    except (UnicodeEncodeError, UnicodeError):
        try:
            # Tentar diferentes encodings
            safe_text = str(text).encode('utf-8', 'ignore').decode('utf-8')
            print(safe_text)
        except:
            try:
                # √öltimo recurso - apenas ASCII
                safe_text = str(text).encode('ascii', 'ignore').decode('ascii')
                print(safe_text)
            except:
                print("Erro de encoding - mensagem suprimida")

def find_game_window():
    """Encontrar janela do jogo automaticamente"""
    global GAME_WINDOW_TITLE
    
    if not WIN32_AVAILABLE:
        print("‚ö†Ô∏è win32gui n√£o dispon√≠vel - detec√ß√£o de janela desabilitada")
        return None, None
    
    def enum_window_callback(hwnd, windows):
        if win32gui.IsWindowVisible(hwnd) and win32gui.IsWindowEnabled(hwnd):
            window_text = win32gui.GetWindowText(hwnd)
            if window_text:
                # Procurar por janelas de jogos conhecidos
                game_keywords = ['Rust', 'Fisch', 'Fishing', 'Game', 'Client', 'Unity', 'Unreal']
                for keyword in game_keywords:
                    if keyword.lower() in window_text.lower():
                        windows.append((hwnd, window_text))
                        break
        return True
    
    windows = []
    win32gui.EnumWindows(enum_window_callback, windows)
    
    if windows:
        # Pegar a primeira janela de jogo encontrada
        hwnd, title = windows[0]
        GAME_WINDOW_TITLE = title
        print(f"üéÆ Janela do jogo detectada: {title}")
        return hwnd, title
    return None, None

# Controle de foco inteligente
LAST_FOCUS_TIME = 0
FOCUS_COOLDOWN = 1.0  # 1 segundo entre focos
AUTO_FOCUS_ENABLED = True  # Pode ser desabilitado

def focus_game_window(force=False):
    """Garantir que a janela do jogo esteja em foco antes de enviar comandos"""
    import time
    global LAST_FOCUS_TIME, AUTO_FOCUS_ENABLED
    
    # Se auto-focus desabilitado e n√£o for√ßado, n√£o fazer nada
    if not AUTO_FOCUS_ENABLED and not force:
        return True
        
    # Cooldown para evitar foco excessivo
    current_time = time.time()
    if not force and (current_time - LAST_FOCUS_TIME) < FOCUS_COOLDOWN:
        return True
        
    try:
        if not WIN32_AVAILABLE:
            # Se win32gui n√£o estiver dispon√≠vel, apenas clicar no centro da tela
            screen_width, screen_height = pyautogui.size()
            pyautogui.click(screen_width // 2, screen_height // 2)
            time.sleep(0.1)
            return True
            
        # Tentar encontrar a janela do jogo
        if GAME_WINDOW_TITLE:
            hwnd = win32gui.FindWindow(None, GAME_WINDOW_TITLE)
        else:
            # Procurar janela automaticamente
            hwnd, title = find_game_window()
            
        if hwnd:
            # Trazer janela para frente
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            win32gui.SetForegroundWindow(hwnd)
            time.sleep(0.1)  # Pequeno delay para garantir foco
            LAST_FOCUS_TIME = current_time  # Atualizar tempo de √∫ltimo foco
            return True
        else:
            # Se n√£o encontrar janela espec√≠fica, pelo menos tirar foco do terminal
            # Clicar no centro da tela para garantir que saia do terminal
            screen_width, screen_height = pyautogui.size()
            pyautogui.click(screen_width // 2, screen_height // 2)
            time.sleep(0.1)
            return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao focar janela do jogo: {e}")
        # Fallback: clicar no centro da tela
        try:
            screen_width, screen_height = pyautogui.size()
            pyautogui.click(screen_width // 2, screen_height // 2)
            time.sleep(0.1)
        except:
            pass
        return False

def toggle_auto_focus():
    """Alternar foco autom√°tico da janela do jogo"""
    global AUTO_FOCUS_ENABLED
    AUTO_FOCUS_ENABLED = not AUTO_FOCUS_ENABLED
    status = "HABILITADO" if AUTO_FOCUS_ENABLED else "DESABILITADO"
    print(f"üéØ Foco autom√°tico {status}")
    return AUTO_FOCUS_ENABLED

def disable_auto_focus():
    """Desabilitar foco autom√°tico (para quando sair do jogo)"""
    global AUTO_FOCUS_ENABLED
    AUTO_FOCUS_ENABLED = False
    print("üö´ Foco autom√°tico DESABILITADO - voc√™ pode sair do jogo sem voltar automaticamente")

def enable_auto_focus():
    """Reabilitar foco autom√°tico"""
    global AUTO_FOCUS_ENABLED
    AUTO_FOCUS_ENABLED = True
    print("‚úÖ Foco autom√°tico HABILITADO")

# Fun√ß√µes auxiliares para movimento de mouse Windows API
def win32_move_mouse(x, y):
    """Move mouse usando Windows API (mais confi√°vel para jogos)"""
    try:
        # Garantir foco no jogo antes
        focus_game_window()
        # Usar SetCursorPos da user32.dll
        ctypes.windll.user32.SetCursorPos(int(x), int(y))
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erro win32_move_mouse: {e}")
        return False

def force_mouse_move(target_x, target_y, max_attempts=5):
    """For√ßar movimento de mouse com m√∫ltiplas tentativas"""
    safe_print(f"[MOUSE] Tentando mover mouse para: ({target_x}, {target_y})")

    for attempt in range(max_attempts):
        # Tentar pyautogui primeiro
        try:
            pyautogui.moveTo(target_x, target_y, duration=0.1)
            time.sleep(0.1)
        except:
            pass

        # Verificar se funcionou
        current_pos = pyautogui.position()
        distance = abs(current_pos.x - target_x) + abs(current_pos.y - target_y)

        if distance < 10:  # Sucesso
            print(f"   ‚úÖ Movimento bem-sucedido na tentativa {attempt + 1}: {current_pos}")
            return True

        # Se n√£o funcionou, tentar com Windows API
        print(f"   ‚ö†Ô∏è Tentativa {attempt + 1} com pyautogui falhou. Tentando win32...")
        if win32_move_mouse(target_x, target_y):
            time.sleep(0.1)
            current_pos = pyautogui.position()
            distance = abs(current_pos.x - target_x) + abs(current_pos.y - target_y)

            if distance < 10:
                print(f"   ‚úÖ Movimento win32 bem-sucedido na tentativa {attempt + 1}: {current_pos}")
                return True

        time.sleep(0.1)

    print(f"   ‚ùå FALHA: Mouse n√£o se moveu ap√≥s {max_attempts} tentativas!")
    return False

def release_mouse_buttons(preserve_right_click=False):
    """Liberar todos os bot√µes do mouse antes de executar macros - CORRIGIDO"""
    try:
        print("   üñ±Ô∏è Liberando bot√µes do mouse...")

        # CORRE√á√ÉO: N√£o liberar bot√£o direito se preserve_right_click=True
        if not preserve_right_click:
            # Liberar bot√£o direito (mais cr√≠tico para macros)
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='right')
            time.sleep(0.1)
        else:
            print("   ‚ö†Ô∏è Preservando bot√£o direito (pesca ativa)")

        # Liberar bot√£o esquerdo tamb√©m por garantia
        focus_game_window()  # Garantir foco
        pyautogui.mouseUp(button='left')
        time.sleep(0.1)

        # Liberar bot√£o do meio se houver
        focus_game_window()  # Garantir foco
        pyautogui.mouseUp(button='middle')
        time.sleep(0.1)

        print("   ‚úÖ Bot√µes do mouse liberados!")
        return True

    except Exception as e:
        print(f"   ‚ö†Ô∏è Erro ao liberar mouse: {e}")
        return False

def center_camera(initial_pos=None):
    """Centralizar c√¢mera antes de executar macro - USA POSI√á√ÉO INICIAL DO F9"""
    try:
        print("   üéØ Resetando c√¢mera para posi√ß√£o inicial...")

        # Usar posi√ß√£o inicial capturada no F9, ou centro da tela como fallback
        if initial_pos:
            center_x, center_y = initial_pos
            print(f"   üìç Usando posi√ß√£o inicial do F9: ({center_x}, {center_y})")
        else:
            screen_width, screen_height = pyautogui.size()
            center_x = screen_width // 2
            center_y = screen_height // 2
            print(f"   üìç Fallback - centro da tela: ({center_x}, {center_y})")

        pyautogui.moveTo(center_x, center_y)
        time.sleep(0.1)

        # M√©todo 2: Reset de c√¢mera por movimento
        # Fazer movimentos em cruz para "cancelar" posi√ß√£o anterior
        pyautogui.moveRel(200, 0)    # Direita
        time.sleep(0.05)
        pyautogui.moveRel(-400, 0)   # Esquerda forte
        time.sleep(0.05)
        pyautogui.moveRel(200, 0)    # Volta centro
        time.sleep(0.05)

        pyautogui.moveRel(0, 200)    # Baixo
        time.sleep(0.05)
        pyautogui.moveRel(0, -400)   # Cima forte
        time.sleep(0.05)
        pyautogui.moveRel(0, 200)    # Volta centro
        time.sleep(0.05)

        # Voltar para centro absoluto novamente
        pyautogui.moveTo(center_x, center_y)
        time.sleep(0.2)

        print("   ‚úÖ C√¢mera resetada - posi√ß√£o zero garantida!")
        return True

    except Exception as e:
        print(f"   ‚ö†Ô∏è Erro ao resetar c√¢mera: {e}")
        return False

def camera_turn_in_game(dx, dy):
    """Movimento de c√¢mera simulando o comportamento do jogo com ALT"""
    import ctypes
    from ctypes import wintypes

    print(f"   üéÆ Movimento no jogo: DX={dx}, DY={dy}")

    try:
        # Estruturas Windows para SendInput
        class MOUSEINPUT(ctypes.Structure):
            _fields_ = [("dx", wintypes.LONG),
                       ("dy", wintypes.LONG),
                       ("mouseData", wintypes.DWORD),
                       ("dwFlags", wintypes.DWORD),
                       ("time", wintypes.DWORD),
                       ("dwExtraInfo", ctypes.POINTER(ctypes.c_ulong))]

        class INPUT(ctypes.Structure):
            class _INPUT(ctypes.Union):
                _fields_ = [("mi", MOUSEINPUT)]
            _fields_ = [("type", wintypes.DWORD),
                       ("_input", _INPUT)]

        # Constantes
        INPUT_MOUSE = 0
        MOUSEEVENTF_MOVE = 0x0001

        # Dividir movimento em passos menores para suavidade
        steps = 10
        dx_step = dx // steps
        dy_step = dy // steps

        for i in range(steps):
            # Criar input
            x = INPUT()
            x.type = INPUT_MOUSE
            x._input.mi.dx = dx_step
            x._input.mi.dy = dy_step
            x._input.mi.dwFlags = MOUSEEVENTF_MOVE
            x._input.mi.time = 0
            x._input.mi.dwExtraInfo = None

            # Enviar input
            ctypes.windll.user32.SendInput(1, ctypes.byref(x), ctypes.sizeof(x))
            time.sleep(0.01)  # Pequeno delay entre movimentos

        # Movimento restante
        remainder_x = dx - (dx_step * steps)
        remainder_y = dy - (dy_step * steps)

        if remainder_x != 0 or remainder_y != 0:
            x = INPUT()
            x.type = INPUT_MOUSE
            x._input.mi.dx = remainder_x
            x._input.mi.dy = remainder_y
            x._input.mi.dwFlags = MOUSEEVENTF_MOVE
            x._input.mi.time = 0
            x._input.mi.dwExtraInfo = None
            ctypes.windll.user32.SendInput(1, ctypes.byref(x), ctypes.sizeof(x))

        print(f"   ‚úÖ Movimento executado com sucesso!")
        return True

    except Exception as e:
        print(f"   ‚ùå Erro no movimento: {e}")
        return False

def camera_turn_direct(dx, dy):
    """Movimento direto de c√¢mera com deslocamento X e Y"""
    import ctypes
    from ctypes import wintypes

    print(f"   üìπ Movimento direto: DX={dx}, DY={dy}")

    try:
        # Estruturas do Windows
        class MOUSEINPUT(ctypes.Structure):
            _fields_ = [("dx", wintypes.LONG),
                       ("dy", wintypes.LONG),
                       ("mouseData", wintypes.DWORD),
                       ("dwFlags", wintypes.DWORD),
                       ("time", wintypes.DWORD),
                       ("dwExtraInfo", ctypes.POINTER(ctypes.c_ulong))]

        class INPUT(ctypes.Structure):
            class _INPUT(ctypes.Union):
                _fields_ = [("mi", MOUSEINPUT)]
            _fields_ = [("type", wintypes.DWORD),
                       ("_input", _INPUT)]

        # Constantes
        INPUT_MOUSE = 0
        MOUSEEVENTF_MOVE = 0x0001

        # Criar input de movimento
        x = INPUT()
        x.type = INPUT_MOUSE
        x._input.mi.dx = int(dx)
        x._input.mi.dy = int(dy)
        x._input.mi.dwFlags = MOUSEEVENTF_MOVE
        x._input.mi.time = 0
        x._input.mi.dwExtraInfo = None

        # Enviar input
        ctypes.windll.user32.SendInput(1, ctypes.byref(x), ctypes.sizeof(x))

        print(f"   ‚úÖ Movimento executado: X={dx}, Y={dy}")
        return True

    except Exception as e:
        print(f"   ‚ùå Erro no movimento direto: {e}")
        # Fallback para pyautogui
        current_x, current_y = pyautogui.position()
        pyautogui.moveRel(dx, dy, duration=0.1)
        return False

def camera_turn(direction, intensity=300):
    """Girar c√¢mera usando INPUT DIRETO (como Pulover) - SEM cursor vis√≠vel"""
    print(f"üìπ Girando c√¢mera com INPUT DIRETO: {direction} (intensidade: {intensity}px)")

    try:
        # M√âTODO 1: Windows SendInput (como Pulover faz)
        return camera_turn_sendinput(direction, intensity)

    except Exception as e:
        print(f"   ‚ùå Erro SendInput, tentando m√©todo alternativo: {e}")
        # M√âTODO 2: Fallback para mouse drag tradicional
        return camera_turn_drag(direction, intensity)

def camera_turn_sendinput(direction, intensity=300):
    """M√©todo SendInput - INPUT DIRETO como Pulover"""
    import ctypes
    from ctypes import wintypes

    print(f"   üéØ Usando SendInput (m√©todo Pulover)")

    try:
        # Definir estruturas do Windows
        class POINT(ctypes.Structure):
            _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]

        class MOUSEINPUT(ctypes.Structure):
            _fields_ = [("dx", wintypes.LONG),
                       ("dy", wintypes.LONG),
                       ("mouseData", wintypes.DWORD),
                       ("dwFlags", wintypes.DWORD),
                       ("time", wintypes.DWORD),
                       ("dwExtraInfo", ctypes.POINTER(wintypes.ULONG))]

        class INPUT(ctypes.Structure):
            class _INPUT(ctypes.Union):
                _fields_ = [("mi", MOUSEINPUT)]
            _anonymous_ = ("_input",)
            _fields_ = [("type", wintypes.DWORD), ("_input", _INPUT)]

        # Constantes
        INPUT_MOUSE = 0
        MOUSEEVENTF_MOVE = 0x0001
        MOUSEEVENTF_ABSOLUTE = 0x8000

        # Carregar offset vertical se dispon√≠vel
        try:
            import json
            with open('config.json', 'r') as f:
                config = json.load(f)
            vertical_offset = config.get('chest_vertical_offset', 0)
        except:
            vertical_offset = 0

        # Calcular movimento relativo com componente vertical
        if direction == 'left':
            delta_x = -intensity
            direction_name = "ESQUERDA"
        elif direction == 'right':
            delta_x = intensity
            direction_name = "DIREITA"
        else:
            error_msg = f"‚ùå Dire√ß√£o inv√°lida: '{direction}' (tipo: {type(direction)})"
            print(error_msg)
            if SESSION_LOG:
                SESSION_LOG.error(f"camera_turn_sendinput: {error_msg}")
            return False

        delta_y = vertical_offset  # Movimento vertical (negativo = para cima)

        print(f"   üìä Delta X: {delta_x}, Delta Y: {delta_y} (movimento 3D)")
        if delta_y != 0:
            direction_y = "CIMA" if delta_y < 0 else "BAIXO"
            print(f"   üìä Movimento vertical: {abs(delta_y)}px para {direction_y}")

        # Criar INPUT para movimento relativo 3D
        mouse_input = INPUT()
        mouse_input.type = INPUT_MOUSE
        mouse_input.mi.dx = delta_x
        mouse_input.mi.dy = delta_y
        mouse_input.mi.mouseData = 0
        mouse_input.mi.dwFlags = MOUSEEVENTF_MOVE  # Movimento RELATIVO
        mouse_input.mi.time = 0
        mouse_input.mi.dwExtraInfo = None

        # Enviar INPUT
        result = ctypes.windll.user32.SendInput(1, ctypes.byref(mouse_input), ctypes.sizeof(INPUT))

        if result == 1:
            if delta_y == 0:
                print(f"   ‚úÖ SendInput bem-sucedido para {direction_name}")
            else:
                direction_y = "CIMA" if delta_y < 0 else "BAIXO"
                print(f"   ‚úÖ SendInput 3D bem-sucedido: {direction_name} + {direction_y}")
            return True
        else:
            print(f"   ‚ùå SendInput falhou (c√≥digo: {result})")
            return False

    except Exception as e:
        print(f"   ‚ùå Erro SendInput: {e}")
        return False

def camera_turn_drag(direction, intensity=300):
    """M√©todo tradicional mouse drag (fallback)"""
    print(f"   üéØ Usando mouse drag tradicional")

    try:
        # Posi√ß√£o central da tela
        center_x, center_y = 960, 540

        # Calcular destino baseado na dire√ß√£o
        if direction == 'left':
            end_x = center_x - intensity
            direction_name = "ESQUERDA"
        elif direction == 'right':
            end_x = center_x + intensity
            direction_name = "DIREITA"
        else:
            error_msg = f"‚ùå Dire√ß√£o inv√°lida em camera_turn_drag: '{direction}' (tipo: {type(direction)})"
            print(error_msg)
            if SESSION_LOG:
                SESSION_LOG.error(error_msg)
            return False

        # MOUSE DRAG tradicional
        pyautogui.moveTo(center_x, center_y)
        time.sleep(0.1)
        pyautogui.mouseDown()
        time.sleep(0.05)
        pyautogui.dragTo(end_x, center_y, duration=0.2)
        time.sleep(0.05)
        pyautogui.mouseUp()

        print(f"   ‚úÖ Mouse drag para {direction_name}")
        return True

    except Exception as e:
        print(f"   ‚ùå Erro mouse drag: {e}")
        return False

def run_pulover_macro(macro_file):
    """Executar macro do Pulover's Macro Creator"""
    try:
        # Procurar pelo execut√°vel do Pulover
        pulover_paths = [
            r"C:\Program Files\Pulover's Macro Creator\MacroCreator.exe",
            r"C:\Program Files (x86)\Pulover's Macro Creator\MacroCreator.exe",
            "MacroCreator.exe"  # Se estiver no PATH
        ]

        pulover_exe = None
        for path in pulover_paths:
            if os.path.exists(path):
                pulover_exe = path
                break

        if not pulover_exe:
            print("‚ùå Pulover's Macro Creator n√£o encontrado!")
            return False

        # Executar macro
        print(f"‚ñ∂Ô∏è Executando macro: {macro_file}")
        result = subprocess.run([pulover_exe, "/r", macro_file],
                              capture_output=True, text=True, timeout=30)

        if result.returncode == 0:
            print("‚úÖ Macro executada com sucesso!")
            return True
        else:
            print(f"‚ùå Erro ao executar macro: {result.stderr}")
            return False

    except subprocess.TimeoutExpired:
        print("‚è±Ô∏è Timeout - Macro demorou mais de 30s")
        return False
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        return False

def run_ahk_script(script_file):
    """Executar script AutoHotkey (.ahk)"""
    try:
        # Procurar pelo AutoHotkey
        ahk_paths = [
            r"C:\Program Files\AutoHotkey\AutoHotkey.exe",
            r"C:\Program Files (x86)\AutoHotkey\AutoHotkey.exe",
            "AutoHotkey.exe"  # Se estiver no PATH
        ]

        ahk_exe = None
        for path in ahk_paths:
            if os.path.exists(path):
                ahk_exe = path
                break

        if not ahk_exe:
            print("‚ùå AutoHotkey n√£o encontrado!")
            return False

        # Executar script
        print(f"‚ñ∂Ô∏è Executando script AHK: {script_file}")
        result = subprocess.run([ahk_exe, script_file],
                              capture_output=True, text=True, timeout=10)

        print("‚úÖ Script AHK executado!")
        return True

    except subprocess.TimeoutExpired:
        print("‚è±Ô∏è Timeout - Script AHK demorou mais de 10s")
        return False
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        return False

# =============================================================================
# üîß FUN√á√ïES AUXILIARES CONSOLIDADAS (REFATORA√á√ÉO)
# =============================================================================

def load_template_safe(template_path):
    """üîß REFATORADA: Carregar template com valida√ß√£o (substitui 19 repeti√ß√µes)"""
    try:
        import cv2
        template = cv2.imread(template_path, cv2.IMREAD_COLOR)
        if template is None:
            print(f"‚ùå Template n√£o encontrado: {template_path}")
            return None
        return template
    except Exception as e:
        print(f"‚ùå Erro ao carregar template {template_path}: {e}")
        return None

def capture_screen_safe(region=None):
    """üîß REFATORADA: Capturar tela com MSS (substitui 21 repeti√ß√µes)"""
    try:
        import mss
        import numpy as np
        import cv2

        # Regi√£o padr√£o (tela inteira) se n√£o especificada
        if region is None:
            region = {"top": 0, "left": 0, "width": 1920, "height": 1080}

        with mss.mss() as sct:
            screenshot = sct.grab(region)
            img_array = np.array(screenshot)

            # Converter BGRA para BGR se necess√°rio
            if img_array.shape[2] == 4:
                return cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
            return img_array

    except Exception as e:
        print(f"‚ùå Erro na captura de tela: {e}")
        return None

def match_template_safe(screen_img, template_path, threshold=0.7):
    """üîß REFATORADA: Template matching com valida√ß√£o (substitui 20 repeti√ß√µes)"""
    try:
        import cv2

        # Carregar template
        template = load_template_safe(template_path)
        if template is None:
            return False, 0.0, (0, 0)

        # Converter para escala de cinza
        screen_gray = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
        template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

        # Template matching
        result = cv2.matchTemplate(screen_gray, template_gray, cv2.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

        if max_val >= threshold:
            # Calcular centro do template
            template_h, template_w = template_gray.shape
            center_x = max_loc[0] + template_w // 2
            center_y = max_loc[1] + template_h // 2
            return True, max_val, (center_x, center_y)

        return False, max_val, (0, 0)

    except Exception as e:
        print(f"‚ùå Erro no template matching {template_path}: {e}")
        return False, 0.0, (0, 0)

# =============================================================================
# üìê CONSTANTES CONSOLIDADAS (REFATORA√á√ÉO)
# =============================================================================

# Coordenadas importantes
INVENTORY_CHEST_DIVIDER_X = 1233  # Linha que separa invent√°rio do ba√∫ (atualizado)
SCREEN_CENTER_X = 960
SCREEN_CENTER_Y = 540
EAT_POSITION_DEFAULT = [1083, 373]  # Posi√ß√£o padr√£o do bot√£o eat
FULL_SCREEN_REGION = {"top": 0, "left": 0, "width": 1920, "height": 1080}

# Thresholds padr√£o
DEFAULT_TEMPLATE_THRESHOLD = 0.7
HIGH_CONFIDENCE_THRESHOLD = 0.8
LOW_CONFIDENCE_THRESHOLD = 0.6

# =============================================================================
# üéØ SISTEMA DE CONFIAN√áA PARA TEMPLATES
# =============================================================================
class TemplateConfidenceManager:
    """Gerenciador de configura√ß√µes de confian√ßa para template matching"""

    def __init__(self, config_path='config.json'):
        self.config_path = config_path
        self.template_confidence = {}
        self.temp_confidence = {}  # Cache tempor√°rio para preview
        # üìÅ TODOS OS 47 TEMPLATES DA PASTA (mapeamento arquivo ‚Üí nome interno)
        self.template_files = {
            # ‚ö° DETEC√á√ïES CR√çTICAS
            'catch.png': 'peixe_capturado',
            'inventory.png': 'inventario_aberto',
            'loot.png': 'barril_aberto',

            # üé£ SISTEMA DE VARAS - COM ISCA (5 varia√ß√µes)
            'varacomisca.png': 'vara_com_isca_1',
            'comiscavara.png': 'vara_com_isca_2',
            'namaocomisca.png': 'vara_com_isca_3',
            'comiscanamao.png': 'vara_com_isca_4',
            'VARANOBAUCI.png': 'vara_com_isca_5',

            # üé£ SISTEMA DE VARAS - SEM ISCA (5 varia√ß√µes)
            'varasemisca.png': 'vara_sem_isca_1',
            'semiscavara.png': 'vara_sem_isca_2',
            'semiscanam.png': 'vara_sem_isca_3',
            'namaosemisca.png': 'vara_sem_isca_4',
            'enbausi.png': 'vara_sem_isca_5',

            # üé£ VARA QUEBRADA
            'varaquebrada.png': 'vara_quebrada',

            # üêü PEIXES (8 tipos + varia√ß√µes)
            'anchovy.png': 'anchova',
            'salmon.png': 'salmao_1',
            'SALMONN.png': 'salmao_2',
            'sardine.png': 'sardinha',
            'smalltrout.png': 'truta_1',
            'TROUTT.png': 'truta_2',
            'shark.png': 'tubarao',
            'herring.png': 'arenque',
            'yellowperch.png': 'perca_amarela',
            'peixecru.png': 'peixe_cru_1',
            'rawfish.png': 'peixe_cru_2',

            # ü•© ISCAS E CARNES (varia√ß√µes)
            'wolfmeat.png': 'carne_lobo_1',
            'carnedelobu.png': 'carne_lobo_2',
            'carneurso.png': 'carne_urso_1',
            'carnedeurso.png': 'carne_urso_2',
            'worm.png': 'minhoca',
            'grub.png': 'isca_1',
            'gruub.png': 'isca_2',

            # üçñ ALIMENTA√á√ÉO (varia√ß√µes)
            'eat.png': 'comer',
            'filefrito.png': 'file_frito_1',
            'frito.png': 'file_frito_2',

            # üì¶ CONTAINERS (todas as caixas)
            'largebox.png': 'caixa_grande',
            'salmonbox.png': 'caixa_salmao',
            'smalltroutbox.png': 'caixa_truta',
            'yellowperchbox.png': 'caixa_perca',
            'wolfmeatbox.png': 'caixa_lobo',
            'grubbox.png': 'caixa_grub',
            'wormbox.png': 'caixa_worm',

            # üîß OUTROS ITENS
            'scrap.png': 'scrap',
            'flare.png': 'sinalizador',
            'bluecard.png': 'cartao_azul',
            'gut.png': 'gut',

            # üíÄ ITENS ESPECIAIS
            'bullet.png': 'bullet',
            'BONE.png': 'BONE',
            'fat.png': 'fat',

            # ‚ö†Ô∏è ALERTAS E ATEN√á√ÉO
            'atencao.png': 'atencao'
        }

        # Lista de nomes internos para compatibilidade
        self.template_names = list(self.template_files.values())
        self.load_template_confidence()

    def load_template_confidence(self):
        """Carregar configura√ß√µes do config.json"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
                self.template_confidence = config.get('template_confidence', {})

            # Se n√£o existe, criar com valores padr√£o
            if not self.template_confidence:
                self.set_default_confidence()
                self.save_template_confidence()
                print("üìä Configura√ß√µes de confian√ßa de templates criadas com valores padr√£o")
            else:
                print(f"‚úÖ Configura√ß√µes de confian√ßa carregadas: {len(self.template_confidence)} templates")

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao carregar configura√ß√µes de template: {e}")
            self.set_default_confidence()

    def set_default_confidence(self):
        """Definir valores padr√£o de confian√ßa"""
        # üéØ VALORES PADR√ÉO BASEADOS NAS CONFIGURA√á√ïES SALVAS PELO USU√ÅRIO
        default_values = {
            # ‚ö° DETEC√á√ïES CR√çTICAS
            'peixe_capturado': 0.8,
            'inventario_aberto': 0.8,
            'barril_aberto': 0.8,

            # üé£ VARAS COM ISCA - valores ajustados pelo usu√°rio
            'vara_com_isca_1': 0.8,   # varacomisca.png
            'vara_com_isca_2': 0.8,   # comiscavara.png
            'vara_com_isca_3': 0.8,   # namaocomisca.png
            'vara_com_isca_4': 0.8,   # comiscanamao.png
            'vara_com_isca_5': 0.73,  # VARANOBAUCI.png - ajustado

            # üé£ VARAS SEM ISCA - valores ajustados pelo usu√°rio
            'vara_sem_isca_1': 0.7,   # varasemisca.png
            'vara_sem_isca_2': 0.7,   # semiscavara.png
            'vara_sem_isca_3': 0.7,   # semiscanam.png
            'vara_sem_isca_4': 0.7,   # namaosemisca.png
            'vara_sem_isca_5': 0.7,   # enbausi.png - threshold reduzido para detectar mais

            # üé£ VARA QUEBRADA
            'vara_quebrada': 0.7,     # varaquebrada.png

            # üêü PEIXES - todas as varia√ß√µes
            'anchova': 0.7,           # anchovy.png
            'salmao_1': 0.7,          # salmon.png
            'salmao_2': 0.7,          # SALMONN.png
            'sardinha': 0.7,          # sardine.png
            'truta_1': 0.7,           # smalltrout.png
            'truta_2': 0.7,           # TROUTT.png
            'tubarao': 0.7,           # shark.png
            'arenque': 0.7,           # herring.png
            'perca_amarela': 0.7,     # yellowperch.png
            'peixe_cru_1': 0.6,       # peixecru.png
            'peixe_cru_2': 0.75,      # rawfish.png - ajustado

            # ü•© ISCAS E CARNES - valores ajustados pelo usu√°rio
            'carne_lobo_1': 0.7,      # wolfmeat.png
            'carne_lobo_2': 0.7,      # carnedelobu.png
            'carne_urso_1': 0.7,      # carneurso.png
            'carne_urso_2': 0.7,      # carnedeurso.png
            'minhoca': 0.6,           # worm.png
            'isca_1': 0.6,            # grub.png
            'isca_2': 0.65,           # gruub.png - ajustado

            # üçñ ALIMENTA√á√ÉO - todas as varia√ß√µes
            'comer': 0.8,             # eat.png
            'file_frito_1': 0.8,      # filefrito.png
            'file_frito_2': 0.8,      # frito.png

            # üì¶ CONTAINERS - valores ajustados pelo usu√°rio
            'caixa_grande': 0.6,      # largebox.png
            'caixa_salmao': 0.6,      # salmonbox.png
            'caixa_truta': 0.6,       # smalltroutbox.png
            'caixa_perca': 0.6,       # yellowperchbox.png
            'caixa_lobo': 0.6,        # wolfmeatbox.png
            'caixa_grub': 0.75,       # grubbox.png - ajustado
            'caixa_worm': 0.6,        # wormbox.png

            # üîß OUTROS ITENS
            'scrap': 0.5,             # scrap.png
            'sinalizador': 0.6,       # flare.png
            'cartao_azul': 0.6,       # bluecard.png
            'gut': 0.6,               # gut.png

            # üíÄ ITENS ESPECIAIS - valores ajustados pelo usu√°rio
            'bullet': 0.5,            # bullet.png
            'BONE': 0.6,              # BONE.png
            'fat': 0.8,               # fat.png - ajustado

            # ‚ö†Ô∏è ALERTAS E ATEN√á√ÉO
            'atencao': 0.8            # atencao.png
        }

        self.template_confidence = default_values.copy()

    def save_template_confidence(self):
        """Salvar configura√ß√µes no config.json"""
        try:
            # Carregar config existente
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
            except:
                config = {}

            # Atualizar se√ß√£o template_confidence
            config['template_confidence'] = self.template_confidence

            # Salvar arquivo
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)

            return True

        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes de template: {e}")
            return False

    def update_confidence_temp(self, template_name, confidence_value):
        """Atualizar confian√ßa APENAS tempor√°rio (para preview)"""
        if template_name in self.template_names:
            self.temp_confidence[template_name] = round(confidence_value, 2)
            print(f"üîç Preview: {template_name} = {confidence_value:.2f} (tempor√°rio)")
            return True
        else:
            print(f"‚ö†Ô∏è Template '{template_name}' n√£o encontrado")
            return False
    
    def update_confidence_live(self, template_name, confidence_value):
        """Atualizar confian√ßa ao vivo e salvar"""
        if template_name in self.template_names:
            old_value = self.template_confidence.get(template_name, 0.7)
            self.template_confidence[template_name] = round(confidence_value, 2)
            
            # Sincronizar cache tempor√°rio tamb√©m
            self.temp_confidence[template_name] = round(confidence_value, 2)

            if self.save_template_confidence():
                print(f"üíæ Confian√ßa salva: {template_name} = {old_value:.2f} ‚Üí {confidence_value:.2f}")
                return True
            else:
                # Reverter se n√£o conseguiu salvar
                self.template_confidence[template_name] = old_value
                self.temp_confidence[template_name] = old_value
                print(f"‚ùå Falha ao salvar confian√ßa para {template_name}")
                return False
        else:
            print(f"‚ö†Ô∏è Template desconhecido: {template_name}")
            return False

    def get_template_confidence(self, template_name):
        """Obter confian√ßa para um template espec√≠fico (prioriza cache tempor√°rio)"""
        # Primeiro verifica se h√° valor tempor√°rio (preview)
        if template_name in self.temp_confidence:
            return self.temp_confidence[template_name]
        # Sen√£o usa o valor salvo
        return self.template_confidence.get(template_name, 0.7)  # Default 0.7

    def get_all_confidences(self):
        """Obter todas as configura√ß√µes de confian√ßa"""
        return self.template_confidence.copy()

    def get_template_names(self):
        """Obter lista de todos os nomes de templates"""
        return self.template_names.copy()

    def get_template_filename(self, template_name):
        """Obter nome do arquivo .png para um template"""
        for filename, internal_name in self.template_files.items():
            if internal_name == template_name:
                return filename
        return None

    def get_template_files_dict(self):
        """Obter dicion√°rio completo arquivo ‚Üí nome interno"""
        return self.template_files.copy()

# =============================================================================
# üéØ GERENCIADOR CENTRALIZADO DE TEMPLATES (SINGLETON)
# =============================================================================
class TemplateManager:
    """Singleton para gerenciar cache centralizado de templates"""
    _instance = None
    _templates_cache = {}
    _loaded = False
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.templates_folder = "templates"
            self.initialized = True
            print("üéØ TemplateManager inicializado (singleton)")
    
    def load_all_templates(self, force_reload=False):
        """Carregar todos os templates UMA VEZ na mem√≥ria"""
        with self._lock:
            if self._loaded and not force_reload:
                print(f"‚úÖ Templates j√° carregados: {len(self._templates_cache)}")
                return True
                
            print("üîÑ Carregando templates centralizados...")
            
            if not os.path.exists(self.templates_folder):
                print(f"‚ùå Pasta {self.templates_folder} n√£o encontrada!")
                return False
            
            import glob
            template_files = glob.glob(os.path.join(self.templates_folder, "*.png"))
            
            if not template_files:
                print("‚ùå Nenhum template .png encontrado!")
                return False
            
            # Limpar cache anterior se reload
            if force_reload:
                self.clear_cache()
            
            loaded_count = 0
            for template_path in template_files:
                template_name = os.path.basename(template_path)
                
                try:
                    template_image = cv2.imread(template_path)
                    
                    if template_image is not None:
                        self._templates_cache[template_name] = {
                            'image': template_image,
                            'path': template_path,
                            'height': template_image.shape[0],
                            'width': template_image.shape[1],
                            'loaded_at': time.time()
                        }
                        loaded_count += 1
                    else:
                        print(f"‚ö†Ô∏è Falha ao carregar: {template_name}")
                        
                except Exception as e:
                    print(f"‚ùå Erro ao carregar {template_name}: {e}")
            
            self._loaded = True
            print(f"‚úÖ Templates carregados: {loaded_count}/{len(template_files)}")
            return loaded_count > 0
    
    def get_template(self, template_name):
        """Obter template da cache (sem I/O)"""
        if not self._loaded:
            self.load_all_templates()
        
        return self._templates_cache.get(template_name)
    
    def get_template_image(self, template_name):
        """Obter apenas a imagem do template"""
        template_data = self.get_template(template_name)
        return template_data['image'] if template_data else None
    
    def get_all_templates(self):
        """Obter todos os templates carregados"""
        if not self._loaded:
            self.load_all_templates()
        
        return self._templates_cache.copy()
    
    def get_template_names(self):
        """Obter lista de nomes dos templates"""
        if not self._loaded:
            self.load_all_templates()
        
        return list(self._templates_cache.keys())
    
    def is_loaded(self):
        """Verificar se templates est√£o carregados"""
        return self._loaded and len(self._templates_cache) > 0
    
    def get_cache_size(self):
        """Obter quantidade de templates em cache"""
        return len(self._templates_cache)
    
    def clear_cache(self):
        """Limpar cache de templates"""
        with self._lock:
            print("üßπ Limpando cache de templates...")
            
            # Liberar mem√≥ria das imagens
            for template_data in self._templates_cache.values():
                if 'image' in template_data:
                    del template_data['image']
            
            self._templates_cache.clear()
            self._loaded = False
            print("‚úÖ Cache de templates limpo")
    
    def reload_templates(self):
        """Recarregar todos os templates"""
        print("üîÑ Recarregando templates...")
        return self.load_all_templates(force_reload=True)
    
    def get_memory_usage(self):
        """Calcular uso aproximado de mem√≥ria dos templates"""
        total_bytes = 0
        for template_data in self._templates_cache.values():
            if 'image' in template_data:
                img = template_data['image']
                # bytes = height * width * channels * dtype_size
                total_bytes += img.shape[0] * img.shape[1] * img.shape[2] * img.itemsize
        
        return total_bytes
    
    def get_stats(self):
        """Obter estat√≠sticas do cache"""
        return {
            'loaded': self._loaded,
            'count': len(self._templates_cache),
            'memory_mb': self.get_memory_usage() / (1024 * 1024),
            'names': list(self._templates_cache.keys())
        }

# =============================================================================
# üé¨ GRAVADOR DE MACRO NATIVO
# =============================================================================
class MacroRecorder:
    def __init__(self):
        self.recording = False
        self.actions = []
        self.start_time = None
        self.real_recording = False  # Flag para grava√ß√£o real
        self.mouse_listener = None
        self.keyboard_listener = None
        self.initial_mouse_pos = None

    def start_recording(self):
        """Iniciar grava√ß√£o de macro SIMPLIFICADO"""
        print("üî¥ GRAVA√á√ÉO SIMPLIFICADA INICIADA!")
        print("üí° INSTRU√á√ïES:")
        print("   1. Pressione ALT")
        print("   2. Mova o mouse para posi√ß√£o desejada")
        print("   3. Pressione E")
        print("   4. Solte ALT")
        print("   5. Pressione F3 para PARAR")
        print("")

        self.recording = True
        self.actions = []
        self.start_time = time.time()

        # Gravar sequ√™ncia simplificada
        self._record_simple_sequence()

    def _record_simple_sequence(self):
        """Gravar sequ√™ncia simplificada capturando movimento real"""
        from pynput import mouse, keyboard

        print("üé¨ GRAVA√á√ÉO SIMPLIFICADA ATIVA!")
        print("   Esperando sequ√™ncia ALT + movimento + E...")

        self.alt_pressed = False
        self.start_pos = None
        self.end_pos = None

        def on_key_press(key):
            """Detectar teclas importantes"""
            if not self.recording:
                return False

            try:
                key_name = key.char
            except AttributeError:
                key_name = str(key).replace('Key.', '')

            # Detectar ALT
            if key_name in ['alt_l', 'alt', 'alt_r']:
                if not self.alt_pressed:
                    self.alt_pressed = True
                    self.start_pos = pyautogui.position()
                    print(f"   üìç ALT pressionado - Posi√ß√£o inicial: {self.start_pos}")

            # Detectar E
            elif key_name == 'e' and self.alt_pressed:
                self.end_pos = pyautogui.position()
                print(f"   üìç E pressionado - Posi√ß√£o final: {self.end_pos}")

            # F3 para parar
            elif key_name == 'f3':
                return False

        def on_key_release(key):
            """Detectar soltura do ALT"""
            if not self.recording:
                return False

            try:
                key_name = key.char
            except AttributeError:
                key_name = str(key).replace('Key.', '')

            if key_name in ['alt_l', 'alt', 'alt_r']:
                if self.alt_pressed and self.start_pos and self.end_pos:
                    # Calcular movimento
                    dx = self.end_pos.x - self.start_pos.x
                    dy = self.end_pos.y - self.start_pos.y

                    print(f"   üìπ MOVIMENTO CAPTURADO:")
                    print(f"      In√≠cio: ({self.start_pos.x}, {self.start_pos.y})")
                    print(f"      Fim: ({self.end_pos.x}, {self.end_pos.y})")
                    print(f"      Deslocamento: DX={dx}, DY={dy}")

                    # Criar sequ√™ncia otimizada
                    self.actions = [
                        {'type': 'key', 'key': 'alt_down', 'time': 0.0},
                        {'type': 'wait', 'duration': 0.5, 'time': 0.5},
                        {'type': 'camera_move', 'dx': dx, 'dy': dy, 'time': 1.0},
                        {'type': 'wait', 'duration': 0.3, 'time': 1.3},
                        {'type': 'key', 'key': 'e', 'time': 1.6},
                        {'type': 'wait', 'duration': 0.5, 'time': 2.1},
                        {'type': 'key', 'key': 'alt_up', 'time': 2.6}
                    ]

                    print("   ‚úÖ Sequ√™ncia gravada com sucesso!")
                    self.alt_pressed = False

        # Criar listener de teclado
        self.keyboard_listener = keyboard.Listener(
            on_press=on_key_press,
            on_release=on_key_release
        )

        self.keyboard_listener.start()

    def _start_real_recording(self):
        """Iniciar grava√ß√£o real de eventos do mouse e teclado"""
        from pynput import mouse, keyboard

        print("üé¨ GRAVA√á√ÉO REAL ATIVADA!")
        print("   üìç Capturando movimentos do mouse...")
        print("   ‚å®Ô∏è Capturando teclas...")

        # Vari√°veis para rastrear movimento
        self.last_mouse_time = time.time()
        self.mouse_start_pos = None
        self.mouse_movements = []

        def on_move(x, y):
            """Capturar movimento do mouse"""
            if self.recording and self.real_recording:
                current_time = time.time() - self.start_time

                # Registrar apenas movimentos significativos
                if not self.mouse_start_pos:
                    self.mouse_start_pos = (x, y)
                    print(f"   üñ±Ô∏è Posi√ß√£o inicial: ({x}, {y})")

                # Acumular movimentos para detectar dire√ß√£o
                self.mouse_movements.append((x, y, current_time))

        def on_click(x, y, button, pressed):
            """Capturar cliques do mouse"""
            if self.recording and self.real_recording:
                current_time = time.time() - self.start_time
                action = {
                    'type': 'click',
                    'x': x,
                    'y': y,
                    'button': str(button),
                    'pressed': pressed,
                    'time': current_time
                }
                self.actions.append(action)
                print(f"   üñ±Ô∏è Click: {button} {'pressionado' if pressed else 'solto'} em ({x}, {y})")

        def on_key_press(key):
            """Capturar teclas pressionadas"""
            if self.recording and self.real_recording:
                current_time = time.time() - self.start_time

                try:
                    key_name = key.char
                except AttributeError:
                    key_name = str(key).replace('Key.', '')

                # Ignorar F3 para n√£o interferir
                if key_name == 'f3':
                    return

                action = {
                    'type': 'key_press',
                    'key': key_name,
                    'time': current_time
                }
                self.actions.append(action)
                print(f"   ‚å®Ô∏è Tecla pressionada: {key_name}")

                # Detectar ALT para movimento de c√¢mera
                if key_name == 'alt_l' or key_name == 'alt':
                    self.mouse_start_pos = pyautogui.position()
                    print(f"   üìπ ALT detectado - iniciando captura de movimento")

        def on_key_release(key):
            """Capturar teclas soltas"""
            if self.recording and self.real_recording:
                current_time = time.time() - self.start_time

                try:
                    key_name = key.char
                except AttributeError:
                    key_name = str(key).replace('Key.', '')

                if key_name == 'f3':
                    return

                action = {
                    'type': 'key_release',
                    'key': key_name,
                    'time': current_time
                }
                self.actions.append(action)
                print(f"   ‚å®Ô∏è Tecla solta: {key_name}")

                # Detectar soltura do ALT para calcular movimento total
                if key_name == 'alt_l' or key_name == 'alt':
                    if self.mouse_movements:
                        self._calculate_camera_movement()

        # Criar listeners
        self.mouse_listener = mouse.Listener(
            on_move=on_move,
            on_click=on_click
        )
        self.keyboard_listener = keyboard.Listener(
            on_press=on_key_press,
            on_release=on_key_release
        )

        # Iniciar listeners
        self.mouse_listener.start()
        self.keyboard_listener.start()

    def _calculate_camera_movement(self):
        """Calcular dire√ß√£o e intensidade do movimento da c√¢mera"""
        if not self.mouse_movements or not self.mouse_start_pos:
            return

        # Pegar primeira e √∫ltima posi√ß√£o
        start_x, start_y = self.mouse_start_pos
        end_x, end_y, end_time = self.mouse_movements[-1][:3]

        # Calcular deslocamento
        dx = end_x - start_x
        dy = end_y - start_y

        # Determinar dire√ß√£o principal
        if abs(dx) > abs(dy):
            # Movimento horizontal predominante
            if dx > 0:
                direction = 'right'
                intensity = abs(dx)
            else:
                direction = 'left'
                intensity = abs(dx)
        else:
            # Movimento vertical predominante
            if dy > 0:
                direction = 'down'
                intensity = abs(dy)
            else:
                direction = 'up'
                intensity = abs(dy)

        # Adicionar movimento de c√¢mera √†s a√ß√µes
        action = {
            'type': 'camera_turn',
            'direction': direction,
            'intensity': int(intensity),
            'dx': int(dx),
            'dy': int(dy),
            'time': end_time
        }
        self.actions.append(action)

        print(f"   üìπ MOVIMENTO DETECTADO:")
        print(f"      In√≠cio: ({start_x}, {start_y})")
        print(f"      Fim: ({end_x}, {end_y})")
        print(f"      Deslocamento: X={dx}, Y={dy}")
        print(f"      Dire√ß√£o: {direction}, Intensidade: {intensity:.0f}px")

        # Limpar para pr√≥ximo movimento
        self.mouse_movements = []
        self.mouse_start_pos = None

    def _create_smart_macro(self):
        """Criar macro inteligente baseado na configura√ß√£o"""
        print("üß† Gerando macro INTELIGENTE...")

        # Ler configura√ß√£o do usu√°rio
        try:
            with open('config.json', 'r') as f:
                config = json.load(f)

            chest_side = config.get('chest_side', 'left')
            intensity = config.get('chest_distance', 300)

            print(f"   üìã Lado do ba√∫: {chest_side}")
            print(f"   üìè Intensidade: {intensity}px")

            # Gerar sequ√™ncia otimizada
            self.actions = [
                {'type': 'key', 'key': 'alt_down', 'time': 0.0},
                {'type': 'wait', 'duration': 0.5, 'time': 0.5},
                {'type': 'camera_turn', 'direction': chest_side, 'intensity': intensity, 'time': 1.0},
                {'type': 'wait', 'duration': 0.3, 'time': 1.3},
                {'type': 'key', 'key': 'e', 'time': 1.6},
                {'type': 'wait', 'duration': 0.5, 'time': 2.1},
                {'type': 'key', 'key': 'alt_up', 'time': 2.6}
            ]

            print("‚úÖ Macro INTELIGENTE gerado!")

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar macro: {e}")
            # Macro padr√£o
            self.actions = [
                {'type': 'key', 'key': 'alt_down', 'time': 0.0},
                {'type': 'camera_turn', 'direction': 'left', 'intensity': 300, 'time': 0.5},
                {'type': 'key', 'key': 'e', 'time': 1.0},
                {'type': 'key', 'key': 'alt_up', 'time': 1.5}
            ]

    def stop_recording(self):
        """Parar grava√ß√£o e salvar macro"""
        if not self.recording:
            print("‚ö†Ô∏è Nenhuma grava√ß√£o ativa!")
            return

        self.recording = False
        self.real_recording = False

        # Parar listeners se existirem
        if hasattr(self, 'mouse_listener') and self.mouse_listener:
            self.mouse_listener.stop()
            self.mouse_listener = None
        if hasattr(self, 'keyboard_listener') and self.keyboard_listener:
            self.keyboard_listener.stop()
            self.keyboard_listener = None

        total_time = time.time() - self.start_time if self.start_time else 0

        print("‚èπÔ∏è GRAVA√á√ÉO FINALIZADA!")
        print(f"üìä Total de a√ß√µes: {len(self.actions)}")
        print(f"‚è±Ô∏è Dura√ß√£o: {total_time:.2f}s")

        # Mostrar resumo das a√ß√µes
        if len(self.actions) > 0:
            print("\nüìù RESUMO DAS A√á√ïES:")
            for i, action in enumerate(self.actions[:5]):
                print(f"   {i+1}. {action}")
            if len(self.actions) > 5:
                print(f"   ... e mais {len(self.actions)-5} a√ß√µes")

        if len(self.actions) > 0:
            self._save_macro()
        else:
            print("‚ö†Ô∏è Nenhuma a√ß√£o gravada!")

    def _save_macro(self):
        """Salvar macro em arquivo"""
        try:
            # Salvar em formato pickle
            with open('recorded_macro.pkl', 'wb') as f:
                pickle.dump(self.actions, f)

            # Salvar em formato texto leg√≠vel
            with open('recorded_macro.txt', 'w', encoding='utf-8') as f:
                f.write("# MACRO GRAVADO AUTOMATICAMENTE\n")
                f.write(f"# Total de a√ß√µes: {len(self.actions)}\n\n")

                for i, action in enumerate(self.actions):
                    f.write(f"{i+1:03d}: {action}\n")

            print("üíæ Macro salvo em:")
            print("   üìÅ recorded_macro.pkl (execut√°vel)")
            print("   üìÅ recorded_macro.txt (leg√≠vel)")
            print("üí° Use F8 para executar o macro gravado!")

        except Exception as e:
            print(f"‚ùå Erro ao salvar macro: {e}")

    def play_macro(self):
        """Reproduzir macro gravado"""
        if not os.path.exists('recorded_macro.pkl'):
            print("‚ùå Nenhum macro gravado encontrado!")
            print("üí° Use F3 para gravar um macro primeiro")
            return

        try:
            # Carregar a√ß√µes
            with open('recorded_macro.pkl', 'rb') as f:
                actions = pickle.load(f)

            print("‚ñ∂Ô∏è REPRODUZINDO MACRO INTELIGENTE...")
            print(f"üìä Total de a√ß√µes: {len(actions)}")

            start_time = time.time()

            for i, action in enumerate(actions):
                print(f"   üìç A√ß√£o {i+1}/{len(actions)}: {action['type']}")

                # Aguardar timing correto
                target_time = action['time']
                current_time = time.time() - start_time
                wait_time = target_time - current_time

                if wait_time > 0:
                    time.sleep(wait_time)

                # Executar a√ß√£o baseada no tipo
                if action['type'] == 'key':
                    key = action['key']
                    if key == 'alt_down':
                        print("      ‚å®Ô∏è ALT Down")
                        focus_game_window()  # Garantir foco antes de pressionar ALT
                        pyautogui.keyDown('alt')
                    elif key == 'alt_up':
                        print("      ‚å®Ô∏è ALT Up")
                        focus_game_window()  # Garantir foco
                        pyautogui.keyUp('alt')
                    elif key == 'e':
                        print("      ‚å®Ô∏è Tecla E")
                        focus_game_window()  # Garantir foco antes de pressionar E
                        pyautogui.press('e')

                elif action['type'] == 'camera_turn':
                    direction = action.get('direction', '')
                    intensity = action.get('intensity', 0)
                    dx = action.get('dx', 0)
                    dy = action.get('dy', 0)

                    print(f"      üìπ Movimento de c√¢mera:")
                    print(f"         Dire√ß√£o: {direction}")
                    print(f"         Intensidade: {intensity}px")
                    print(f"         Deslocamento: X={dx}, Y={dy}")

                    # Se tiver dx e dy, usar movimento direto
                    if dx != 0 or dy != 0:
                        try:
                            # Movimento direto usando SendInput
                            camera_turn_direct(dx, dy)
                        except Exception as e:
                            print(f"      ‚ùå Erro no movimento direto: {e}")
                            # Fallback para m√©todo antigo
                            if direction and intensity:
                                camera_turn(direction, intensity)
                    else:
                        # Usar m√©todo antigo
                        camera_turn(direction, intensity)

                elif action['type'] == 'camera_move':
                    # Novo tipo simplificado com movimento direto
                    dx = action.get('dx', 0)
                    dy = action.get('dy', 0)

                    print(f"      üìπ Movimento de c√¢mera simplificado:")
                    print(f"         Deslocamento: DX={dx}, DY={dy}")

                    # Usar movimento com ALT pressionado (como no jogo)
                    if dx != 0 or dy != 0:
                        # Movimento simulando o jogo com ALT
                        camera_turn_in_game(dx, dy)

                elif action['type'] == 'wait':
                    duration = action['duration']
                    print(f"      ‚è≥ Aguardar: {duration}s")
                    time.sleep(duration)

                # Tipos legados (compatibilidade)
                elif action['type'] == 'move':
                    pyautogui.moveTo(action['x'], action['y'])

                elif action['type'] == 'click':
                    if action['pressed']:
                        focus_game_window()  # Garantir foco
                        pyautogui.mouseDown(x=action['x'], y=action['y'])
                    else:
                        focus_game_window()  # Garantir foco
                        pyautogui.mouseUp(x=action['x'], y=action['y'])

            print("‚úÖ MACRO INTELIGENTE EXECUTADO COM SUCESSO!")

        except Exception as e:
            print(f"‚ùå Erro ao executar macro: {e}")

# Inst√¢ncia global do gravador
macro_recorder = MacroRecorder()

print("""
    üßô‚Äç‚ôÇÔ∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üé£
          ULTIMATE FISHING BOT v3.0 - INTERFACE SIMPLIFICADA
          Powered by Magic ‚ú® | Licensed
    üåä ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üêü
""")

# =============================================================================
# üîê GERENCIADOR DE LICEN√áAS
# =============================================================================
class LicenseManager:
    def __init__(self):
        self.license_file = "license.key"
        self.hardware_id = self.get_hardware_id()
        print(f"üñ•Ô∏è Hardware ID: {self.hardware_id}")

    def get_hardware_id(self):
        """Gerar ID √∫nico da m√°quina"""
        try:
            machine_info = {
                'node': platform.node(),
                'processor': platform.processor(),
                'machine': platform.machine(),
                'system': platform.system(),
                'cpu_count': psutil.cpu_count(),
                'memory': psutil.virtual_memory().total
            }
            combined = json.dumps(machine_info, sort_keys=True)
            return hashlib.sha256(combined.encode()).hexdigest()[:32]
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar Hardware ID: {e}")
            return "UNKNOWN-HARDWARE-ID"

    def load_license(self):
        """Carregar licen√ßa salva"""
        try:
            if os.path.exists(self.license_file):
                with open(self.license_file, 'r') as f:
                    return f.read().strip()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao carregar licen√ßa: {e}")
        return None

    def save_license(self, key):
        """Salvar licen√ßa"""
        try:
            with open(self.license_file, 'w') as f:
                f.write(key)
            print("üíæ Licen√ßa salva com sucesso!")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao salvar licen√ßa: {e}")

    def activate(self, key):
        """Ativar licen√ßa no servidor"""
        print(f"üîê Ativando chave: {key[:10]}...")

        try:
            data = {
                'activation_key': key,
                'hardware_id': self.hardware_id,
                'project_id': PROJECT_ID
            }

            print(f"üì§ Enviando para: {ACTIVATION_SERVER}/activate")
            print(f"üìã Hardware ID: {self.hardware_id}")

            # Adicionar headers para melhor compatibilidade
            headers = {
                'Content-Type': 'application/json',
                'User-Agent': 'UltimateFishingBot/3.0'
            }

            response = requests.post(f"{ACTIVATION_SERVER}/activate",
                                   json=data, headers=headers, timeout=15)

            print(f"üì• Status Code: {response.status_code}")
            print(f"üìÑ Response: {response.text[:200]}...")

            if response.status_code == 200:
                try:
                    result = response.json()
                    # Corrigido: verificar 'valid' ao inv√©s de 'success'
                    if result.get('valid', False):
                        self.save_license(key)
                        print("‚úÖ Ativa√ß√£o bem-sucedida!")
                        return True, "Ativa√ß√£o realizada com sucesso!"
                    else:
                        error_msg = result.get('message', 'Erro desconhecido na ativa√ß√£o')
                        print(f"‚ùå Falha na ativa√ß√£o: {error_msg}")
                        return False, error_msg
                except ValueError as e:
                    print(f"‚ùå Erro JSON na ativa√ß√£o: {e}")
                    return False, "Resposta inv√°lida do servidor"
            elif response.status_code == 403:
                error_msg = "Chave inv√°lida, expirada ou j√° usada em outro dispositivo"
                print(f"‚ùå {error_msg}")
                return False, error_msg
            elif response.status_code == 400:
                error_msg = "Dados de ativa√ß√£o inv√°lidos"
                print(f"‚ùå {error_msg}")
                return False, error_msg
            else:
                error_msg = f"Servidor retornou {response.status_code}: {response.text}"
                print(f"‚ùå {error_msg}")
                return False, error_msg

        except requests.exceptions.ConnectionError:
            error_msg = "Erro de conex√£o - Verifique sua internet"
            print(f"‚ùå {error_msg}")
            return False, error_msg
        except requests.exceptions.Timeout:
            error_msg = "Timeout - Servidor demorou para responder"
            print(f"‚ùå {error_msg}")
            return False, error_msg
        except Exception as e:
            error_msg = f"Erro na ativa√ß√£o: {str(e)}"
            print(f"‚ùå {error_msg}")
            return False, error_msg

    def validate(self, key):
        """Validar licen√ßa no servidor"""
        print(f"üîç Validando chave: {key[:10]}...")

        try:
            data = {
                'activation_key': key,
                'hardware_id': self.hardware_id,
                'project_id': PROJECT_ID
            }

            print(f"üì§ Enviando dados para: {ACTIVATION_SERVER}/validate")
            print(f"üìã Hardware ID: {self.hardware_id}")

            # Adicionar headers para melhor compatibilidade
            headers = {
                'Content-Type': 'application/json',
                'User-Agent': 'UltimateFishingBot/3.0'
            }

            response = requests.post(f"{ACTIVATION_SERVER}/validate",
                                   json=data, headers=headers, timeout=15)

            print(f"üì• Status Code: {response.status_code}")
            print(f"üìÑ Response: {response.text[:200]}...")

            if response.status_code == 200:
                try:
                    result = response.json()
                    is_valid = result.get('valid', False)
                    print(f"‚úÖ Valida√ß√£o: {'V√°lida' if is_valid else 'Inv√°lida'}")

                    if is_valid:
                        print(f"üìÖ Expira em: {result.get('expires_at', 'N/A')}")
                        print(f"üìä Status: {result.get('status', 'N/A')}")
                        print(f"üéØ Plano: {result.get('plan_name', 'N/A')}")
                        print(f"‚è∞ Dias restantes: {result.get('days_remaining', 'N/A')}")

                    return is_valid, result
                except ValueError as e:
                    print(f"‚ùå Erro JSON: {e}")
                    return False, {'message': 'Resposta inv√°lida do servidor'}
            else:
                error_msg = f'Servidor retornou {response.status_code}: {response.text}'
                print(f"‚ùå {error_msg}")
                return False, {'message': error_msg}

        except requests.exceptions.ConnectionError:
            error_msg = "Erro de conex√£o - Verifique sua internet"
            print(f"‚ùå {error_msg}")
            return False, {'message': error_msg}
        except requests.exceptions.Timeout:
            error_msg = "Timeout - Servidor demorou para responder"
            print(f"‚ùå {error_msg}")
            return False, {'message': error_msg}
        except Exception as e:
            error_msg = f'Erro de valida√ß√£o: {str(e)}'
            print(f"‚ùå {error_msg}")
            return False, {'message': error_msg}

# =============================================================================
# üé® INTERFACE SIMPLES E EST√ÅVEL
# =============================================================================
class SimpleFishingUI:
    def __init__(self, bot):
        self.bot = bot
        self.is_destroyed = False
        
        # üåç SISTEMA DE TRADU√á√ÉO - Rastrear widgets para atualiza√ß√£o din√¢mica
        self.translatable_widgets = {
            'labels': {},      # Labels com texto traduz√≠vel
            'buttons': {},     # Bot√µes com texto traduz√≠vel  
            'frames': {},      # LabelFrames com texto traduz√≠vel
            'checkboxes': {},  # Checkboxes com texto traduz√≠vel
        }

        # Criar janela de forma robusta
        try:
            self.main_window = tk.Tk()
            self.main_window.title("üé£ Ultimate Fishing Bot v3.0")
            self.main_window.geometry("800x800")
            self.main_window.configure(bg='#1a1a1a')
            self.main_window.resizable(True, True)

            # Garantir que a janela apare√ßa
            self.main_window.withdraw()  # Ocultar temporariamente
            self.main_window.update_idletasks()  # Processar eventos pendentes

            # Protocolo para fechar janela
            self.main_window.protocol("WM_DELETE_WINDOW", self.close_window)

            # Criar interface
            self.create_interface()

            # Exibir a janela ap√≥s criar a interface
            self.main_window.deiconify()  # Mostrar janela
            self.main_window.lift()       # Trazer para frente
            self.main_window.focus_force() # For√ßar foco

            # Centralizar na tela
            self.main_window.update_idletasks()
            width = self.main_window.winfo_width()
            height = self.main_window.winfo_height()
            x = (self.main_window.winfo_screenwidth() - width) // 2
            y = (self.main_window.winfo_screenheight() - height) // 2
            self.main_window.geometry(f"{width}x{height}+{x}+{y}")

            # Iniciar atualiza√ß√µes
            self.update_stats()

        except Exception as e:
            print(f"‚ùå Erro ao criar interface: {e}")
            import traceback
            traceback.print_exc()
            raise

    def close_window(self):
        """Fechar janela de forma segura e encerrar aplica√ß√£o"""
        try:
            safe_print("[UI] Fechando aplica√ß√£o...")

            # Parar bot se estiver rodando
            if hasattr(self.bot, 'running') and self.bot.running:
                self.bot.emergency_stop()

            # Fechar threads YOLO
            if hasattr(self, 'yolo_thread_running'):
                self.yolo_thread_running = False

            # üßπ LIMPEZA AUTOM√ÅTICA DE MEM√ìRIA
            self.cleanup_memory()

            self.is_destroyed = True
            self.main_window.destroy()

            # Encerrar aplica√ß√£o completamente (fecha CMD)
            import sys
            sys.exit(0)

        except Exception as e:
            safe_print(f"[ERROR] Erro ao fechar: {e}")
            import sys
            sys.exit(0)

    def cleanup_memory(self):
        """üßπ LIMPEZA AUTOM√ÅTICA DE MEM√ìRIA"""
        try:
            import gc

            print("üßπ Iniciando limpeza de mem√≥ria...")

            # Parar viewers
            if hasattr(self, 'viewer_running'):
                self.viewer_running = False
            if hasattr(self, 'catch_viewer_running'):
                self.catch_viewer_running = False

            # Limpar canvas
            if hasattr(self, 'viewer_canvas'):
                try:
                    if hasattr(self.viewer_canvas, 'image'):
                        del self.viewer_canvas.image
                    self.viewer_canvas.delete("all")
                except:
                    pass

            if hasattr(self, 'catch_canvas'):
                try:
                    if hasattr(self.catch_canvas, 'image'):
                        del self.catch_canvas.image
                    self.catch_canvas.delete("all")
                except:
                    pass

            # Limpar detec√ß√µes armazenadas
            if hasattr(self, 'last_catch_viewer_detections'):
                self.last_catch_viewer_detections.clear()

            # Limpar bot cache se existir
            if hasattr(self, 'bot'):
                if hasattr(self.bot, 'processed_broken_rods'):
                    self.bot.processed_broken_rods.clear()
                if hasattr(self.bot, 'rod_tracking_system'):
                    self.bot.rod_tracking_system.clear()

            # For√ßa garbage collection
            collected = gc.collect()
            print(f"‚úÖ Limpeza conclu√≠da: {collected} objetos removidos da mem√≥ria")

        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza de mem√≥ria: {e}")

    def periodic_memory_cleanup(self, frame_count, viewer_type="GENERIC"):
        """üßπ LIMPEZA PERI√ìDICA DE MEM√ìRIA OTIMIZADA"""
        try:
            import gc
            import psutil
            import os

            # Obter uso atual de mem√≥ria
            process = psutil.Process(os.getpid())
            memory_mb = process.memory_info().rss / 1024 / 1024

            # For√ßa garbage collection
            collected = gc.collect()

            # Log apenas se coletou algo significativo ou alta mem√≥ria
            if collected > 50 or memory_mb > 500:
                print(f"üßπ [{viewer_type}] Frame {frame_count}: {collected} objetos removidos | RAM: {memory_mb:.1f} MB")

        except Exception as e:
            # Fallback silencioso se psutil n√£o dispon√≠vel
            try:
                import gc
                collected = gc.collect()
                if collected > 0:
                    print(f"üßπ [{viewer_type}] Limpeza: {collected} objetos removidos")
            except:
                pass

    def create_interface(self):
        """Criar interface com abas"""
        # Frame principal
        main_frame = tk.Frame(self.main_window, bg='#1a1a1a')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)

        # T√≠tulo
        title_label = tk.Label(main_frame,
                             text="üé£ Ultimate Fishing Bot v3.0",
                             font=('Arial', 18, 'bold'),
                             fg='#00aaff',
                             bg='#1a1a1a')
        title_label.pack(pady=15)

        # Criar Notebook para abas com cores melhoradas e contraste adequado
        style = ttk.Style()
        style.configure('TNotebook', background='#2d2d2d')
        style.configure('TNotebook.Tab',
                       background='#404040',
                       foreground='#e0e0e0',  # Texto claro para fundo escuro padr√£o
                       padding=[12, 8],
                       font=('Arial', 9, 'bold'))
        style.map('TNotebook.Tab',
                 background=[('selected', '#0078d4'), ('active', '#555555')],
                 foreground=[('selected', '#000000'), ('active', '#ffffff')])  # Texto preto quando selecionado (fundo azul claro)

        # Configurar outros estilos para melhor legibilidade
        style.configure('TFrame', background='#2d2d2d')
        style.configure('TLabel', background='#2d2d2d', foreground='#ffffff', font=('Arial', 9))
        style.configure('TButton', font=('Arial', 9, 'bold'))
        style.configure('TEntry', font=('Arial', 9))
        style.configure('TCheckbutton', background='#2d2d2d', foreground='#ffffff', font=('Arial', 9))
        style.configure('TScale', background='#2d2d2d')

        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill='both', expand=True, pady=10)

        # Aba 1: Controle e Status
        self.create_control_tab()

        # Aba 2: Configura√ß√µes Gerais
        self.create_config_tab()

        # Aba 3: Sistema de Alimenta√ß√£o
        self.create_feeding_tab()

        # Aba 4: Confian√ßa por Classe
        self.create_confidence_tab()

        # Aba 5: Visualizador YOLO
        # REMOVIDO: YOLO Viewer (sistema convertido para template matching)

        # Aba 6: Visualizador CATCH (Template Matching)
        self.create_catch_viewer_tab()

        # Aba 7: Sistema Anti-Detec√ß√£o
        self.create_anti_detection_tab()

        # Aba 8: Sistema Multilingual
        self.create_language_tab()

        # üîÑ Carregar todas as configura√ß√µes salvas na UI
        print("üîÑ Carregando configura√ß√µes salvas...")
        self.load_all_configs()

    def create_control_tab(self):
        """Criar aba de controle e status"""
        control_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(control_frame, text='üéÆ Controle')

        # Status do Bot
        status_frame = tk.LabelFrame(control_frame, text="ü§ñ Status do Bot",
                                   fg='white', bg='#1a1a1a',
                                   font=('Arial', 12, 'bold'))
        status_frame.pack(fill='x', pady=10, padx=10)

        self.status_label = tk.Label(status_frame, text="‚ö´ Parado",
                                   font=('Arial', 14, 'bold'),
                                   fg='red', bg='#1a1a1a')
        self.status_label.pack(pady=10)

        # Estat√≠sticas
        stats_frame = tk.LabelFrame(control_frame, text="üìä Estat√≠sticas",
                                  fg='white', bg='#1a1a1a',
                                  font=('Arial', 12, 'bold'))
        stats_frame.pack(fill='x', pady=10, padx=10)

        self.stats_label = tk.Label(stats_frame,
                                  text="Ciclos: 0 | Peixes: 0 | Uptime: 0s",
                                  font=('Arial', 12),
                                  fg='white', bg='#1a1a1a')
        self.stats_label.pack(pady=10)

        # Bot√µes de Controle
        button_frame = tk.Frame(control_frame, bg='#1a1a1a')
        button_frame.pack(pady=30)

        self.start_button = tk.Button(button_frame, text="üöÄ Iniciar", command=self.start_bot,
                                     bg='#28a745', fg='white', font=('Arial', 12, 'bold'),
                                     padx=20, pady=8)
        self.start_button.pack(side='left', padx=10)

        self.pause_button = tk.Button(button_frame, text="‚è∏Ô∏è Pausar", command=self.pause_bot,
                                     bg='#ffc107', fg='black', font=('Arial', 12, 'bold'),
                                     padx=20, pady=8)
        self.pause_button.pack(side='left', padx=10)

        self.stop_button = tk.Button(button_frame, text="üõë Parar", command=self.stop_bot,
                                    bg='#dc3545', fg='white', font=('Arial', 12, 'bold'),
                                    padx=20, pady=8)
        self.stop_button.pack(side='left', padx=10)

        # REMOVIDO: Sistema YOLO Visual duplicado (j√° existe em outra aba)
        # Inicializar vari√°veis necess√°rias para compatibilidade
        self.yolo_window_active = False
        self.yolo_window = None
        self.yolo_toggle_btn = None  # Mantido como None
        self.yolo_status_label = tk.Label(control_frame, text="", bg='#1a1a1a')  # Label vazio oculto

        # Sistema de Limpeza Autom√°tica
        auto_frame = tk.LabelFrame(control_frame, text="üîÑ Limpeza Autom√°tica",
                                 fg='white', bg='#1a1a1a',
                                 font=('Arial', 12, 'bold'))
        auto_frame.pack(fill='x', pady=10, padx=10)

        # Configura√ß√£o a cada X pescas
        fish_frame = tk.Frame(auto_frame, bg='#1a1a1a')
        fish_frame.pack(fill='x', padx=10, pady=5)

        tk.Label(fish_frame, text="üêü Limpar invent√°rio a cada:",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).pack(side='left')

        self.auto_clean_interval_var = tk.StringVar(value="10")
        # Adicionar trace para salvar automaticamente quando alterado
        self.auto_clean_interval_var.trace('w', self.on_auto_clean_interval_changed)
        tk.Entry(fish_frame, textvariable=self.auto_clean_interval_var, width=5).pack(side='left', padx=5)

        tk.Label(fish_frame, text="pescas",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).pack(side='left')

        # Toggle para ativa√ß√£o
        self.auto_clean_enabled_var = tk.BooleanVar(value=True)
        # Adicionar trace para salvar automaticamente quando alterado
        self.auto_clean_enabled_var.trace('w', self.on_auto_clean_enabled_changed)
        tk.Checkbutton(auto_frame, text="‚úÖ Ativar limpeza autom√°tica",
                      variable=self.auto_clean_enabled_var,
                      bg='#1a1a1a', fg='white', font=('Arial', 10),
                      selectcolor='#333333').pack(padx=10, pady=5)

        # Status da limpeza
        self.auto_clean_status_label = tk.Label(auto_frame,
                                              text="üìä Pr√≥xima limpeza em: 10 pescas",
                                              font=('Arial', 10),
                                              fg='#28a745', bg='#1a1a1a')
        self.auto_clean_status_label.pack(pady=5)

        # Bot√£o para salvar configura√ß√µes de limpeza autom√°tica
        tk.Button(auto_frame, text="üíæ Salvar Configura√ß√µes de Limpeza",
                 command=self.save_auto_clean_config,
                 bg='#28a745', fg='white', font=('Arial', 9, 'bold'),
                 padx=15, pady=5).pack(pady=10)

    def create_config_tab(self):
        """Criar aba de configura√ß√µes gerais"""
        config_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(config_frame, text='‚öôÔ∏è Configura√ß√µes')

        # Frame scroll√°vel para configura√ß√µes
        canvas = tk.Canvas(config_frame, bg='#1a1a1a', highlightthickness=0)
        scrollbar = tk.Scrollbar(config_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#1a1a1a')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y", pady=10)

        # Grid para as configura√ß√µes
        config_grid = tk.Frame(scrollable_frame, bg='#1a1a1a')
        config_grid.pack(fill='x', padx=10, pady=10)

        # Timeout do Ciclo
        tk.Label(config_grid, text="Timeout do Ciclo (s):",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=0, column=0, sticky='w', pady=5)
        self.cycle_timeout_var = tk.StringVar(value=str(self.bot.config.get('cycle_timeout', 60)))
        tk.Entry(config_grid, textvariable=self.cycle_timeout_var, width=10).grid(row=0, column=1, padx=10, pady=5)

        # Lado do Ba√∫
        tk.Label(config_grid, text="Lado do Ba√∫:",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=0, column=2, sticky='w', pady=5, padx=(20,0))
        self.chest_side_var = tk.StringVar(value=self.bot.config.get('chest_side', 'left'))
        chest_combo = tk.OptionMenu(config_grid, self.chest_side_var, "left", "right")
        chest_combo.configure(bg='#333333', fg='white', width=8)
        chest_combo.grid(row=0, column=3, padx=10, pady=5)

        # Tipo de Macro
        tk.Label(config_grid, text="Tipo Macro:",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=0, column=4, sticky='w', pady=5, padx=(20,0))
        self.macro_type_var = tk.StringVar(value=self.bot.config.get('macro_type', 'padrao'))
        macro_combo = tk.OptionMenu(config_grid, self.macro_type_var, "padrao", "personalizado")
        macro_combo.configure(bg='#333333', fg='white', width=12)
        macro_combo.grid(row=0, column=5, padx=10, pady=5)

        # REMOVIDO: Intervalo de Armazenamento de Peixes (duplicata do controle de limpeza autom√°tica)

        # Auto Reload
        self.auto_reload_var = tk.BooleanVar(value=self.bot.config.get('auto_reload', True))
        tk.Checkbutton(config_grid, text="Auto Reload", variable=self.auto_reload_var,
                      fg='white', bg='#1a1a1a', selectcolor='#333333',
                      font=('Arial', 10)).grid(row=1, column=0, sticky='w', pady=5)

        # Limite de Troca de Par
        tk.Label(config_grid, text="Limite Troca Par:",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=1, column=2, sticky='w', pady=5, padx=(20,0))
        self.pair_switch_var = tk.StringVar(value=str(self.bot.config.get('pair_switch_limit', 20)))
        tk.Entry(config_grid, textvariable=self.pair_switch_var, width=10).grid(row=1, column=3, padx=10, pady=5)

        # Dist√¢ncia do Ba√∫
        tk.Label(config_grid, text="Dist√¢ncia Ba√∫ (px):",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=2, column=0, sticky='w', pady=5)
        self.chest_distance_var = tk.StringVar(value=str(self.bot.config.get('chest_distance', 300)))
        tk.Entry(config_grid, textvariable=self.chest_distance_var, width=10).grid(row=2, column=1, padx=10, pady=5)

        # Cliques por Segundo (para puxar peixe)
        tk.Label(config_grid, text="Cliques/Segundo:",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=2, column=2, sticky='w', pady=5, padx=(20,0))
        self.clicks_per_second_var = tk.StringVar(value=str(self.bot.config.get('clicks_per_second', 12)))
        clicks_entry = tk.Entry(config_grid, textvariable=self.clicks_per_second_var, width=8)
        clicks_entry.grid(row=2, column=3, padx=10, pady=5)
        
        # Label informativo
        tk.Label(config_grid, text="(8-20 recomendado)",
                fg='#888888', bg='#1a1a1a', font=('Arial', 8)).grid(row=2, column=4, sticky='w', pady=5)

        # ‚è±Ô∏è NOVA OP√á√ÉO: Threshold de Timeout para Manuten√ß√£o
        tk.Label(config_grid, text="‚è±Ô∏è Timeouts p/ Manuten√ß√£o:",
                fg='white', bg='#1a1a1a', font=('Arial', 10)).grid(row=2, column=5, sticky='w', pady=5, padx=(20,0))
        self.timeout_threshold_var = tk.StringVar(value=str(self.bot.rod_system.get('timeout_threshold', 2)))
        timeout_entry = tk.Entry(config_grid, textvariable=self.timeout_threshold_var, width=8)
        timeout_entry.grid(row=2, column=6, padx=10, pady=5)
        
        # Label explicativo para timeout
        tk.Label(config_grid, text="(2+ timeouts = manuten√ß√£o)",
                fg='#888888', bg='#1a1a1a', font=('Arial', 8)).grid(row=3, column=5, columnspan=2, sticky='w', pady=2)

        # ‚ö° NOVA OP√á√ÉO: Manejo de Varas Quebradas
        tk.Label(config_grid, text="üîß Varas Quebradas:",
                fg='white', bg='#1a1a1a', font=('Arial', 10, 'bold')).grid(row=4, column=0, sticky='w', pady=(15,5))
        
        self.broken_rod_action_var = tk.StringVar(value=self.bot.config.get('broken_rod_action', 'discard'))
        
        # Radio buttons para escolher a√ß√£o
        tk.Radiobutton(config_grid, text="üóëÔ∏è Descartar", 
                      variable=self.broken_rod_action_var, value='discard',
                      fg='white', bg='#1a1a1a', selectcolor='#333333',
                      font=('Arial', 9)).grid(row=4, column=1, columnspan=2, sticky='w', pady=2)
        
        tk.Radiobutton(config_grid, text="üì¶ Guardar no ba√∫", 
                      variable=self.broken_rod_action_var, value='save',
                      fg='white', bg='#1a1a1a', selectcolor='#333333',
                      font=('Arial', 9)).grid(row=5, column=1, columnspan=2, sticky='w', pady=2)
        
        # Label explicativo
        tk.Label(config_grid, text="Descartar = remove para lixo | Guardar = clique direito no ba√∫",
                fg='#888888', bg='#1a1a1a', font=('Arial', 8)).grid(row=5, column=3, columnspan=2, sticky='w', pady=2)

        # Bot√£o Salvar Configura√ß√µes
        tk.Button(scrollable_frame, text="üíæ Salvar Configura√ß√µes", command=self.save_config,
                 bg='#17a2b8', fg='white', font=('Arial', 12, 'bold'),
                 padx=20, pady=10).pack(pady=20)

    def create_feeding_tab(self):
        """Criar aba de sistema de alimenta√ß√£o"""
        feeding_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(feeding_frame, text='üçñ Alimenta√ß√£o')

        # T√≠tulo da aba
        title_label = tk.Label(feeding_frame,
                              text="üçñ Sistema de Alimenta√ß√£o Inteligente",
                              font=('Arial', 14, 'bold'),
                              fg='#ff6b35', bg='#1a1a1a')
        title_label.pack(pady=15)

        # Frame principal com scroll
        canvas = tk.Canvas(feeding_frame, bg='#1a1a1a')
        scrollbar = ttk.Scrollbar(feeding_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#1a1a1a')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True, padx=10)
        scrollbar.pack(side="right", fill="y", pady=10)

        # üçñ NOVO: Configura√ß√£o de modo de alimenta√ß√£o
        mode_frame = tk.LabelFrame(scrollable_frame, text="‚öôÔ∏è Modo de Alimenta√ß√£o",
                                  bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        mode_frame.pack(fill='x', padx=10, pady=10)

        # Vari√°vel para modo de alimenta√ß√£o - PADR√ÉO: detec√ß√£o autom√°tica
        self.feeding_mode = tk.StringVar(value=self.bot.alimentacao.get('feeding_mode', 'detecao_auto'))

        # Radio buttons para escolher modo
        tk.Radiobutton(mode_frame,
                      text="üéØ Slots Fixos (Coordenadas [1306,858] e [1403,877])",
                      variable=self.feeding_mode, value='slots_fixos',
                      bg='#2a2a2a', fg='white', selectcolor='#404040',
                      font=('Arial', 9), command=self.update_feeding_mode).pack(anchor='w', padx=10, pady=5)

        tk.Radiobutton(mode_frame,
                      text="üîç Detec√ß√£o Autom√°tica (Busca fil√© frito na tela)",
                      variable=self.feeding_mode, value='detecao_auto',
                      bg='#2a2a2a', fg='white', selectcolor='#404040',
                      font=('Arial', 9), command=self.update_feeding_mode).pack(anchor='w', padx=10, pady=5)

        # Descri√ß√£o do modo selecionado
        self.mode_description = tk.Label(mode_frame,
                                        text=self.get_feeding_mode_description(),
                                        bg='#2a2a2a', fg='#cccccc', font=('Arial', 8),
                                        wraplength=400, justify='left')
        self.mode_description.pack(padx=10, pady=(5, 10))

        # Status atual
        status_frame = tk.LabelFrame(scrollable_frame, text="üìä Status Atual",
                                    bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        status_frame.pack(fill='x', padx=10, pady=5)

        self.feeding_status_label = tk.Label(status_frame,
                                           text="Carregando status...",
                                           bg='#2a2a2a', fg='#00ff88',
                                           font=('Consolas', 9))
        self.feeding_status_label.pack(pady=10)

        # Configura√ß√µes de Triggers
        triggers_frame = tk.LabelFrame(scrollable_frame, text="‚è∞ Triggers de Alimenta√ß√£o",
                                     bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        triggers_frame.pack(fill='x', padx=10, pady=5)

        # üîò SELETOR DE MODO (EXCLUSIVO)
        mode_frame = tk.Frame(triggers_frame, bg='#2a2a2a')
        mode_frame.pack(fill='x', padx=10, pady=10)

        tk.Label(mode_frame, text="üìå Modo de Trigger:", bg='#2a2a2a', fg='white',
                font=('Arial', 9, 'bold')).pack(side='left')

        # Vari√°vel para modo (s√≥ um pode estar ativo)
        current_mode = self.bot.alimentacao.get('trigger_mode', 'catches')  # Padr√£o: pescas
        self.trigger_mode_var = tk.StringVar(value=current_mode)

        # Radio buttons para escolha exclusiva
        tk.Radiobutton(mode_frame, text="üé£ Por Pescas", variable=self.trigger_mode_var,
                      value='catches', bg='#2a2a2a', fg='white', selectcolor='#333333',
                      font=('Arial', 8)).pack(side='left', padx=10)
        tk.Radiobutton(mode_frame, text="‚è∞ Por Tempo", variable=self.trigger_mode_var,
                      value='time', bg='#2a2a2a', fg='white', selectcolor='#333333',
                      font=('Arial', 8)).pack(side='left', padx=10)

        # Trigger por tempo
        time_frame = tk.Frame(triggers_frame, bg='#2a2a2a')
        time_frame.pack(fill='x', padx=10, pady=5)

        tk.Label(time_frame, text="‚è∞ A cada X minutos:", bg='#2a2a2a', fg='white').pack(side='left')
        self.trigger_minutes_var = tk.StringVar(value=str(self.bot.alimentacao['trigger_minutes']))
        tk.Entry(time_frame, textvariable=self.trigger_minutes_var, width=10).pack(side='right')

        # Trigger por pescas
        catches_frame = tk.Frame(triggers_frame, bg='#2a2a2a')
        catches_frame.pack(fill='x', padx=10, pady=5)

        tk.Label(catches_frame, text="üé£ A cada X pescas:", bg='#2a2a2a', fg='white').pack(side='left')
        self.trigger_catches_var = tk.StringVar(value=str(self.bot.alimentacao['trigger_catches']))
        tk.Entry(catches_frame, textvariable=self.trigger_catches_var, width=10).pack(side='right')

        # Configura√ß√µes por sess√£o
        session_frame = tk.LabelFrame(scrollable_frame, text="üçΩÔ∏è Configura√ß√µes por Sess√£o",
                                    bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        session_frame.pack(fill='x', padx=10, pady=5)

        feeds_frame = tk.Frame(session_frame, bg='#2a2a2a')
        feeds_frame.pack(fill='x', padx=10, pady=5)

        tk.Label(feeds_frame, text="üçñ Quantas vezes comer:", bg='#2a2a2a', fg='white').pack(side='left')
        self.feeds_per_session_var = tk.StringVar(value=str(self.bot.alimentacao['feeds_per_session']))
        tk.Entry(feeds_frame, textvariable=self.feeds_per_session_var, width=10).pack(side='right')

        # Posi√ß√µes dos slots
        positions_frame = tk.LabelFrame(scrollable_frame, text="üìç Posi√ß√µes dos Slots",
                                      bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        positions_frame.pack(fill='x', padx=10, pady=5)

        # Slot 1
        slot1_frame = tk.Frame(positions_frame, bg='#2a2a2a')
        slot1_frame.pack(fill='x', padx=10, pady=2)
        tk.Label(slot1_frame, text="üçñ Slot 1 (X,Y):", bg='#2a2a2a', fg='white').pack(side='left')
        self.slot1_x_var = tk.StringVar(value=str(self.bot.alimentacao['slot_positions'][1][0]))
        self.slot1_y_var = tk.StringVar(value=str(self.bot.alimentacao['slot_positions'][1][1]))
        tk.Entry(slot1_frame, textvariable=self.slot1_x_var, width=8).pack(side='right', padx=2)
        tk.Entry(slot1_frame, textvariable=self.slot1_y_var, width=8).pack(side='right', padx=2)

        # Slot 2
        slot2_frame = tk.Frame(positions_frame, bg='#2a2a2a')
        slot2_frame.pack(fill='x', padx=10, pady=2)
        tk.Label(slot2_frame, text="üçñ Slot 2 (X,Y):", bg='#2a2a2a', fg='white').pack(side='left')
        self.slot2_x_var = tk.StringVar(value=str(self.bot.alimentacao['slot_positions'][2][0]))
        self.slot2_y_var = tk.StringVar(value=str(self.bot.alimentacao['slot_positions'][2][1]))
        tk.Entry(slot2_frame, textvariable=self.slot2_x_var, width=8).pack(side='right', padx=2)
        tk.Entry(slot2_frame, textvariable=self.slot2_y_var, width=8).pack(side='right', padx=2)

        # Posi√ß√£o para comer
        eat_frame = tk.Frame(positions_frame, bg='#2a2a2a')
        eat_frame.pack(fill='x', padx=10, pady=2)
        tk.Label(eat_frame, text="üçΩÔ∏è Comer (X,Y):", bg='#2a2a2a', fg='white').pack(side='left')
        self.eat_x_var = tk.StringVar(value=str(self.bot.alimentacao['eat_position'][0]))
        self.eat_y_var = tk.StringVar(value=str(self.bot.alimentacao['eat_position'][1]))
        tk.Entry(eat_frame, textvariable=self.eat_x_var, width=8).pack(side='right', padx=2)
        tk.Entry(eat_frame, textvariable=self.eat_y_var, width=8).pack(side='right', padx=2)

        # Bot√µes de controle
        controls_frame = tk.Frame(scrollable_frame, bg='#1a1a1a')
        controls_frame.pack(fill='x', padx=10, pady=10)

        tk.Button(controls_frame, text="üíæ Salvar Configura√ß√µes",
                 command=self.save_feeding_config,
                 bg='#28a745', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=5)

        tk.Button(controls_frame, text="üçñ Testar Alimenta√ß√£o",
                 command=self.test_feeding,
                 bg='#ff6b35', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=5)


        tk.Button(controls_frame, text="üîÑ Resetar Contadores",
                 command=self.reset_feeding_counters,
                 bg='#dc3545', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=5)

    def save_feeding_config_to_file(self):
        """Salvar configura√ß√µes de alimenta√ß√£o no config.json"""
        try:
            # Atualizar configura√ß√£o do bot com dados da UI
            self.bot.config['feeding']['feeding_mode'] = self.feeding_mode.get()

            # Salvar no arquivo
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(self.bot.config, f, indent=2, ensure_ascii=False)

            print("üíæ Configura√ß√µes de alimenta√ß√£o salvas no config.json")

        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes: {e}")

    def save_feeding_config(self):
        """Salvar configura√ß√µes de alimenta√ß√£o"""
        try:
            # Atualizar configura√ß√µes do bot
            self.bot.alimentacao['trigger_mode'] = self.trigger_mode_var.get()  # üîò MODO EXCLUSIVO
            self.bot.alimentacao['trigger_minutes'] = int(self.trigger_minutes_var.get())
            self.bot.alimentacao['trigger_catches'] = int(self.trigger_catches_var.get())
            self.bot.alimentacao['feeds_per_session'] = int(self.feeds_per_session_var.get())

            self.bot.alimentacao['slot_positions'][1] = [int(self.slot1_x_var.get()), int(self.slot1_y_var.get())]
            self.bot.alimentacao['slot_positions'][2] = [int(self.slot2_x_var.get()), int(self.slot2_y_var.get())]
            self.bot.alimentacao['eat_position'] = [int(self.eat_x_var.get()), int(self.eat_y_var.get())]

            # Salvar no config.json
            if hasattr(self.bot, 'config'):
                self.bot.config['feeding'] = {
                    'enabled': True,
                    'trigger_mode': self.bot.alimentacao['trigger_mode'],  # üîò MODO EXCLUSIVO
                    'slot1_position': self.bot.alimentacao['slot_positions'][1],
                    'slot2_position': self.bot.alimentacao['slot_positions'][2],
                    'eat_position': self.bot.alimentacao['eat_position'],
                    'feeds_per_session': self.bot.alimentacao['feeds_per_session'],
                    'max_uses_per_slot': self.bot.alimentacao['max_uses_per_slot'],
                    'trigger_minutes': self.bot.alimentacao['trigger_minutes'],
                    'trigger_catches': self.bot.alimentacao['trigger_catches']
                }
                # Salvar diretamente no arquivo config.json
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.bot.config, f, indent=2, ensure_ascii=False)

            messagebox.showinfo("‚úÖ Sucesso", "Configura√ß√µes de alimenta√ß√£o salvas!")

        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Erro ao salvar: {e}")

    def toggle_yolo_window(self):
        """Ativar/Desativar janela YOLO visual"""
        # Fun√ß√£o mantida para compatibilidade mas n√£o faz nada
        # YOLO visual foi movido para outra aba
        print("‚ö†Ô∏è YOLO Visual foi movido para outra aba da interface")
        return

    def is_cursor_visible(self):
        """Detectar se o cursor est√° vis√≠vel (modo normal) ou invis√≠vel (modo FPS)"""
        try:
            import ctypes
            # GetCursorInfo para verificar se cursor est√° vis√≠vel
            class CURSORINFO(ctypes.Structure):
                _fields_ = [("cbSize", ctypes.c_uint32),
                           ("flags", ctypes.c_uint32),
                           ("hCursor", ctypes.c_void_p),
                           ("ptScreenPos", ctypes.c_long * 2)]

            cursor_info = CURSORINFO()
            cursor_info.cbSize = ctypes.sizeof(CURSORINFO)

            if ctypes.windll.user32.GetCursorInfo(ctypes.byref(cursor_info)):
                # Flag 0x00000001 = CURSOR_SHOWING
                return bool(cursor_info.flags & 0x00000001)
            return True  # Fallback - assumir vis√≠vel
        except:
            return True  # Fallback - assumir vis√≠vel

    def optimized_click(self, x, y, button='left', double_click=False):
        """Sistema de clique otimizado que detecta modo FPS automaticamente"""
        try:
            cursor_visible = self.is_cursor_visible()

            if cursor_visible:
                # Modo normal - usar pyautogui
                print(f"üñ±Ô∏è Clique normal em ({x}, {y}) - Cursor vis√≠vel")
                if double_click:
                    focus_game_window()  # Garantir foco
                    pyautogui.doubleClick(x, y, button=button)
                else:
                    focus_game_window()  # Garantir foco
                    pyautogui.click(x, y, button=button)
            else:
                # Modo FPS - usar SendInput direto
                print(f"üéØ Clique FPS em ({x}, {y}) - Cursor invis√≠vel")
                self.fps_click(x, y, button, double_click)

            return True
        except Exception as e:
            print(f"‚ùå Erro no clique otimizado: {e}")
            # Fallback para pyautogui
            try:
                if double_click:
                    focus_game_window()  # Garantir foco
                    pyautogui.doubleClick(x, y, button=button)
                else:
                    focus_game_window()  # Garantir foco
                    pyautogui.click(x, y, button=button)
                return True
            except:
                return False

    def fps_click(self, x, y, button='left', double_click=False):
        """Clique espec√≠fico para modo FPS usando SendInput"""
        import ctypes
        from ctypes import wintypes

        try:
            # Mover mouse para posi√ß√£o
            ctypes.windll.user32.SetCursorPos(x, y)
            time.sleep(0.05)

            # Estruturas SendInput para mouse
            class MOUSEINPUT(ctypes.Structure):
                _fields_ = [("dx", wintypes.LONG),
                           ("dy", wintypes.LONG),
                           ("mouseData", wintypes.DWORD),
                           ("dwFlags", wintypes.DWORD),
                           ("time", wintypes.DWORD),
                           ("dwExtraInfo", ctypes.POINTER(ctypes.c_ulong))]

            class INPUT(ctypes.Structure):
                class _INPUT(ctypes.Union):
                    _fields_ = [("mi", MOUSEINPUT)]
                _fields_ = [("type", wintypes.DWORD), ("_input", _INPUT)]

            # Constantes
            INPUT_MOUSE = 0
            MOUSEEVENTF_LEFTDOWN = 0x0002
            MOUSEEVENTF_LEFTUP = 0x0004
            MOUSEEVENTF_RIGHTDOWN = 0x0008
            MOUSEEVENTF_RIGHTUP = 0x0010

            # Definir flags baseado no bot√£o
            if button == 'left':
                down_flag = MOUSEEVENTF_LEFTDOWN
                up_flag = MOUSEEVENTF_LEFTUP
            else:  # right
                down_flag = MOUSEEVENTF_RIGHTDOWN
                up_flag = MOUSEEVENTF_RIGHTUP

            # Criar inputs para down e up
            inputs = []

            # Mouse down
            input_down = INPUT()
            input_down.type = INPUT_MOUSE
            input_down._input.mi.dwFlags = down_flag
            input_down._input.mi.time = 0
            input_down._input.mi.dwExtraInfo = None
            inputs.append(input_down)

            # Mouse up
            input_up = INPUT()
            input_up.type = INPUT_MOUSE
            input_up._input.mi.dwFlags = up_flag
            input_up._input.mi.time = 0
            input_up._input.mi.dwExtraInfo = None
            inputs.append(input_up)

            # Duplicar para double click
            if double_click:
                inputs.extend([input_down, input_up])

            # Enviar inputs
            for input_item in inputs:
                ctypes.windll.user32.SendInput(1, ctypes.byref(input_item), ctypes.sizeof(input_item))
                time.sleep(0.05)

            print(f"‚úÖ Clique FPS executado com sucesso")
            return True

        except Exception as e:
            print(f"‚ùå Erro no clique FPS: {e}")
            return False

    def start_yolo_window(self):
        """Iniciar janela YOLO em tempo real - VERS√ÉO SIMPLIFICADA"""
        try:
            self.yolo_window_active = True
            # Verificar se bot√£o existe antes de configurar
            if self.yolo_toggle_btn:
                self.yolo_toggle_btn.config(text="üëÅÔ∏è Desativar YOLO", bg='#dc3545')

            # Criar janela YOLO
            self.yolo_window = tk.Toplevel(self.main_window)
            self.yolo_window.title("üëÅÔ∏è YOLO - Detec√ß√µes em Tempo Real")
            self.yolo_window.geometry("900x700")
            self.yolo_window.configure(bg='#1a1a1a')

            # Frame para a imagem (Canvas para melhor controle)
            self.yolo_canvas = tk.Canvas(self.yolo_window,
                                       bg='#333333',
                                       width=800, height=600)
            self.yolo_canvas.pack(padx=10, pady=10)

            # Frame para informa√ß√µes
            info_frame = tk.Frame(self.yolo_window, bg='#1a1a1a')
            info_frame.pack(fill='x', padx=10, pady=5)

            self.yolo_info_label = tk.Label(info_frame,
                                          text="üîÑ Iniciando captura de tela...",
                                          fg='white', bg='#1a1a1a',
                                          font=('Consolas', 10))
            self.yolo_info_label.pack()

            # Callback para fechar janela
            self.yolo_window.protocol("WM_DELETE_WINDOW", self.stop_yolo_window)

            # Iniciar thread de atualiza√ß√£o SIMPLIFICADA
            self.yolo_thread_running = True
            threading.Thread(target=self.simple_yolo_update, daemon=True).start()

            safe_print("[YOLO] Janela YOLO ativada!")

        except Exception as e:
            print(f"‚ùå Erro ao iniciar janela YOLO: {e}")
            messagebox.showerror("Erro", f"Erro ao iniciar YOLO visual: {e}")

    def stop_yolo_window(self):
        """Parar janela YOLO"""
        self.yolo_window_active = False
        self.yolo_thread_running = False

        # Verificar se bot√£o existe antes de configurar
        if self.yolo_toggle_btn:
            self.yolo_toggle_btn.config(text="üëÅÔ∏è Ativar YOLO Visual", bg='#17a2b8')

        if self.yolo_window:
            self.yolo_window.destroy()
            self.yolo_window = None

        safe_print("[YOLO] Janela YOLO desativada!")

    def update_yolo_window(self):
        """Thread para atualizar janela YOLO em tempo real"""
        import cv2
        import numpy as np
        from PIL import Image, ImageTk

        while self.yolo_thread_running and self.yolo_window_active:
            try:
                start_time = time.time()  # Para controle de FPS

                if not self.bot.yolo_model or not self.bot.sct:
                    print("‚ö†Ô∏è YOLO model ou MSS n√£o dispon√≠vel")
                    time.sleep(1)
                    continue

                # Capturar tela completa
                safe_print("Capturando tela...")
                monitor = {"top": 0, "left": 0, "width": 1920, "height": 1080}
                screenshot = self.bot.sct.grab(monitor)
                frame = np.array(screenshot)

                # Debug: verificar se frame foi capturado
                safe_print(f"Frame capturado: {frame.shape}")

                # Converter cores corretamente
                if frame.shape[2] == 4:  # BGRA
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2RGB)
                else:  # BGR
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                # Redimensionar para a janela
                height, width = frame.shape[:2]
                new_width = 780
                new_height = int(height * (new_width / width))

                safe_print(f"[RESIZE] Redimensionando: {width}x{height} -> {new_width}x{new_height}")
                frame_resized = cv2.resize(frame, (new_width, new_height))

                # Detectar objetos com YOLO
                safe_print("[YOLO] Executando detec√ß√£o...")
                results = self.bot.yolo_model(frame, verbose=False)
                detections = []

                # Cores por classe conforme seu exemplo
                class_colors = {
                    'peixe capturado': (0, 255, 0),      # Verde
                    'vara': (255, 165, 0),               # Laranja
                    'vara com isca': (0, 255, 255),     # Ciano
                    'anchova': (255, 192, 203),          # Rosa
                    'salmao': (255, 20, 147),            # Rosa escuro
                    'sardinha': (135, 206, 235),         # Azul claro
                    'truta': (255, 215, 0),              # Dourado
                    'tubarao': (255, 0, 0),              # Vermelho
                    'carne de urso': (139, 69, 19),      # Marrom
                    'carne de lobo': (160, 82, 45),      # Marrom escuro
                    'gordura': (255, 215, 0),            # Dourado (isca)
                    'inventario aberto': (255, 255, 0),  # Amarelo
                    'barril aberto': (255, 140, 0),      # Laranja escuro
                    'scrap': (192, 192, 192),            # Prata
                    'default': (255, 255, 255)           # Branco
                }

                safe_print(f"[YOLO] Results: {len(results) if results else 0}")

                if results and len(results) > 0:
                    result = results[0]
                    if hasattr(result, 'boxes') and result.boxes is not None:
                        boxes = result.boxes.xyxy.cpu().numpy()
                        confidences = result.boxes.conf.cpu().numpy()
                        classes = result.boxes.cls.cpu().numpy()

                        safe_print(f"[YOLO] Boxes encontradas: {len(boxes)}")

                        for i, (box, conf, cls) in enumerate(zip(boxes, confidences, classes)):
                            if conf >= 0.1:  # Threshold baixo para debug
                                class_name = self.bot.yolo_model.names[int(cls)]
                                detections.append({
                                    'box': box,
                                    'confidence': conf,
                                    'class': class_name
                                })

                                # Coordenadas originais
                                x1, y1, x2, y2 = box.astype(int)
                                # Ajustar para imagem redimensionada
                                x1_res = int(x1 * (new_width / width))
                                y1_res = int(y1 * (new_height / height))
                                x2_res = int(x2 * (new_width / width))
                                y2_res = int(y2 * (new_height / height))

                                # Cor baseada na classe
                                color = class_colors.get(class_name, class_colors['default'])

                                # Desenhar bounding box
                                cv2.rectangle(frame_resized, (x1_res, y1_res), (x2_res, y2_res), color, 2)

                                # Label com classe e confian√ßa
                                label = f"{class_name} {conf:.2f}"
                                cv2.putText(frame_resized, label, (x1_res, y1_res - 5),
                                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)

                                safe_print(f"[BBOX] {class_name} em ({x1_res},{y1_res})-({x2_res},{y2_res}) conf={conf:.2f}")

                safe_print(f"[YOLO] Total de detec√ß√µes: {len(detections)}")

                # Converter para PIL e depois para tkinter
                try:
                    safe_print("[PIL] Convertendo para PIL...")
                    image_pil = Image.fromarray(frame_resized)

                    safe_print("[TK] Convertendo para tkinter...")
                    image_tk = ImageTk.PhotoImage(image_pil)

                    # Atualizar interface (thread-safe)
                    if self.yolo_window and self.yolo_window_active:
                        safe_print("[UPDATE] Atualizando interface...")
                        self.yolo_window.after(0, lambda img=image_tk, dets=detections: self.update_yolo_display(img, dets))

                except Exception as convert_error:
                    print(f"‚ùå Erro na convers√£o de imagem: {convert_error}")

                # Controle de FPS conforme seu exemplo
                target_frame_time = 1.0 / 15.0  # 15 FPS m√°ximo
                frame_time = time.time() - start_time
                if frame_time < target_frame_time:
                    time.sleep(target_frame_time - frame_time)

            except Exception as e:
                print(f"‚ö†Ô∏è Erro na thread YOLO: {e}")
                time.sleep(1)

    def update_yolo_display(self, image_tk, detections):
        """Atualizar display YOLO (thread-safe)"""
        try:
            safe_print("[DISPLAY] Atualizando display YOLO...")

            if self.yolo_window and self.yolo_window_active:
                safe_print(f"[LABEL] Configurando imagem no label...")
                self.yolo_image_label.configure(image=image_tk)
                self.yolo_image_label.image = image_tk  # Manter refer√™ncia
                safe_print("[OK] Imagem atualizada no label")

                # Atualizar informa√ß√µes
                if detections:
                    info_text = f"[TARGET] {len(detections)} detec√ß√µes:\n"
                    for det in detections[:5]:  # Mostrar s√≥ 5 primeiras
                        info_text += f"‚Ä¢ {det['class']}: {det['confidence']:.2f}\n"
                    if len(detections) > 5:
                        info_text += f"... e mais {len(detections) - 5} detec√ß√µes"
                else:
                    info_text = "üì≠ Nenhuma detec√ß√£o"

                self.yolo_info_label.config(text=info_text)

                # Atualizar status na interface principal
                if detections:
                    last_detection = detections[0]['class']
                    status_text = f"üìä Detec√ß√µes: {len(detections)} | √öltima: {last_detection}"
                else:
                    status_text = "üìä Detec√ß√µes: 0 | √öltima: Nenhuma"

                self.yolo_status_label.config(text=status_text)

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao atualizar display YOLO: {e}")

    def simple_yolo_update(self):
        """Atualiza√ß√£o YOLO melhorada - baseada no novo1.py"""
        from PIL import Image, ImageTk, ImageDraw, ImageFont
        import numpy as np
        import mss

        safe_print("Thread YOLO melhorada iniciada!")

        # Criar inst√¢ncia MSS espec√≠fica para esta thread
        sct = mss.mss()

        # Cores para diferentes classes (como no novo1.py)
        class_colors = {
            'peixe capturado': (0, 255, 0),      # Verde
            'peixe capturado (TEMPLATE)': (0, 255, 255),  # Ciano brilhante para template
            'vara': (255, 165, 0),               # Laranja
            'vara com isca': (0, 255, 255),     # Ciano
            'anchova': (255, 192, 203),         # Rosa
            'salmao': (255, 20, 147),           # Rosa escuro
            'sardinha': (173, 216, 230),        # Azul claro
            'truta': (255, 215, 0),             # Dourado
            'tubarao': (220, 20, 60),           # Vermelho escuro
            'inventario aberto': (128, 0, 128), # Roxo
            'barril aberto': (139, 69, 19),     # Marrom
            'carne de urso': (160, 82, 45),     # Marrom claro
            'carne de lobo': (105, 105, 105),   # Cinza
            'gordura': (255, 215, 0),           # Dourado (isca)
            'default': (255, 255, 255)          # Branco
        }

        frame_count = 0
        fps_timer = time.time()
        peixe_detections_total = 0  # Contador para debugging

        while self.yolo_thread_running and self.yolo_window_active:
            try:
                frame_start = time.time()

                # STEP 1: Capturar regi√£o espec√≠fica do jogo (como no novo1.py)
                safe_print("Capturando regiao do jogo...")

                # Regi√£o de captura otimizada para Rust (ajuste conforme necess√°rio)
                game_region = {
                    "top": 0,
                    "left": 0,
                    "width": 1920,
                    "height": 1080
                }

                screenshot = sct.grab(game_region)

                # STEP 2: Converter para array numpy
                img_array = np.array(screenshot)
                safe_print(f"Array capturado: {img_array.shape}")

                # STEP 3: Converter cores (BGRA -> RGB)
                if len(img_array.shape) == 3 and img_array.shape[2] == 4:
                    img_rgb = cv2.cvtColor(img_array, cv2.COLOR_BGRA2RGB)
                else:
                    img_rgb = img_array

                # STEP 4: Executar predi√ß√µes H√çBRIDAS (Template + YOLO)
                detections = []

                # PRIORIDADE 1: TEMPLATE MATCHING para peixe capturado
                try:
                    safe_print("[TEMPLATE] Testando template matching...")
                    template_found, template_conf, template_bbox = self.bot.detect_fish_caught_template(threshold=0.5)

                    if template_found:
                        # Adicionar detec√ß√£o de template √†s detec√ß√µes
                        safe_print(f"üêü [TEMPLATE] PEIXE CAPTURADO DETECTADO! Conf: {template_conf:.3f}")

                        # Usar bbox real ou fallback
                        if template_bbox:
                            bbox = template_bbox
                        else:
                            bbox = (100, 100, 200, 150)  # Fallback se n√£o tiver posi√ß√£o

                        detections.append({
                            "class": "peixe capturado (TEMPLATE)",
                            "confidence": template_conf,
                            "bbox": bbox,
                            "method": "TEMPLATE"
                        })
                        peixe_detections_total += 1

                except Exception as template_error:
                    safe_print(f"[ERROR] Erro template matching: {template_error}")

                # PASSO 2: YOLO detection
                if self.bot.yolo_model:
                    try:
                        # Executar predi√ß√µes YOLO no frame RGB
                        safe_print("[YOLO] Executando predi√ß√µes...")
                        results = self.bot.yolo_model(img_rgb, verbose=False)

                        # Processar resultados das predi√ß√µes
                        for result in results:
                            if hasattr(result, 'boxes') and result.boxes is not None:
                                boxes = result.boxes
                                for box in boxes:
                                    conf = float(box.conf[0])
                                    cls_id = int(box.cls[0])
                                    class_name = self.bot.yolo_model.names[cls_id]

                                    # Verificar threshold individual da classe
                                    threshold = self.bot.config.get('class_confidence', {}).get(class_name, 0.5)

                                    if conf >= max(0.1, threshold):  # M√≠n 0.1 para debug
                                        x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())

                                        # Log espec√≠fico para PEIXE CAPTURADO
                                        if class_name.lower() == "peixe capturado":
                                            peixe_detections_total += 1
                                            safe_print(f"üêü [YOLO] PEIXE CAPTURADO DETECTADO! (#{peixe_detections_total})")
                                            safe_print(f"   ‚îî‚îÄ Confian√ßa: {conf:.3f} (threshold: {threshold})")
                                            safe_print(f"   ‚îî‚îÄ Posi√ß√£o: ({x1},{y1}) at√© ({x2},{y2})")
                                            safe_print(f"   ‚îî‚îÄ Tamanho: {x2-x1}x{y2-y1} pixels")
                                            if (x2-x1) < 20 or (y2-y1) < 20:
                                                safe_print(f"   ‚ö†Ô∏è ATEN√á√ÉO: Detec√ß√£o muito pequena! Pode ser falso positivo")

                                        detections.append({
                                            "class": class_name,
                                            "confidence": conf,
                                            "bbox": (x1, y1, x2, y2),
                                            "method": "YOLO"
                                        })

                        # Log resumo das detec√ß√µes
                        peixe_count = sum(1 for d in detections if "peixe capturado" in d["class"].lower())
                        template_count = sum(1 for d in detections if d.get("method") == "TEMPLATE")
                        yolo_count = sum(1 for d in detections if d.get("method") == "YOLO" and "peixe capturado" in d["class"].lower())

                        if peixe_count > 0:
                            safe_print(f"[H√çBRIDO] Total: {len(detections)} | PEIXE: {peixe_count} (Template: {template_count}, YOLO: {yolo_count})")
                        else:
                            safe_print(f"[H√çBRIDO] Total: {len(detections)} detec√ß√µes - nenhum peixe capturado")

                        # Log todas as classes detectadas para debug
                        if detections:
                            classes_found = [d["class"] for d in detections]
                            safe_print(f"[DEBUG] Classes detectadas: {classes_found}")
                    except Exception as yolo_error:
                        safe_print(f"[ERROR] Erro nas predi√ß√µes YOLO: {yolo_error}")

                # STEP 5: Desenhar detec√ß√µes na imagem (como no novo1.py)
                img_with_detections = img_rgb.copy()

                if detections:
                    for detection in detections:
                        class_name = detection['class']
                        confidence = detection['confidence']
                        x1, y1, x2, y2 = detection['bbox']

                        # Obter cor para a classe
                        color = class_colors.get(class_name, class_colors['default'])

                        # Desenhar bounding box colorido
                        cv2.rectangle(img_with_detections, (x1, y1), (x2, y2), color, 2)

                        # Adiciona label com confian√ßa conforme seu exemplo
                        label = f"{class_name} {confidence:.2f}"
                        cv2.putText(img_with_detections, label, (x1, y1-5),
                                  cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)

                # STEP 6: Redimensionar para canvas
                height, width = img_with_detections.shape[:2]
                scale = min(800/width, 600/height)
                new_width = int(width * scale)
                new_height = int(height * scale)

                img_pil = Image.fromarray(img_with_detections.astype('uint8'))
                img_resized = img_pil.resize((new_width, new_height), Image.Resampling.LANCZOS)

                # STEP 7: Adicionar informa√ß√µes de overlay (como no novo1.py)
                draw = ImageDraw.Draw(img_resized)

                # Informa√ß√µes no canto inferior esquerdo
                info_lines = [
                    f"[TARGET] Detec√ß√µes: {len(detections)}",
                    f"[RES] Resolu√ß√£o: {width}x{height}",
                    f"[CANVAS] Canvas: {new_width}x{new_height}",
                    f"[FRAME] Frame: {frame_count}"
                ]

                y_offset = new_height - (len(info_lines) * 20 + 10)  # Mover para baixo
                for line in info_lines:
                    # Fundo preto para o texto
                    text_bbox = draw.textbbox((10, y_offset), line)
                    draw.rectangle(text_bbox, fill=(0, 0, 0, 128))

                    # Texto branco
                    draw.text((10, y_offset), line, fill=(255, 255, 255))
                    y_offset += 20

                # Lista de detec√ß√µes no canto direito
                if detections:
                    x_offset = new_width - 250
                    y_offset = 10

                    draw.text((x_offset, y_offset), "üîç Detec√ß√µes:", fill=(255, 255, 0))
                    y_offset += 20

                    for i, detection in enumerate(detections[:10]):  # M√°ximo 10
                        class_name = detection['class']
                        confidence = detection['confidence']
                        text = f"‚Ä¢ {class_name}: {confidence:.2f}"

                        # Fundo preto
                        text_bbox = draw.textbbox((x_offset, y_offset), text)
                        draw.rectangle(text_bbox, fill=(0, 0, 0, 128))

                        # Texto colorido pela classe
                        color = class_colors.get(class_name, class_colors['default'])
                        draw.text((x_offset, y_offset), text, fill=color)
                        y_offset += 15

                # STEP 8: Converter para tkinter
                img_tk = ImageTk.PhotoImage(img_resized)

                # STEP 9: Calcular FPS real
                frame_count += 1
                current_time = time.time()
                if current_time - fps_timer >= 1.0:
                    fps = frame_count / (current_time - fps_timer)
                    frame_count = 0
                    fps_timer = current_time
                else:
                    fps = 0

                # STEP 10: Atualizar Canvas (thread-safe)
                if self.yolo_window and self.yolo_window_active:
                    def update_canvas():
                        try:
                            self.yolo_canvas.delete("all")
                            self.yolo_canvas.create_image(400, 300, image=img_tk, anchor='center')
                            self.yolo_canvas.image = img_tk  # Manter refer√™ncia

                            # Atualizar informa√ß√µes
                            if fps > 0:
                                fps_text = f"‚úÖ Captura: {new_width}x{new_height} | FPS: {fps:.1f} | Detec√ß√µes: {len(detections)}"
                            else:
                                fps_text = f"‚úÖ Captura: {new_width}x{new_height} | Processando... | Detec√ß√µes: {len(detections)}"

                            self.yolo_info_label.config(text=fps_text)

                        except Exception as canvas_error:
                            print(f"‚ùå Erro no canvas: {canvas_error}")

                    self.yolo_window.after(0, update_canvas)

                # Controle de FPS - 15 FPS m√°ximo
                frame_time = time.time() - frame_start
                target_frame_time = 1.0 / 15.0  # 15 FPS

                if frame_time < target_frame_time:
                    time.sleep(target_frame_time - frame_time)

            except Exception as e:
                safe_print(f"ERRO na captura YOLO: {e}")
                time.sleep(1)

        # Cleanup da inst√¢ncia MSS
        try:
            sct.close()
        except:
            pass

        safe_print("[STOP] Thread YOLO melhorada finalizada")

    def test_feeding(self):
        """Testar sistema de alimenta√ß√£o"""
        try:
            self.save_feeding_config()  # Salvar antes de testar
            messagebox.showinfo("üçñ Teste", "Iniciando teste de alimenta√ß√£o...\nVerifique o jogo!")
            # Executar alimenta√ß√£o em thread separada
            import threading
            threading.Thread(target=self.bot.execute_feeding, daemon=True).start()
        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Erro no teste: {e}")

    def test_auto_clean(self):
        """Testar sistema de limpeza autom√°tica"""
        try:
            messagebox.showinfo("üßπ Teste", "Iniciando teste de limpeza autom√°tica...\nVerifique o jogo!\n\nO bot ir√°:\n‚Ä¢ Abrir ba√∫\n‚Ä¢ Transferir peixes\n‚Ä¢ Coletar iscas\n‚Ä¢ Fechar ba√∫")
            # Executar limpeza em thread separada
            import threading
            threading.Thread(target=self.bot.execute_auto_clean, daemon=True).start()
        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Erro no teste: {e}")

    def reset_feeding_counters(self):
        """Resetar contadores de alimenta√ß√£o"""
        if messagebox.askyesno("üîÑ Resetar", "Resetar todos os contadores de alimenta√ß√£o?"):
            self.bot.alimentacao['slot1_uses'] = 0
            self.bot.alimentacao['slot2_uses'] = 0
            self.bot.alimentacao['current_slot'] = 1
            self.bot.alimentacao['last_feed_time'] = 0
            messagebox.showinfo("‚úÖ Sucesso", "Contadores resetados!")

    def update_feeding_mode(self):
        """üçñ NOVO: Atualizar modo de alimenta√ß√£o selecionado"""
        try:
            mode = self.feeding_mode.get()
            self.bot.alimentacao['feeding_mode'] = mode

            # Atualizar descri√ß√£o
            if hasattr(self, 'mode_description'):
                self.mode_description.config(text=self.get_feeding_mode_description())

            # Salvar configura√ß√£o no arquivo
            self.save_feeding_config_to_file()
            print(f"üçñ Modo de alimenta√ß√£o alterado para: {mode}")

        except Exception as e:
            print(f"‚ùå Erro ao atualizar modo de alimenta√ß√£o: {e}")

    def get_feeding_mode_description(self):
        """üçñ NOVO: Obter descri√ß√£o do modo de alimenta√ß√£o atual"""
        mode = self.feeding_mode.get() if hasattr(self, 'feeding_mode') else 'slots_fixos'

        descriptions = {
            'slots_fixos': "‚Ä¢ Usa coordenadas fixas configuradas\n‚Ä¢ Mais r√°pido e confi√°vel\n‚Ä¢ Funciona bem se posi√ß√£o n√£o muda",
            'detecao_auto': "‚Ä¢ Busca fil√© frito automaticamente na tela\n‚Ä¢ Detecta posi√ß√£o din√¢mica do bot√£o 'eat'\n‚Ä¢ Mais lento mas adapta-se a mudan√ßas\n‚Ä¢ Ideal quando bot√£o muda de posi√ß√£o"
        }

        return descriptions.get(mode, "Modo desconhecido")

    def create_confidence_tab(self):
        """üéØ NOVO: Criar aba de configura√ß√£o de confian√ßa para TEMPLATES"""
        confidence_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(confidence_frame, text='üéØ Templates')

        # T√≠tulo da aba
        title_label = tk.Label(confidence_frame,
                             text="üéØ Configura√ß√£o de Confian√ßa por Template",
                             font=('Arial', 14, 'bold'),
                             fg='#00aaff',
                             bg='#1a1a1a')
        title_label.pack(pady=10)

        # Subt√≠tulo explicativo
        subtitle_label = tk.Label(confidence_frame,
                                text="Ajuste a precis√£o necess√°ria para cada template ser detectado.\nMudan√ßas s√£o aplicadas ao vivo e salvas automaticamente!",
                                font=('Arial', 10),
                                fg='#cccccc',
                                bg='#1a1a1a')
        subtitle_label.pack(pady=5)

        # Frame scroll√°vel para os templates
        canvas = tk.Canvas(confidence_frame, bg='#1a1a1a', highlightthickness=0)
        scrollbar = tk.Scrollbar(confidence_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#1a1a1a')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y", pady=10)

        # Dicion√°rio para armazenar as vari√°veis de confian√ßa dos templates
        self.template_confidence_vars = {}

        # Obter lista de templates do gerenciador
        template_names = self.bot.template_confidence_manager.get_template_names()
        all_confidences = self.bot.template_confidence_manager.get_all_confidences()

        # Organizar TODOS os 47 templates por categoria (com arquivos)
        template_categories = {
            "üî¥ CR√çTICOS (3)": ['peixe_capturado', 'inventario_aberto', 'barril_aberto'],
            "üé£ VARAS COM ISCA (5)": ['vara_com_isca_1', 'vara_com_isca_2', 'vara_com_isca_3', 'vara_com_isca_4', 'vara_com_isca_5'],
            "üé£ VARAS SEM ISCA (5)": ['vara_sem_isca_1', 'vara_sem_isca_2', 'vara_sem_isca_3', 'vara_sem_isca_4', 'vara_sem_isca_5'],
            "üé£ VARA QUEBRADA (1)": ['vara_quebrada'],
            "üêü PEIXES (11)": ['anchova', 'salmao_1', 'salmao_2', 'sardinha', 'truta_1', 'truta_2', 'tubarao', 'arenque', 'perca_amarela', 'peixe_cru_1', 'peixe_cru_2'],
            "ü•© ISCAS/CARNES (7)": ['carne_lobo_1', 'carne_lobo_2', 'carne_urso_1', 'carne_urso_2', 'minhoca', 'isca_1', 'isca_2'],
            "üçñ ALIMENTA√á√ÉO (3)": ['comer', 'file_frito_1', 'file_frito_2'],
            "üì¶ CONTAINERS (7)": ['caixa_grande', 'caixa_salmao', 'caixa_truta', 'caixa_perca', 'caixa_lobo', 'caixa_grub', 'caixa_worm'],
            "üîß OUTROS ITENS (4)": ['scrap', 'sinalizador', 'cartao_azul', 'gut'],
            "üíÄ ITENS ESPECIAIS (3)": ['bullet', 'BONE', 'fat']
        }

        # Criar se√ß√µes para cada categoria
        for category, template_list in template_categories.items():
            # Cabe√ßalho da categoria
            category_label = tk.Label(scrollable_frame,
                                    text=category,
                                    font=('Arial', 12, 'bold'),
                                    fg='#ffcc00',
                                    bg='#1a1a1a')
            category_label.pack(pady=(20, 10), anchor='w')

            # Frame para os templates desta categoria
            category_frame = tk.Frame(scrollable_frame, bg='#2a2a2a')
            category_frame.pack(fill='x', padx=10, pady=5)

            # Grid para os controles
            grid_frame = tk.Frame(category_frame, bg='#2a2a2a')
            grid_frame.pack(fill='x', padx=10, pady=10)

            # Cabe√ßalho da grid
            tk.Label(grid_frame, text="Template + Arquivo", fg='white', bg='#2a2a2a', font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', padx=5, pady=5)
            tk.Label(grid_frame, text="Valor", fg='white', bg='#2a2a2a', font=('Arial', 10, 'bold')).grid(row=0, column=1, padx=5, pady=5)
            tk.Label(grid_frame, text="Confian√ßa (0.5 = Flex√≠vel ‚Üí 0.9 = Preciso)", fg='white', bg='#2a2a2a', font=('Arial', 10, 'bold')).grid(row=0, column=2, padx=5, pady=5)

            row = 1
            for template_name in template_list:
                if template_name in template_names:
                    # Nome do template + arquivo .png
                    display_name = template_name.replace('_', ' ').title()
                    filename = self.bot.template_confidence_manager.get_template_filename(template_name)
                    if filename:
                        full_display = f"{display_name}\nüìÅ {filename}"
                    else:
                        full_display = display_name

                    label = tk.Label(grid_frame, text=full_display,
                            fg='white', bg='#2a2a2a', font=('Arial', 8), justify='left')
                    label.grid(row=row, column=0, sticky='w', padx=5, pady=2)

                    # Valor atual de confian√ßa
                    current_confidence = all_confidences.get(template_name, 0.7)
                    confidence_var = tk.DoubleVar(value=current_confidence)
                    self.template_confidence_vars[template_name] = confidence_var

                    # Entry para valor num√©rico
                    entry = tk.Entry(grid_frame, textvariable=confidence_var, width=6, font=('Arial', 9))
                    entry.grid(row=row, column=1, padx=5, pady=2)

                    # Slider para ajuste visual (preview em tempo real, salva s√≥ no bot√£o)
                    slider = tk.Scale(grid_frame, from_=0.5, to=0.9, resolution=0.05, orient='horizontal',
                                    variable=confidence_var, length=300, bg='#444444', fg='white',
                                    highlightthickness=0, troughcolor='#666666',
                                    command=lambda val, template=template_name: self.update_template_confidence_preview(template, float(val)))
                    slider.grid(row=row, column=2, padx=5, pady=2)

                    row += 1

        # Bot√µes de a√ß√£o
        button_frame = tk.Frame(scrollable_frame, bg='#1a1a1a')
        button_frame.pack(pady=20)

        tk.Button(button_frame, text="üîÑ Aplicar Padr√£o", command=self.reset_template_confidence,
                 bg='#6f42c1', fg='white', font=('Arial', 10, 'bold'),
                 padx=15, pady=5).pack(side='left', padx=5)

        tk.Button(button_frame, text="üéØ Cr√≠ticos: Precis√£o Alta", command=self.set_high_precision_critical,
                 bg='#dc3545', fg='white', font=('Arial', 10, 'bold'),
                 padx=15, pady=5).pack(side='left', padx=5)

        tk.Button(button_frame, text="üíæ Salvar Tudo", command=self.save_all_template_confidence,
                 bg='#28a745', fg='white', font=('Arial', 10, 'bold'),
                 padx=15, pady=5).pack(side='left', padx=5)

    # üéØ FUN√á√ïES CALLBACK PARA SISTEMA DE TEMPLATES
    def update_template_confidence_preview(self, template_name, confidence_value):
        """Atualizar confian√ßa APENAS para preview (n√£o salva arquivo)"""
        try:
            # Atualizar apenas o cache tempor√°rio para o viewer
            success = self.bot.template_confidence_manager.update_confidence_temp(template_name, confidence_value)
            if success:
                # Feedback visual opcional
                print(f"üîç Preview: Template '{template_name}' = {confidence_value:.2f} (n√£o salvo)")
            return success
        except Exception as e:
            print(f"‚ùå Erro no preview: {e}")
            return False
    
    def update_template_confidence_live(self, template_name, confidence_value):
        """Atualizar confian√ßa ao vivo E SALVAR arquivo"""
        try:
            success = self.bot.template_confidence_manager.update_confidence_live(template_name, confidence_value)
            if success:
                # Feedback visual opcional
                print(f"üíæ Template '{template_name}' salvo como {confidence_value:.2f}")
            return success
        except Exception as e:
            print(f"‚ùå Erro ao salvar: {e}")
            return False

    def reset_template_confidence(self):
        """Resetar todas as configura√ß√µes para padr√£o"""
        try:
            if messagebox.askyesno("üîÑ Resetar", "Resetar todas as configura√ß√µes de confian√ßa para os valores padr√£o?"):
                # Resetar no manager
                self.bot.template_confidence_manager.set_default_confidence()
                self.bot.template_confidence_manager.save_template_confidence()

                # Atualizar interface
                for template_name, var in self.template_confidence_vars.items():
                    default_value = self.bot.template_confidence_manager.get_template_confidence(template_name)
                    var.set(default_value)

                messagebox.showinfo("‚úÖ Sucesso", "Configura√ß√µes de template resetadas para padr√£o!")

        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Erro ao resetar configura√ß√µes: {e}")

    def set_high_precision_critical(self):
        """Aplicar alta precis√£o aos templates cr√≠ticos"""
        try:
            critical_templates = ['peixe_capturado', 'vara_com_isca', 'vara_sem_isca', 'vara_quebrada', 'inventario_aberto', 'barril_aberto']

            for template_name in critical_templates:
                if template_name in self.template_confidence_vars:
                    self.bot.template_confidence_manager.update_confidence_live(template_name, 0.85)
                    self.template_confidence_vars[template_name].set(0.85)

            messagebox.showinfo("üéØ Aplicado", "Templates cr√≠ticos configurados para alta precis√£o (0.85)!")

        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Erro ao aplicar alta precis√£o: {e}")

    def save_all_template_confidence(self):
        """Salvar todas as configura√ß√µes de confian√ßa"""
        try:
            # Salvar cada template individualmente
            saved_count = 0
            for template_name, var in self.template_confidence_vars.items():
                confidence_value = var.get()
                if self.bot.template_confidence_manager.update_confidence_live(template_name, confidence_value):
                    saved_count += 1

            messagebox.showinfo("üíæ Salvo", f"Salvos {saved_count} templates com sucesso!\nConfigura√ß√µes aplicadas ao vivo!")

        except Exception as e:
            messagebox.showerror("‚ùå Erro", f"Erro ao salvar configura√ß√µes: {e}")

    def create_yolo_viewer_tab(self):
        """üö´ REMOVIDO - Visualizador YOLO (substitu√≠do por Template Matching)"""
        # Esta fun√ß√£o foi removida - sistema agora usa apenas Template Matching
        pass

    # FUN√á√ÉO DUPLICADA REMOVIDA - usando apenas a implementa√ß√£o na linha ~2950

    def start_yolo_viewer(self):
        """Iniciar visualizador YOLO com detec√ß√µes em tempo real"""
        if not self.viewer_running:
            self.viewer_running = True
            self.viewer_status_label.config(text="üìä Status: Executando", fg='#28a745')

            # Abrir janela do visualizador
            self.yolo_viewer_window = tk.Toplevel(self.main_window)
            self.yolo_viewer_window.title("üëÅÔ∏è YOLO Viewer - Rust Game Detection")
            self.yolo_viewer_window.geometry("1000x800")
            self.yolo_viewer_window.configure(bg='#1a1a1a')

            # Canvas para a imagem
            self.viewer_canvas = tk.Canvas(self.yolo_viewer_window,
                                         bg='#333333', width=900, height=700)
            self.viewer_canvas.pack(padx=20, pady=20)

            # Callback para fechar
            self.yolo_viewer_window.protocol("WM_DELETE_WINDOW", self.stop_yolo_viewer)

            # Iniciar thread de detec√ß√£o
            threading.Thread(target=self.yolo_viewer_loop, daemon=True).start()

            print("üëÅÔ∏è YOLO Viewer iniciado!")

    def stop_yolo_viewer(self):
        """Parar visualizador YOLO"""
        self.viewer_running = False
        self.viewer_status_label.config(text="üìä Status: Parado", fg='#dc3545')

        if self.yolo_viewer_window:
            self.yolo_viewer_window.destroy()
            self.yolo_viewer_window = None

        print("üëÅÔ∏è YOLO Viewer parado!")

    def yolo_viewer_loop(self):
        """Loop principal do visualizador YOLO"""
        from PIL import Image, ImageTk, ImageDraw, ImageFont
        import cv2
        import numpy as np
        import mss

        detection_count = {}
        frame_count = 0

        # üßπ CONTROLE DE LIMPEZA PERI√ìDICA - YOLO VIEWER
        import gc
        cleanup_interval = 200  # Limpar a cada 200 frames (~20 segundos a 10fps)
        last_cleanup = 0

        # Criar inst√¢ncia MSS espec√≠fica para esta thread
        sct = mss.mss()

        while self.viewer_running:
            try:
                if not self.bot.yolo_model:
                    time.sleep(1)
                    continue

                frame_count += 1

                # Capturar tela com MSS local
                screenshot = sct.grab({"top": 0, "left": 0, "width": 1920, "height": 1080})
                img_array = np.array(screenshot)

                # Converter para RGB
                if img_array.shape[2] == 4:
                    img_rgb = img_array[:, :, [2, 1, 0]]  # BGRA -> RGB
                else:
                    img_rgb = img_array

                # Detectar objetos
                results = self.bot.yolo_model(img_rgb, verbose=False)

                # Processar detec√ß√µes
                detections = []
                if results and len(results) > 0:
                    result = results[0]
                    if hasattr(result, 'boxes') and result.boxes is not None:
                        boxes = result.boxes.xyxy.cpu().numpy()
                        confidences = result.boxes.conf.cpu().numpy()
                        classes = result.boxes.cls.cpu().numpy()

                        for box, conf, cls in zip(boxes, confidences, classes):
                            if conf >= 0.3:
                                class_name = self.bot.yolo_model.names[int(cls)]
                                detections.append({
                                    'box': box,
                                    'confidence': conf,
                                    'class': class_name
                                })

                                # Contar detec√ß√µes
                                detection_count[class_name] = detection_count.get(class_name, 0) + 1

                # Redimensionar para viewer
                height, width = img_rgb.shape[:2]
                scale = min(900/width, 700/height)
                new_width = int(width * scale)
                new_height = int(height * scale)

                # Converter para PIL e desenhar detec√ß√µes
                img_pil = Image.fromarray(img_rgb.astype('uint8'))
                img_resized = img_pil.resize((new_width, new_height), Image.Resampling.LANCZOS)

                # üéØ TRACKER: Mapear slots das varas - COORDENADAS REAIS
                SLOT_POSITIONS = {
                    1: (709, 1005),   # Slot 1
                    2: (805, 1005),   # Slot 2
                    3: (899, 1005),   # Slot 3
                    4: (992, 1005),   # Slot 4
                    5: (1092, 1005),  # Slot 5
                    6: (1188, 1005)   # Slot 6
                }

                rod_slots = {}
                vara_detections = []

                # Extrair detec√ß√µes de varas
                for det in detections:
                    if det['class'] in ['vara', 'vara com isca']:
                        x1, y1, x2, y2 = det['box']
                        center_x = (x1 + x2) / 2
                        center_y = (y1 + y2) / 2
                        vara_detections.append({
                            'detection': det,
                            'center_x': center_x,
                            'center_y': center_y,
                            'box': det['box'],
                            'class': det['class']
                        })

                # Mapear varas para slots por dist√¢ncia
                used_detections = set()
                for slot, (slot_x, slot_y) in SLOT_POSITIONS.items():
                    best_match = None
                    best_distance = float('inf')
                    best_index = -1

                    for i, vara in enumerate(vara_detections):
                        if i in used_detections:
                            continue

                        distance = ((vara['center_x'] - slot_x) ** 2 + (vara['center_y'] - slot_y) ** 2) ** 0.5
                        # Reduzir toler√¢ncia para 60 pixels - mais preciso
                        if distance < best_distance and distance < 60:
                            best_distance = distance
                            best_match = vara
                            best_index = i

                    if best_match:
                        used_detections.add(best_index)
                        rod_slots[slot] = best_match
                        rod_slots[slot]['distance'] = best_distance  # Adicionar dist√¢ncia para debug

                # üî¥ DETECTAR VARAS QUEBRADAS com template matching
                broken_rods = []
                try:
                    # Usar a imagem j√° capturada para detec√ß√£o de varas quebradas
                    broken_rods = self.bot.detect_broken_rods(img_rgb)
                except Exception as e:
                    print(f"‚ùå Erro na detec√ß√£o de vara quebrada: {e}")

                # üéØ DETECTAR ESTADO DAS VARAS COM TEMPLATE MATCHING
                rod_bait_states = {}
                for slot, vara_info in rod_slots.items():
                    try:
                        # Capturar √°rea da vara para detec√ß√£o de isca
                        x1, y1, x2, y2 = vara_info['box']

                        # Ampliar regi√£o para an√°lise de cor
                        margin = 20
                        region_x = max(0, int(x1 - margin))
                        region_y = max(0, int(y1 - margin))
                        region_w = min(1920 - region_x, int(x2 - x1 + 2 * margin))
                        region_h = min(1080 - region_y, int(y2 - y1 + 2 * margin))

                        # Usar m√©todo existente de detec√ß√£o de cor
                        has_bait = self.bot.detect_color_in_region(
                            region_x, region_y, region_w, region_h,
                            target_color=(244, 164, 96),  # Cor da isca
                            tolerance=50,
                            min_pixels=10
                        )

                        rod_bait_states[slot] = has_bait

                    except Exception as e:
                        # Se falhar, assumir sem isca como fallback
                        rod_bait_states[slot] = False
                        print(f"‚ö†Ô∏è Erro detectando isca no slot {slot}: {e}")

                # Desenhar ret√¢ngulos e tracking
                draw = ImageDraw.Draw(img_resized)
                colors = {'peixe': (0, 255, 0), 'vara': (255, 0, 0), 'default': (0, 0, 255)}

                # Desenhar posi√ß√µes esperadas dos slots (apenas se n√£o houver vara)
                for slot, (slot_x, slot_y) in SLOT_POSITIONS.items():
                    x_scaled = int(slot_x * scale)
                    y_scaled = int(slot_y * scale)

                    # Verificar se h√° vara neste slot
                    has_rod = slot in rod_slots

                    if not has_rod:
                        # Slot vazio - mostrar posi√ß√£o esperada com X cinza
                        draw.line([x_scaled-10, y_scaled-10, x_scaled+10, y_scaled+10],
                                 fill=(128, 128, 128), width=1)
                        draw.line([x_scaled-10, y_scaled+10, x_scaled+10, y_scaled-10],
                                 fill=(128, 128, 128), width=1)
                        draw.text((x_scaled-10, y_scaled-25), f"[{slot}]", fill=(128, 128, 128))

                # üî¥ DESENHAR VARAS QUEBRADAS
                for broken in broken_rods:
                    x_broken = int(broken['x'] * scale)
                    y_broken = int(broken['y'] * scale)

                    # X GRANDE vermelho para vara quebrada - RESTAURADO
                    size = 50  # AUMENTADO: era 30, agora 50 para melhor visibilidade
                    draw.line([x_broken-size, y_broken-size, x_broken+size, y_broken+size],
                            fill=(255, 0, 0), width=8)  # Width aumentado tamb√©m
                    draw.line([x_broken-size, y_broken+size, x_broken+size, y_broken-size],
                            fill=(255, 0, 0), width=8)  # Width aumentado tamb√©m

                    # Label de vara quebrada
                    draw.text((x_broken-40, y_broken-50), "VARA QUEBRADA", fill=(255, 0, 0))
                    draw.text((x_broken-30, y_broken+35), f"Conf: {broken['confidence']:.2f}", fill=(255, 0, 0))

                for det in detections:
                    x1, y1, x2, y2 = det['box']
                    # Ajustar coordenadas para imagem redimensionada
                    x1_res = int(x1 * scale)
                    y1_res = int(y1 * scale)
                    x2_res = int(x2 * scale)
                    y2_res = int(y2 * scale)

                    center_x_res = (x1_res + x2_res) // 2
                    center_y_res = (y1_res + y2_res) // 2

                    # üé® SISTEMA DE CORES BASEADO EM ESTADO DA VARA
                    if 'peixe' in det['class'].lower():
                        color = (0, 255, 0)  # Verde para peixes
                    elif 'vara' in det['class'].lower():
                        # üéØ INDICADOR ESPECIAL PARA VARA NA M√ÉO
                        center_x = (x1 + x2) / 2
                        center_y = (y1 + y2) / 2
                        slot_number = self.bot.map_rod_position_to_slot(center_x, center_y)
                        current_rod_in_hand = getattr(self.bot, 'rod_hand_tracking', {}).get('current_rod', 1)

                        if slot_number == current_rod_in_hand:
                            # üü° Vara atualmente na m√£o = AMARELO BRILHANTE
                            color = (0, 255, 255)  # Amarelo (BGR format)
                        else:
                            # üé£ Outras varas: cor baseada no estado de isca
                            if 'with_bait' in det['class'].lower() or 'com_isca' in det['class'].lower():
                                color = (0, 0, 255)    # Vermelho para vara com isca
                            elif 'without_bait' in det['class'].lower() or 'sem_isca' in det['class'].lower():
                                color = (255, 0, 0)    # Azul para vara sem isca
                            elif 'broken' in det['class'].lower() or 'quebrada' in det['class'].lower():
                                color = (128, 128, 128)  # Cinza para vara quebrada
                            else:
                                color = (255, 255, 255)  # Branco para vara desconhecida
                    else:
                        color = (0, 0, 255)  # Azul para outros objetos

                    # Desenhar ret√¢ngulo
                    draw.rectangle([x1_res, y1_res, x2_res, y2_res], outline=color, width=2)

                    # üéØ TRACKING VISUAL: Adicionar n√∫mero do slot para varas
                    if det['class'] in ['vara', 'vara com isca']:
                        center_x = (x1 + x2) / 2
                        center_y = (y1 + y2) / 2

                        # Verificar se esta vara tem slot mapeado
                        slot_number = None
                        for slot, vara_info in rod_slots.items():
                            if abs(vara_info['center_x'] - center_x) < 10 and abs(vara_info['center_y'] - center_y) < 10:
                                slot_number = slot
                                break

                        if slot_number:
                            # üéØ Verificar se esta √© a vara na m√£o
                            current_rod_in_hand = getattr(self.bot, 'rod_hand_tracking', {}).get('current_rod', 1)
                            is_rod_in_hand = (slot_number == current_rod_in_hand)

                            # Usar status do rod_slots se dispon√≠vel
                            vara_info = rod_slots.get(slot_number, {})
                            if 'status' in vara_info:
                                status = vara_info['status']
                            else:
                                # Fallback para detec√ß√£o baseada em isca
                                has_bait = rod_bait_states.get(slot_number, False)
                                status = "COM ISCA" if has_bait else "SEM ISCA"

                            # Definir cor do c√≠rculo baseado no status
                            if status == "COM ISCA":
                                circle_color = (0, 255, 0)  # Verde
                            elif status == "SEM ISCA":
                                circle_color = (255, 0, 0)  # Azul
                            elif status == "QUEBRADA":
                                circle_color = (0, 0, 255)  # Vermelho
                            else:
                                circle_color = (128, 128, 128)  # Cinza

                            # üü° INDICADOR ESPECIAL PARA VARA NA M√ÉO
                            if is_rod_in_hand:
                                # C√≠rculo AMARELO PULSANTE para vara na m√£o
                                circle_color = (0, 255, 255)  # Amarelo (BGR)
                                status = f"üéØ NA M√ÉO - {status}"
                                # Contorno extra grosso
                                draw.ellipse([center_x_res-30, center_y_res-30, center_x_res+30, center_y_res+30],
                                           fill=circle_color, outline=(255, 255, 255), width=5)
                                # Segundo c√≠rculo interno para efeito
                                draw.ellipse([center_x_res-25, center_y_res-25, center_x_res+25, center_y_res+25],
                                           fill=None, outline=(0, 0, 0), width=2)
                            else:
                                # C√≠rculo normal para varas n√£o na m√£o
                                draw.ellipse([center_x_res-25, center_y_res-25, center_x_res+25, center_y_res+25],
                                           fill=circle_color, outline=(0, 0, 0), width=3)

                            # N√∫mero do slot
                            draw.text((center_x_res-12, center_y_res-15), str(slot_number), fill=(255, 255, 255))

                            # Labels especiais para vara na m√£o
                            if is_rod_in_hand:
                                draw.text((x1_res, y1_res-60), f"üéØ VARA ATIVA", fill=(0, 255, 255))
                                draw.text((x1_res, y1_res-45), f"SLOT {slot_number} - {status}", fill=(0, 255, 255))
                            else:
                                draw.text((x1_res, y1_res-45), f"SLOT {slot_number} - {status}", fill=color)

                            draw.text((x1_res, y1_res-30), f"Dist: {rod_slots[slot_number].get('distance', 0):.1f}px", fill=(255, 255, 0))
                            draw.text((x1_res, y1_res-15), f"{det['class']} {det['confidence']:.2f}", fill=color)
                        else:
                            # Vara n√£o mapeada
                            draw.text((x1_res, y1_res-30), "N√ÉO MAPEADA", fill=(255, 100, 100))
                            draw.text((x1_res, y1_res-15), f"{det['class']} {det['confidence']:.2f}", fill=color)
                    else:
                        # N√£o √© vara, label normal
                        draw.text((x1_res, y1_res-15), f"{det['class']} {det['confidence']:.2f}", fill=color)

                # üßπ LIMPEZA PERI√ìDICA DE MEM√ìRIA - YOLO VIEWER
                if frame_count - last_cleanup >= cleanup_interval:
                    try:
                        # Limpar vari√°veis tempor√°rias
                        del img_array, img_rgb
                    except:
                        pass
                    # Limpeza otimizada
                    self.periodic_memory_cleanup(frame_count, "YOLO VIEWER")
                    last_cleanup = frame_count

                # Atualizar canvas
                img_tk = ImageTk.PhotoImage(img_resized)

                if self.yolo_viewer_window and self.viewer_running:
                    def update_viewer():
                        try:
                            # üßπ LIMPEZA DE MEM√ìRIA: Liberar imagem anterior
                            if hasattr(self.viewer_canvas, 'image'):
                                del self.viewer_canvas.image

                            self.viewer_canvas.delete("all")
                            self.viewer_canvas.create_image(450, 350, image=img_tk, anchor='center')
                            self.viewer_canvas.image = img_tk

                            # Atualizar estat√≠sticas
                            stats_text = f"Frame: {frame_count} | Detec√ß√µes: {len(detections)}\n"
                            for class_name, count in sorted(detection_count.items()):
                                stats_text += f"{class_name}: {count} | "

                            if hasattr(self, 'detection_stats_label'):
                                self.detection_stats_label.config(text=stats_text)

                        except Exception as e:
                            print(f"‚ùå Erro ao atualizar viewer: {e}")

                    self.yolo_viewer_window.after(0, update_viewer)

                time.sleep(0.2)  # 5 FPS

            except Exception as e:
                print(f"‚ùå Erro no YOLO viewer: {e}")
                time.sleep(1)

        # Cleanup da inst√¢ncia MSS
        try:
            sct.close()
        except:
            pass

    def create_catch_viewer_tab(self):
        """Criar aba para visualizar detec√ß√µes de template matching (CATCH)"""
        catch_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(catch_frame, text='üêü CATCH Viewer')

        # T√≠tulo
        title_label = tk.Label(catch_frame,
                              text="üêü Visualizador Template Matching - CATCH",
                              font=('Arial', 14, 'bold'),
                              fg='#00ff88', bg='#1a1a1a')
        title_label.pack(pady=15)

        # Frame de controles
        control_frame = tk.Frame(catch_frame, bg='#1a1a1a')
        control_frame.pack(fill='x', padx=20, pady=10)

        # Bot√µes de controle
        button_frame = tk.Frame(control_frame, bg='#1a1a1a')
        button_frame.pack()

        self.catch_viewer_running = False
        self.catch_viewer_window = None
        self.is_recording_viewer = False

        start_catch_btn = tk.Button(button_frame, text="üöÄ Iniciar CATCH Viewer",
                                   command=lambda: self.start_catch_viewer(),
                                   bg='#28a745', fg='white', font=('Arial', 10, 'bold'),
                                   padx=15, pady=8)
        start_catch_btn.pack(side='left', padx=5)

        stop_catch_btn = tk.Button(button_frame, text="‚èπÔ∏è Parar CATCH Viewer",
                                  command=lambda: self.stop_catch_viewer(),
                                  bg='#dc3545', fg='white', font=('Arial', 10, 'bold'),
                                  padx=15, pady=8)
        stop_catch_btn.pack(side='left', padx=5)

        # Status do catch viewer
        self.catch_viewer_status_label = tk.Label(control_frame,
                                                 text="üìä Status: Parado",
                                                 font=('Arial', 10),
                                                 fg='#dc3545', bg='#1a1a1a')
        self.catch_viewer_status_label.pack(pady=10)

        # Frame para estat√≠sticas do template
        catch_stats_frame = tk.LabelFrame(catch_frame, text="üìä Estat√≠sticas Template Matching",
                                         bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        catch_stats_frame.pack(fill='x', padx=20, pady=10)

        self.catch_stats_label = tk.Label(catch_stats_frame,
                                         text="Nenhuma estat√≠stica de template dispon√≠vel",
                                         bg='#2a2a2a', fg='white',
                                         font=('Consolas', 9))
        self.catch_stats_label.pack(pady=10)

        # Instru√ß√µes
        catch_instructions = """
üìã INSTRU√á√ïES DO CATCH VIEWER:
‚ö° SISTEMA SEMPRE ATIVO: Template matching funciona automaticamente quando o bot inicia (F9)
1. Clique 'Iniciar CATCH Viewer' apenas para VISUALIZAR a detec√ß√£o em tempo real
2. Janela mostra captura de tela com detec√ß√µes de 'peixe capturado'
3. Verde: Template matching detectou catch.png na tela (confian√ßa > 0.5)
4. Sistema funciona em background mesmo com a janela fechada
5. Baseado no test_template_visual.py - detec√ß√£o principal do bot
6. Use para debugar e verificar se o sistema est√° detectando corretamente
        """

        catch_instruction_label = tk.Label(catch_frame, text=catch_instructions,
                                          bg='#1a1a1a', fg='#cccccc',
                                          font=('Arial', 9),
                                          justify='left')
        catch_instruction_label.pack(padx=20, pady=10)

    def start_catch_viewer(self):
        """Iniciar visualizador CATCH (template matching)"""
        if not self.catch_viewer_running:
            self.catch_viewer_running = True
            self.catch_viewer_status_label.config(text="üìä Status: Executando", fg='#28a745')

            # Abrir janela do visualizador CATCH
            self.catch_viewer_window = tk.Toplevel(self.main_window)
            self.catch_viewer_window.title("üêü CATCH Viewer - Template Matching")
            self.catch_viewer_window.geometry("1000x800")
            self.catch_viewer_window.configure(bg='#1a1a1a')

            # Canvas para a imagem
            self.catch_canvas = tk.Canvas(self.catch_viewer_window,
                                         bg='#333333', width=900, height=700)
            self.catch_canvas.pack(padx=20, pady=20)

            # Callback para fechar
            self.catch_viewer_window.protocol("WM_DELETE_WINDOW", self.stop_catch_viewer)

            # Iniciar thread de template matching
            threading.Thread(target=self.catch_viewer_loop, daemon=True).start()

            print("üêü CATCH Viewer iniciado!")

    def stop_catch_viewer(self):
        """üîÑ CORRIGIDO: Parar visualizador CATCH sem travar"""
        print("üîÑ Parando CATCH viewer...")
        self.catch_viewer_running = False

        # Atualizar status de forma segura
        try:
            if hasattr(self, 'catch_viewer_status_label') and self.catch_viewer_status_label.winfo_exists():
                self.catch_viewer_status_label.config(text="üìä Status: Parado", fg='#dc3545')
        except (tk.TclError, AttributeError):
            pass

        # Fechar janela de forma segura
        try:
            if self.catch_viewer_window and self.catch_viewer_window.winfo_exists():
                self.catch_viewer_window.destroy()
        except (tk.TclError, AttributeError):
            pass
        finally:
            self.catch_viewer_window = None
            print("‚úÖ CATCH viewer parado com sucesso")

    def catch_viewer_loop(self):
        """Loop principal do visualizador - DETECTA TODOS OS TEMPLATES"""
        try:
            # Atualizar status inicial
            if hasattr(self, 'catch_stats_label'):
                self.catch_stats_label.config(text="üöÄ Carregando CATCH Viewer...\nImportando depend√™ncias...")

            from PIL import Image, ImageTk, ImageDraw, ImageFont
        except ImportError:
            from PIL import Image, ImageTk, ImageDraw
            try:
                from PIL import ImageFont
            except ImportError:
                # Fallback se ImageFont n√£o estiver dispon√≠vel
                ImageFont = None
        import cv2
        import numpy as np
        import mss
        import os
        import glob

        # üéØ USAR TEMPLATE MANAGER CENTRALIZADO NO CATCH VIEWER
        template_manager = TemplateManager()
        
        # Carregar templates uma vez via TemplateManager
        print("üîÑ Carregando templates via TemplateManager...")
        if not template_manager.load_all_templates():
            print("‚ùå Falha ao carregar templates via TemplateManager!")
            self.stop_catch_viewer()
            return
        
        # Obter templates j√° carregados (sem I/O adicional)
        templates = template_manager.get_all_templates()
        template_colors = {}
        
        # Cores diferentes para cada template (RGB)
        colors = [
            (0, 255, 0),    # Verde - catch.png
            (255, 0, 0),    # Vermelho - varaquebrada.png
            (0, 0, 255),    # Azul
            (255, 255, 0),  # Amarelo
            (255, 0, 255),  # Magenta
            (0, 255, 255),  # Ciano
            (128, 255, 0),  # Verde-lim√£o
            (255, 128, 0),  # Laranja
            (128, 0, 255),  # Roxo
            (255, 255, 255),# Branco
        ]

        # Configurar cores para templates (sem carregamento adicional)
        i = 0
        for template_name in templates.keys():
            # üé® SISTEMA DE CORES ESPEC√çFICAS
            if template_name in ['varacomisca.png', 'comiscavara.png', 'namaocomisca.png', 'comiscanamao.png', 'VARANOBAUCI.png']:
                template_colors[template_name] = (0, 255, 0)  # Verde = COM ISCA
            elif template_name in ['varasemisca.png', 'semiscavara.png', 'semiscanam.png', 'namaosemisca.png']:
                template_colors[template_name] = (0, 0, 255)  # Azul = SEM ISCA
            elif template_name == 'varaquebrada.png':
                template_colors[template_name] = (255, 0, 0)  # Vermelho = QUEBRADA
            elif template_name == 'namao.png':
                template_colors[template_name] = (255, 165, 0)  # Laranja = VARA NA M√ÉO
            elif template_name == 'catch.png':
                template_colors[template_name] = (0, 255, 0)  # Verde para peixes capturados
            elif template_name == 'atencao.png':
                template_colors[template_name] = (255, 255, 0)  # Amarelo = ATEN√á√ÉO
            else:
                template_colors[template_name] = colors[i % len(colors)]  # Cores padr√£o para outros
            i += 1

        if not templates:
            print("‚ùå Nenhum template carregado pelo TemplateManager!")
            self.stop_catch_viewer()
            return

        print(f"\nüéØ Templates carregados via cache: {len(templates)}")
        
        # Exibir estat√≠sticas do TemplateManager
        stats = template_manager.get_stats()
        print(f"üìä TemplateManager Stats: {stats['count']} templates, {stats['memory_mb']:.1f}MB mem√≥ria")

        # Configurar captura (IGUAL AO test_template_visual.py)
        sct = mss.mss()
        monitors = sct.monitors
        primary_monitor = monitors[1]

        # Capturar TELA TODA (IGUAL AO test_template_visual.py)
        fish_region = {
            "top": 0,
            "left": 0,
            "width": primary_monitor['width'],
            "height": primary_monitor['height']
        }

        frame_count = 0
        detections_total = {}

        # Inicializar contador para cada template
        for template_name in templates:
            detections_total[template_name] = 0

        # üßπ CONTROLE DE LIMPEZA PERI√ìDICA E OTIMIZA√á√ÉO DE MEM√ìRIA
        import gc
        cleanup_interval = 100  # Limpar a cada 100 frames (~10 segundos a 10fps)
        last_cleanup = 0

        # üéØ DETEC√á√ÉO COMPLETA: Processar TODOS os templates sempre (igual arquivo de refer√™ncia)

        # üéØ SISTEMA DE DETEC√á√ÉO DE INVENT√ÅRIO/LOOT - MODO COMPLETO
        # Usar atributos da inst√¢ncia para compartilhar entre threads
        self.inventory_loot_detected = False
        self.last_inventory_loot_check = 0
        self.tab_pressed_recently = False
        self.rod_status_preserved = False  # Para manter status das varas ap√≥s fechar invent√°rio

        # üíæ INICIALIZAR SISTEMA DE STATUS DAS VARAS SE NECESS√ÅRIO
        if not hasattr(self, 'rod_status_tracking'):
            self.rod_status_tracking = {
                'available_with_bait': [],
                'available_without_bait': [],
                'broken_rods': [],
                'slots': {},  # ADICIONADO: tracking detalhado por slot
                'inventory_was_open': False,  # ADICIONADO: controle do estado do invent√°rio
                'last_inventory_check': 0,  # ADICIONADO: timestamp da √∫ltima verifica√ß√£o
                'last_update': time.time(),
                'preserved': False
            }
            print("üîß Sistema de tracking de varas inicializado")

        # üéÆ SISTEMA DE DETEC√á√ÉO DE TAB
        import keyboard

        def on_tab_press():
            self.tab_pressed_recently = True
            if self.inventory_loot_detected:
                print("üéÆ TAB detectado - Desativando modo completo do Catch Viewer")
                print("üíæ Mantendo status das varas at√© pr√≥xima abertura do invent√°rio")
                self.inventory_loot_detected = False
                self.rod_status_preserved = True  # Marcar que devemos preservar o status das varas

                # DEBUG: Mostrar status atual das varas e marcar como preservado
                if hasattr(self, 'rod_status_tracking') and self.rod_status_tracking:
                    self.rod_status_tracking['preserved'] = True  # Marcar como preservado
                    # Status preservado silenciosamente
                else:
                    print("‚ö†Ô∏è DEBUG: Nenhum status de varas para preservar")

        # Registrar listener para TAB (sem bloquear)
        try:
            keyboard.on_press_key('tab', lambda _: on_tab_press())
        except:
            print("‚ö†Ô∏è N√£o foi poss√≠vel registrar listener de TAB")

        while self.catch_viewer_running:
            try:
                frame_count += 1

                # üßπ LIMPEZA PERI√ìDICA DE MEM√ìRIA
                if frame_count - last_cleanup >= cleanup_interval:
                    # For√ßar garbage collection
                    gc.collect()
                    last_cleanup = frame_count
                    if frame_count % 500 == 0:  # Print menos frequente
                        print(f"üßπ Limpeza de mem√≥ria executada no frame {frame_count}")

                # Capturar tela
                screenshot = sct.grab(fish_region)
                screen_img = np.array(screenshot)

                # Converter BGRA para BGR
                if screen_img.shape[2] == 4:
                    screen_img = cv2.cvtColor(screen_img, cv2.COLOR_BGRA2BGR)

                screen_copy = screen_img.copy()
                all_detections = []

                # ‚ö° OTIMIZA√á√ÉO: Limpar screenshot original da mem√≥ria imediatamente
                del screenshot

                # üéØ SISTEMA INTELIGENTE DE SELE√á√ÉO DE TEMPLATES
                templates_to_process = []

                # üîç VERIFICAR SE INVENTORY/LOOT FOI DETECTADO (verifica√ß√£o r√°pida primeiro)
                if frame_count - self.last_inventory_loot_check >= 5:  # Verificar a cada 5 frames
                    # Verifica√ß√£o r√°pida apenas para inventory.png e loot.png
                    check_templates = ['inventory.png', 'loot.png']
                    for template_name in check_templates:
                        if template_name in templates:
                            template_data = templates[template_name]
                            template_img = template_data['image']

                            # Cache de tela para verifica√ß√£o r√°pida
                            if not hasattr(self, '_quick_screen_cache'):
                                self._quick_screen_cache = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)

                            # Cache de template
                            cache_key = f"{template_name}_quick"
                            if not hasattr(self, '_quick_template_cache'):
                                self._quick_template_cache = {}
                            if cache_key not in self._quick_template_cache:
                                self._quick_template_cache[cache_key] = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)

                            # Template matching r√°pido
                            result = cv2.matchTemplate(self._quick_screen_cache, self._quick_template_cache[cache_key], cv2.TM_CCOEFF_NORMED)

                            # Obter threshold configur√°vel
                            template_mapping = self.bot.template_confidence_manager.get_template_files_dict()
                            template_key = template_mapping.get(template_name, None)
                            if template_key:
                                threshold = self.bot.template_confidence_manager.get_template_confidence(template_key)
                            else:
                                threshold = 0.8

                            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
                            if max_val >= threshold:
                                # DESATIVADO sistema de MODO COMPLETO - apenas marcar invent√°rio detectado
                                # N√£o imprimir mensagens repetitivas sobre modo completo
                                pass  # Invent√°rio detectado mas sem ativar modo completo
                                break

                    self.last_inventory_loot_check = frame_count

                # üéØ DETECTAR TODOS OS TEMPLATES SEMPRE (igual arquivo de refer√™ncia)
                # Testar CADA template
                for template_name, template_data in templates.items():
                    template_img = template_data['image']
                    template_w = template_data['width']
                    template_h = template_data['height']

                    # üîÑ PROCESSAMENTO SIMPLES UNIFICADO (igual arquivo de refer√™ncia)
                    screen_processed = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
                    template_processed = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)

                    # Template matching com imagens processadas
                    result = cv2.matchTemplate(screen_processed, template_processed, cv2.TM_CCOEFF_NORMED)

                    # üéØ USAR MAPEAMENTO DIRETO DO SISTEMA DE CONFIAN√áA CONFIGUR√ÅVEL
                    template_mapping = self.bot.template_confidence_manager.get_template_files_dict()

                    # Obter confian√ßa do sistema configur√°vel ou usar padr√£o
                    template_key = template_mapping.get(template_name, None)
                    if template_key and hasattr(self.bot, 'template_confidence_manager'):
                        threshold = self.bot.template_confidence_manager.get_template_confidence(template_key)
                        # Print removido para otimiza√ß√£o - s√≥ em debug se necess√°rio
                    else:
                        # Fallback para thresholds fixos se n√£o encontrar no sistema
                        threshold = 0.7
                        # Print removido para otimiza√ß√£o

                    # Encontrar TODOS os matches acima do threshold
                    locations = np.where(result >= threshold)

                    # Processar cada match
                    for pt in zip(*locations[::-1]):
                        confidence = result[pt[1], pt[0]]

                        # Verificar se n√£o √© duplicata (muito pr√≥ximo de outro match)
                        is_duplicate = False
                        for existing in all_detections:
                            # Aumentar dist√¢ncia m√≠nima para evitar sobreposi√ß√µes
                            if (abs(existing['x'] - pt[0]) < 50 and
                                abs(existing['y'] - pt[1]) < 50):
                                is_duplicate = True
                                break

                        if not is_duplicate:
                            all_detections.append({
                                'name': template_name,
                                'x': pt[0],
                                'y': pt[1],
                                'width': template_w,
                                'height': template_h,
                                'confidence': confidence,
                                'color': template_colors[template_name]
                            })

                            # Contar detec√ß√£o
                            detections_total[template_name] += 1

                            # Log apenas para templates importantes e com detalhes
                            if template_name == 'catch.png':
                                print(f"üêü [VIEWER] PEIXE CAPTURADO! Confian√ßa {confidence:.3f} em ({pt[0]}, {pt[1]})")
                            elif template_name == 'varaquebrada.png':
                                print(f"üî¥ [VIEWER] VARA QUEBRADA! Confian√ßa {confidence:.3f}")
                            elif template_name == 'shark.png':
                                print(f"ü¶à [VIEWER] SHARK DETECTADO! Confian√ßa {confidence:.3f} em ({pt[0]}, {pt[1]})")
                            elif template_name in ['varacomisca.png', 'comiscavara.png', 'varasemisca.png', 'semiscavara.png', 'namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'VARANOBAUCI.png']:
                                # Padronizar detec√ß√£o: COM ISCA = comisca/varacomisca/namaocomisca/comiscanamao/varanobauci, SEM ISCA = semisca/varasemisca/semiscanam/namaosemisca
                                status = "COM ISCA" if ("comisca" in template_name or "namaocomisca" in template_name or "comiscanamao" in template_name or "varanobauci" in template_name) else "SEM ISCA"
                                print(f"üé£ [VIEWER] Vara {status} detectada - Conf: {confidence:.3f}")
                            elif template_name == 'bullet.png':
                                print(f"üí• [VIEWER] BULLET detectado! Confian√ßa {confidence:.3f} em ({pt[0]}, {pt[1]})")
                            elif template_name == 'BONE.png':
                                print(f"üíÄ [VIEWER] BONE detectado! Confian√ßa {confidence:.3f} em ({pt[0]}, {pt[1]})")
                            elif template_name == 'fat.png':
                                print(f"üßà [VIEWER] FAT detectado! Confian√ßa {confidence:.3f} em ({pt[0]}, {pt[1]})")
                            elif template_name in ['peixecru.png', 'rawfish.png']:
                                print(f"üêü [VIEWER] PEIXE CRU detectado! Confian√ßa {confidence:.3f} em ({pt[0]}, {pt[1]})")

                # üî• ARMAZENAR √öLTIMAS DETEC√á√ïES PARA OUTRAS FUN√á√ïES USAREM
                self.last_catch_viewer_detections = {}
                for detection in all_detections:
                    template_name = detection['name']
                    # Manter apenas a detec√ß√£o mais confiante de cada template
                    if template_name not in self.last_catch_viewer_detections or detection['confidence'] > self.last_catch_viewer_detections[template_name]['confidence']:
                        self.last_catch_viewer_detections[template_name] = detection

                # Desenhar TODAS as detec√ß√µes
                for detection in all_detections:
                    top_left = (detection['x'], detection['y'])
                    bottom_right = (detection['x'] + detection['width'],
                                  detection['y'] + detection['height'])
                    center_x = detection['x'] + detection['width'] // 2
                    center_y = detection['y'] + detection['height'] // 2

                    # Usar cor espec√≠fica do template
                    color = detection['color']

                    # üé® DESENHO ESPECIAL PARA VARA QUEBRADA - X VERMELHO
                    if detection['name'] == 'varaquebrada.png':
                        # Desenhar X vermelho grande ao inv√©s de ret√¢ngulo
                        size = max(detection['width'], detection['height']) // 2
                        cv2.line(screen_copy,
                                (center_x - size, center_y - size),
                                (center_x + size, center_y + size),
                                color, 5)  # Linha diagonal 1
                        cv2.line(screen_copy,
                                (center_x - size, center_y + size),
                                (center_x + size, center_y - size),
                                color, 5)  # Linha diagonal 2
                    else:
                        # Ret√¢ngulo normal para outros templates
                        cv2.rectangle(screen_copy, top_left, bottom_right, color, 2)

                    # Adicionar texto com nome do template formatado
                    name_display = detection['name'][:-4].upper().replace('_', ' ')
                    label = f"{name_display} {detection['confidence']*100:.1f}%"

                    # Background para o texto
                    (text_width, text_height), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
                    cv2.rectangle(screen_copy,
                                 (top_left[0], top_left[1] - text_height - 10),
                                 (top_left[0] + text_width + 5, top_left[1] - 5),
                                 (0, 0, 0), -1)

                    # Texto com cor branca
                    cv2.putText(screen_copy, label,
                               (top_left[0] + 2, top_left[1] - 8),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

                # Adicionar contador de detec√ß√µes no canto inferior esquerdo
                screen_height = screen_copy.shape[0]
                y_start = screen_height - (len(detections_total) * 25 + 60)  # Mover para baixo
                y_offset = y_start + 30

                cv2.rectangle(screen_copy, (10, y_start), (350, screen_height - 10), (0, 0, 0), -1)
                cv2.putText(screen_copy, f"CATCH VIEWER - Frame {frame_count}",
                           (15, y_offset), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
                y_offset += 30

                for template_name, count in detections_total.items():
                    if count > 0:
                        color = template_colors.get(template_name, (255, 255, 255))
                        cv2.putText(screen_copy, f"{template_name[:-4]}: {count}",
                                   (15, y_offset), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                        y_offset += 25

                # Adicionar FPS
                current_time = time.time()
                if hasattr(self, 'catch_viewer_last_time'):
                    fps = 1 / (current_time - self.catch_viewer_last_time)
                    cv2.putText(screen_copy, f"FPS: {fps:.1f}",
                               (10, screen_copy.shape[0] - 20),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
                self.catch_viewer_last_time = current_time

                # Indicador de grava√ß√£o se ativo
                if self.is_recording_viewer:
                    cv2.circle(screen_copy, (screen_copy.shape[1] - 30, 30), 10, (0, 0, 255), -1)
                    cv2.putText(screen_copy, "REC",
                               (screen_copy.shape[1] - 80, 35),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

                # Redimensionar para canvas
                height, width = screen_copy.shape[:2]
                scale = min(900/width, 700/height)
                new_width = int(width * scale)
                new_height = int(height * scale)

                # Converter para PIL
                img_rgb = cv2.cvtColor(screen_copy, cv2.COLOR_BGR2RGB)
                img_pil = Image.fromarray(img_rgb.astype('uint8'))
                img_resized = img_pil.resize((new_width, new_height), Image.Resampling.LANCZOS)

                # üéØ MAPEAMENTO DE SLOTS E AN√ÅLISE DE VARAS
                SLOT_POSITIONS = {
                    1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
                    4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
                }

                # üîç VERIFICAR SE INVENT√ÅRIO EST√Å ABERTO
                inventory_open = self.bot.detect_inventory_open()

                # üîç DETECTAR VARAS NOS SLOTS - APENAS COM INVENT√ÅRIO ABERTO
                rod_slots = {}
                vara_detections = []

                # Processar detec√ß√£o de varas APENAS com invent√°rio aberto (para evitar status incorreto)
                if inventory_open:
                    # Verificar cada slot individualmente
                    for slot_num, (slot_x, slot_y) in SLOT_POSITIONS.items():
                        # Definir regi√£o ao redor do slot (100x100 pixels)
                        region_x1 = max(0, slot_x - 50)
                        region_y1 = max(0, slot_y - 50)
                        region_x2 = min(screen_img.shape[1], slot_x + 50)
                        region_y2 = min(screen_img.shape[0], slot_y + 50)

                        # Extrair regi√£o do slot
                        slot_region = screen_img[region_y1:region_y2, region_x1:region_x2]

                        # Verificar templates de vara nesta regi√£o
                        vara_found = False
                        best_match = None
                        best_confidence = 0

                        for template_name in ['varacomisca.png', 'comiscavara.png', 'varasemisca.png', 'semiscavara.png', 'namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'VARANOBAUCI.png', 'varaquebrada.png']:
                            if template_name in templates:
                                template_data = templates[template_name]
                                template_img = template_data['image']

                                # Verificar se template cabe na regi√£o
                                if template_img.shape[0] > slot_region.shape[0] or template_img.shape[1] > slot_region.shape[1]:
                                    continue

                                # Template matching na regi√£o do slot
                                slot_gray = cv2.cvtColor(slot_region, cv2.COLOR_BGR2GRAY)
                                template_gray = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)

                                result = cv2.matchTemplate(slot_gray, template_gray, cv2.TM_CCOEFF_NORMED)
                                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                                # Se encontrou match melhor que o anterior
                                # Usar threshold do template_confidence_manager (igual ao Catch Viewer)
                                template_key = template_name.replace('.png', '')
                                threshold = self.bot.template_confidence_manager.get_template_confidence(template_key)

                                if max_val > threshold and max_val > best_confidence:
                                    best_confidence = max_val
                                    best_match = {
                                        'name': template_name,
                                        'confidence': max_val,
                                        'x': region_x1 + max_loc[0],
                                        'y': region_y1 + max_loc[1],
                                        'width': template_data['width'],
                                        'height': template_data['height'],
                                        'slot': slot_num
                                    }
                                    vara_found = True

                        # Se encontrou vara neste slot
                        if vara_found and best_match:
                            # Adicionar √†s detec√ß√µes gerais para desenhar
                            best_match['color'] = template_colors.get(best_match['name'], (255, 255, 255))
                            all_detections.append(best_match)

                            # Determinar status da vara para exibi√ß√£o
                            status = "COM ISCA" if "comisca" in best_match['name'].lower() else "SEM ISCA" if "semisca" in best_match['name'].lower() else "QUEBRADA"

                            # Adicionar ao mapeamento de slots
                            rod_slots[slot_num] = {
                                'detection': best_match,
                                'center_x': slot_x,
                                'center_y': slot_y,
                                'name': best_match['name'],
                                'distance': 0,  # Dist√¢ncia zero pois est√° no slot exato
                                'status': status  # Adicionar status para exibi√ß√£o
                            }

                            # Adicionar √† lista de detec√ß√µes de vara
                            vara_detections.append(rod_slots[slot_num])

                            # Log de debug
                            if frame_count % 30 == 0:  # Log a cada 30 frames
                                print(f"[SLOT {slot_num}] {status} - Conf: {best_confidence:.2f}")

                # N√£o precisamos mapear novamente pois j√° mapeamos direto nos slots acima

                # üîç ANALISAR ESTADO DAS VARAS - MANTER STATUS AP√ìS FECHAR INVENT√ÅRIO
                # inventory_open j√° foi verificado acima

                if not hasattr(self, 'rod_status_tracking'):
                    self.rod_status_tracking = {
                        'slots': {},
                        'timeout_count': {},
                        'last_check_time': 0,
                        'available_with_bait': [],
                        'available_without_bait': [],
                        'broken_rods': [],
                        'last_inventory_check': 0,
                        'inventory_was_open': False
                    }

                # üóÑÔ∏è SISTEMA DE CACHE COMPLETO DE DETEC√á√ïES
                if not hasattr(self, 'full_detection_cache'):
                    self.full_detection_cache = {
                        'baits_in_inventory': [],  # Iscas no invent√°rio
                        'baits_in_chest': [],      # Iscas no ba√∫
                        'rods_in_chest': [],        # Varas no ba√∫ (VARANOBAUCI com isca)
                        'rods_in_inventory': [],    # Varas no invent√°rio
                        'all_items': {},            # Todos os itens detectados
                        'last_update': 0,           # √öltima atualiza√ß√£o
                        'update_interval': 10,      # Atualizar a cada 10 segundos
                        'cached_at': 0              # Quando foi cacheado
                    }

                if inventory_open:
                    # üîÑ ATUALIZAR STATUS APENAS COM INVENT√ÅRIO ABERTO (igual ultimavez - Copia (2))
                    if not self.rod_status_tracking.get('inventory_was_open', False):
                        print("\n[CATCH VIEWER] Inventario ABERTO - atualizando deteccoes...")

                    self.rod_status_tracking['inventory_was_open'] = True

                    # N√ÉO LIMPAR - apenas inicializar se n√£o existir
                    if 'empty_slots' not in self.rod_status_tracking:
                        self.rod_status_tracking['empty_slots'] = []

                    # Resetar arrays de detec√ß√£o apenas se invent√°rio foi reaberto
                    # N√ÉO resetar se ainda est√° mostrando √∫ltima detec√ß√£o do invent√°rio fechado
                    if inventory_open:
                        self.rod_status_tracking['available_with_bait'].clear()
                        self.rod_status_tracking['available_without_bait'].clear()
                        self.rod_status_tracking['broken_rods'].clear()
                        self.rod_status_tracking['empty_slots'].clear()
                        self.rod_status_tracking['last_inventory_check'] = time.time()

                    # üéØ MELHORAR DETEC√á√ïES - CONSIDERAR TEMPLATES SIMILARES
                    for slot, vara_info in rod_slots.items():
                        template_name = vara_info['name'].lower()

                        # Mapear templates similares para status unificado (incluindo VARANOBAUCI)
                        if ('comisca' in template_name or 'varacomisca' in template_name or 'namaocomisca' in template_name or 'comiscanamao' in template_name or 'varanobauci' in template_name):
                            # comiscavara.png OU varacomisca.png OU namaocomisca.png OU comiscanamao.png OU VARANOBAUCI.png = COM ISCA
                            status = "COM_ISCA"
                            self.rod_status_tracking['available_with_bait'].append(slot)
                        elif ('semisca' in template_name or 'varasemisca' in template_name or 'semiscanam' in template_name or 'namaosemisca' in template_name):
                            # semiscavara.png OU varasemisca.png OU semiscanam.png OU namaosemisca.png = SEM ISCA
                            status = "SEM_ISCA"
                            self.rod_status_tracking['available_without_bait'].append(slot)
                        elif 'quebrada' in template_name:
                            status = "QUEBRADA"
                            self.rod_status_tracking['broken_rods'].append(slot)
                        else:
                            status = "DESCONHECIDO"

                        self.rod_status_tracking['slots'][slot] = {
                            'status': status,
                            'confidence': vara_info['detection']['confidence'],
                            'last_seen': time.time(),
                            'template_detected': vara_info['name']  # Manter template original
                        }

                    # Slots vazios = slots que n√£o foram detectados visualmente
                    all_slots = set(range(1, 7))
                    detected_slots = set(rod_slots.keys())
                    empty_slots = all_slots - detected_slots

                    for slot_num in empty_slots:
                        self.rod_status_tracking['slots'][slot_num] = {
                            'status': 'VAZIO',
                            'confidence': 0,
                            'last_seen': time.time(),
                            'template_detected': 'none'
                        }
                        self.rod_status_tracking['empty_slots'].append(slot_num)

                    # Log de status atualizado com invent√°rio aberto (igual ultimavez - Copia (2))
                    print(f"\n[CATCH VIEWER] Status ATUALIZADO (inventario aberto):")
                    print(f"  Com isca: {self.rod_status_tracking['available_with_bait']}")
                    print(f"  Sem isca: {self.rod_status_tracking['available_without_bait']}")
                    print(f"  Quebradas: {self.rod_status_tracking['broken_rods']}")
                    print(f"  Vazios: {self.rod_status_tracking['empty_slots']}")
                    
                    # Marcar como abertura manual se o bot n√£o est√° em limpeza autom√°tica
                    try:
                        if not self.bot.auto_clean.get('in_progress', False) and not self.bot.game_state.get('auto_clean_in_progress', False):
                            self.bot.game_state['manual_inventory_open'] = True
                            print("‚ö†Ô∏è [CATCH VIEWER] Invent√°rio aberto manualmente - contagem de peixes pausada")
                    except Exception as e:
                        print(f"‚ùå Erro no CATCH viewer: {e}")
                        # Fallback seguro - assumir abertura manual
                        if hasattr(self.bot, 'game_state'):
                            self.bot.game_state['manual_inventory_open'] = True

                    # Mostrar templates detectados para debug
                    for slot, info in self.rod_status_tracking['slots'].items():
                        template = info.get('template_detected', 'unknown')
                        conf = info.get('confidence', 0)
                        print(f"    Slot {slot}: {template} (conf: {conf:.2f})")

                    # Calcular slots vazios para exibi√ß√£o
                    all_slots = set(range(1, 7))
                    occupied_slots = set(self.rod_status_tracking['available_with_bait'] +
                                       self.rod_status_tracking['available_without_bait'] +
                                       self.rod_status_tracking['broken_rods'])
                    empty_slots = sorted(list(all_slots - occupied_slots))

                    # Log apenas quando necess√°rio (n√£o a cada frame)
                    if frame_count % 30 == 0:  # A cada 30 frames
                        print(f"\n[CATCH VIEWER] Status ATUALIZADO (inventario aberto):")
                        print(f"  Com isca: {self.rod_status_tracking['available_with_bait']}")
                        print(f"  Sem isca: {self.rod_status_tracking['available_without_bait']}")
                        print(f"  Quebradas: {self.rod_status_tracking['broken_rods']}")
                        print(f"  Vazios: {self.rod_status_tracking['empty_slots']}")
                        
                        # Marcar como abertura manual se o bot n√£o est√° em limpeza
                        try:
                            if not self.bot.auto_clean.get('in_progress', False) and not self.bot.game_state.get('auto_clean_in_progress', False):
                                self.bot.game_state['manual_inventory_open'] = True
                        except Exception as e:
                            print(f"‚ùå Erro no CATCH viewer (frame {frame_count}): {e}")
                            # Fallback seguro
                            if hasattr(self.bot, 'game_state'):
                                self.bot.game_state['manual_inventory_open'] = True

                        # Mostrar templates detectados
                        for slot, info in self.rod_status_tracking['slots'].items():
                            template = info.get('template_detected', 'unknown')
                            conf = info.get('confidence', 0)
                            print(f"    Slot {slot}: {template} (conf: {conf:.2f})")

                else:
                    # üíæ INVENT√ÅRIO FECHADO - MANTER DADOS EXISTENTES
                    if self.rod_status_tracking.get('inventory_was_open', False):
                        print("\n[CATCH VIEWER] Inventario FECHADO - mantendo ultimas deteccoes")
                        self.rod_status_tracking['inventory_was_open'] = False

                        # üìå PRESERVAR CACHE - N√ÉO ATUALIZAR QUANDO FECHADO
                        if self.full_detection_cache['cached_at'] > 0:
                            time_since_cache = time.time() - self.full_detection_cache['cached_at']
                            print(f"üì¶ [CACHE] Preservado - dados de {time_since_cache:.1f}s atr√°s")
                            print(f"   ‚Ä¢ Cache mantido com {len(self.full_detection_cache['all_items'])} itens")

                    # Log menos frequente quando invent√°rio est√° fechado
                    if frame_count % 180 == 0:  # A cada 3 minutos
                        if self.rod_status_tracking.get('last_inventory_check', 0) > 0:
                            time_since_check = time.time() - self.rod_status_tracking['last_inventory_check']
                            print(f"[CATCH VIEWER] Inventario fechado - usando dados de {time_since_check:.0f}s atras")
                            print(f"  Status preservado - Com isca: {self.rod_status_tracking['available_with_bait']}")
                        else:
                            print("[CATCH VIEWER] Aguardando primeira deteccao com inventario aberto")

                            # DEBUG: Mostrar status dos slots preservados
                            print("  üìä Status dos slots preservados:")
                            for slot in range(1, 7):
                                if slot in self.rod_status_tracking.get('slots', {}):
                                    slot_info = self.rod_status_tracking['slots'][slot]
                                    status = slot_info.get('status', 'UNKNOWN')
                                    print(f"    Slot {slot}: {status}")
                                else:
                                    print(f"    Slot {slot}: N√£o detectado")

                            # Mostrar cache preservado
                            if self.full_detection_cache['cached_at'] > 0:
                                print(f"üì¶ [CACHE] Status do cache preservado:")
                                print(f"   ‚Ä¢ Iscas no invent√°rio: {len(self.full_detection_cache['baits_in_inventory'])}")
                                print(f"   ‚Ä¢ Iscas no ba√∫: {len(self.full_detection_cache['baits_in_chest'])}")
                                print(f"   ‚Ä¢ Varas no ba√∫: {len(self.full_detection_cache['rods_in_chest'])}")

                # üßπ LIMPEZA PERI√ìDICA DE MEM√ìRIA
                if frame_count - last_cleanup >= cleanup_interval:
                    try:
                        # Limpar vari√°veis tempor√°rias
                        del screen_img
                    except:
                        pass
                    # Limpeza otimizada
                    self.periodic_memory_cleanup(frame_count, "CATCH VIEWER")
                    last_cleanup = frame_count

                # üé® ADICIONAR OVERLAYS DE SLOTS NA IMAGEM PIL
                draw = ImageDraw.Draw(img_resized)
                scale = min(900/1920, 700/1080)

                # Desenhar informa√ß√µes de cada slot
                for slot, (slot_x, slot_y) in SLOT_POSITIONS.items():
                    x_scaled = int(slot_x * scale)
                    y_scaled = int(slot_y * scale)

                    if slot in rod_slots:
                        # Slot com vara detectada
                        vara_info = rod_slots[slot]
                        template_name = vara_info['name'].lower()

                        # Determinar cor baseada no status
                        if 'comisca' in template_name:
                            circle_color = (0, 255, 0)  # Verde - com isca
                            status_text = "COM ISCA"
                        elif 'semisca' in template_name:
                            circle_color = (255, 165, 0)  # Laranja - sem isca
                            status_text = "SEM ISCA"
                        elif 'quebrada' in template_name:
                            circle_color = (255, 0, 0)  # Vermelho - quebrada
                            status_text = "QUEBRADA"
                        else:
                            circle_color = (128, 128, 128)  # Cinza - desconhecido
                            status_text = "?"

                        # Desenhar c√≠rculo do slot
                        draw.ellipse([x_scaled-25, y_scaled-25, x_scaled+25, y_scaled+25],
                                   fill=circle_color, outline=(255, 255, 255), width=3)

                        # N√∫mero do slot GRANDE e VIS√çVEL
                        font = ImageFont.load_default() if ImageFont else None
                        # N√∫mero grande em branco com contorno preto
                        for dx in [-1, 0, 1]:
                            for dy in [-1, 0, 1]:
                                if dx != 0 or dy != 0:
                                    draw.text((x_scaled-8+dx, y_scaled-10+dy), str(slot),
                                            fill=(0, 0, 0), font=font)
                        draw.text((x_scaled-8, y_scaled-10), str(slot),
                                fill=(255, 255, 255), font=font)

                        # Status abaixo
                        draw.text((x_scaled-30, y_scaled+30), status_text,
                                fill=circle_color, font=font)
                    else:
                        # Slot vazio
                        draw.line([x_scaled-15, y_scaled-15, x_scaled+15, y_scaled+15],
                                fill=(100, 100, 100), width=2)
                        draw.line([x_scaled-15, y_scaled+15, x_scaled+15, y_scaled-15],
                                fill=(100, 100, 100), width=2)
                        font = ImageFont.load_default() if ImageFont else None
                        draw.text((x_scaled-5, y_scaled+20), f"[{slot}]",
                                fill=(100, 100, 100), font=font)

                # Adicionar resumo no canto inferior direito
                info_y = img_resized.height - 150  # Mover para baixo
                info_text = "STATUS DAS VARAS:"
                draw.text((img_resized.width - 200, info_y), info_text, fill=(255, 255, 255))
                info_y += 20

                # Status das varas - estrutura limpa
                if hasattr(self, 'rod_status_tracking'):

                    if self.rod_status_tracking['available_with_bait']:
                        draw.text((img_resized.width - 200, info_y),
                                f"Com isca: {self.rod_status_tracking['available_with_bait']}",
                                fill=(0, 255, 0))
                        info_y += 15

                    if self.rod_status_tracking['available_without_bait']:
                        draw.text((img_resized.width - 200, info_y),
                                f"Sem isca: {self.rod_status_tracking['available_without_bait']}",
                                fill=(255, 165, 0))
                        info_y += 15

                    if self.rod_status_tracking['broken_rods']:
                        draw.text((img_resized.width - 200, info_y),
                                f"Quebradas: {self.rod_status_tracking['broken_rods']}",
                                fill=(255, 0, 0))
                        info_y += 15

                    # Calcular e mostrar slots vazios
                    all_slots = set(range(1, 7))
                    occupied_slots = set(self.rod_status_tracking['available_with_bait'] +
                                       self.rod_status_tracking['available_without_bait'] +
                                       self.rod_status_tracking['broken_rods'])
                    empty_slots = sorted(list(all_slots - occupied_slots))

                    if empty_slots:
                        draw.text((img_resized.width - 200, info_y),
                                f"Vazios: {empty_slots}",
                                fill=(128, 128, 128))
                        info_y += 15
                else:
                    draw.text((img_resized.width - 200, info_y), "Aguardando detec√ß√£o...", fill=(128, 128, 128))
                    info_y += 15


                # Atualizar canvas
                img_tk = ImageTk.PhotoImage(img_resized)

                # CORRE√á√ÉO: Verifica√ß√µes mais robustas para evitar travamento
                try:
                    if (self.catch_viewer_window and
                        self.catch_viewer_running and
                        hasattr(self, 'catch_canvas') and
                        self.catch_canvas.winfo_exists()):

                        def update_catch_viewer():
                            try:
                                # Verificar se janela ainda existe
                                if not self.catch_viewer_running:
                                    return

                                # üßπ LIMPEZA DE MEM√ìRIA: Liberar imagem anterior
                                if hasattr(self.catch_canvas, 'image'):
                                    del self.catch_canvas.image

                                self.catch_canvas.delete("all")
                                self.catch_canvas.create_image(450, 350, image=img_tk, anchor='center')
                                self.catch_canvas.image = img_tk

                                # ‚ö° OTIMIZA√á√ÉO: Atualizar estat√≠sticas apenas a cada 3 frames para melhor FPS
                                if frame_count % 3 == 0:
                                    total_detections = len(all_detections) if 'all_detections' in locals() else 0
                                    processed_templates = len(templates_to_process)
                                    stats_text = f"Frame: {frame_count} | FPS: {fps:.1f}\n"

                                    # Indicar modo atual
                                    if self.inventory_loot_detected:
                                        stats_text += "üéØ MODO COMPLETO ATIVO\n"
                                    elif self.rod_status_preserved:
                                        stats_text += "üíæ STATUS PRESERVADO\n"
                                    else:
                                        stats_text += "‚ö° MODO OTIMIZADO\n"

                                    stats_text += f"Processando: {processed_templates}/{len(templates)} templates\n"
                                    stats_text += "Detec√ß√µes ativas:\n"

                                    # Mostrar apenas templates com detec√ß√µes ativas
                                    active_count = 0
                                    for template_name, count in detections_total.items():
                                        if count > 0:
                                            stats_text += f"  ‚Ä¢ {template_name[:-4]}: {count}\n"
                                            active_count += 1

                                    if active_count == 0:
                                        stats_text += "  Procurando templates...\n"

                                    if hasattr(self, 'catch_stats_label') and self.catch_stats_label.winfo_exists():
                                        self.catch_stats_label.config(text=stats_text)

                            except tk.TclError:
                                # Janela foi fechada, parar viewer
                                print("üîÑ Janela CATCH viewer fechada, parando sistema...")
                                self.catch_viewer_running = False
                            except Exception as e:
                                print(f"‚ùå Erro ao atualizar CATCH viewer: {e}")

                        # Usar try/catch para o after tamb√©m
                        try:
                            self.catch_viewer_window.after(0, update_catch_viewer)
                        except tk.TclError:
                            print("üîÑ Janela CATCH viewer n√£o dispon√≠vel, parando...")
                            self.catch_viewer_running = False

                except Exception as e:
                    print(f"‚ö†Ô∏è Erro na atualiza√ß√£o da interface CATCH: {e}")
                    # Continuar o loop mesmo se interface falhar

                # ‚ö° OTIMIZA√á√ÉO: Limpeza de vari√°veis tempor√°rias no final do loop
                del screen_img, screen_copy, all_detections
                if 'result' in locals():
                    del result

                time.sleep(0.1)  # 10 FPS - balanceado para performance

            except Exception as e:
                print(f"‚ùå Erro no CATCH viewer: {e}")
                # Limpeza de emerg√™ncia
                if hasattr(self, '_screen_gray_cache'):
                    del self._screen_gray_cache
                if hasattr(self, '_template_cache'):
                    del self._template_cache
                time.sleep(1)

        # ‚ö° CLEANUP FINAL OTIMIZADO
        try:
            # Limpar listener de keyboard
            try:
                keyboard.unhook_all()
                print("üéÆ Keyboard listeners removidos")
            except:
                pass

            # Limpar cache se existir
            if hasattr(self, '_screen_gray_cache'):
                del self._screen_gray_cache
            if hasattr(self, '_template_cache'):
                self._template_cache.clear()
                del self._template_cache
            if hasattr(self, '_quick_screen_cache'):
                del self._quick_screen_cache
            if hasattr(self, '_quick_template_cache'):
                self._quick_template_cache.clear()
                del self._quick_template_cache

            # Fechar MSS
            sct.close()

            # Garbage collection final
            import gc
            gc.collect()

            print("üßπ CATCH Viewer: Limpeza final conclu√≠da")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro no cleanup final: {e}")

    def create_anti_detection_tab(self):
        """Criar aba de configura√ß√£o do sistema anti-detec√ß√£o"""
        anti_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(anti_frame, text='üõ°Ô∏è Anti-Detec√ß√£o')

        # T√≠tulo
        title_label = tk.Label(anti_frame,
                              text="üõ°Ô∏è Sistema Anti-Detec√ß√£o Avan√ßado",
                              font=('Arial', 14, 'bold'),
                              fg='#ffaa00', bg='#1a1a1a')
        title_label.pack(pady=15)

        # Frame scroll√°vel para as configura√ß√µes
        canvas = tk.Canvas(anti_frame, bg='#1a1a1a', highlightthickness=0)
        scrollbar = tk.Scrollbar(anti_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#1a1a1a')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # ========== ATIVA√á√ÉO GERAL ==========
        main_frame = tk.LabelFrame(scrollable_frame, text="‚ö° Ativa√ß√£o Geral",
                                   bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        main_frame.pack(fill='x', padx=20, pady=10)

        self.anti_detection_enabled = tk.BooleanVar(value=self.bot.anti_detection['enabled'])
        tk.Checkbutton(main_frame, text="Ativar Sistema Anti-Detec√ß√£o",
                      variable=self.anti_detection_enabled,
                      bg='#2a2a2a', fg='white', selectcolor='#2a2a2a',
                      font=('Arial', 10, 'bold'),
                      command=self.toggle_anti_detection).pack(pady=10)

        # ========== VARIA√á√ÉO DE CLIQUES ==========
        click_frame = tk.LabelFrame(scrollable_frame, text="üñ±Ô∏è Varia√ß√£o de Cliques",
                                    bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        click_frame.pack(fill='x', padx=20, pady=10)

        self.click_variation_enabled = tk.BooleanVar(value=self.bot.anti_detection['click_variation']['enabled'])
        tk.Checkbutton(click_frame, text="Ativar varia√ß√£o de cliques",
                      variable=self.click_variation_enabled,
                      bg='#2a2a2a', fg='white', selectcolor='#2a2a2a',
                      command=self.update_anti_detection_settings).pack(pady=5)

        # Sliders para configurar delays
        tk.Label(click_frame, text="Delay m√≠nimo (ms):", bg='#2a2a2a', fg='white').pack()
        self.click_min_delay = tk.Scale(click_frame, from_=50, to=150, orient='horizontal',
                                       bg='#2a2a2a', fg='white', highlightthickness=0,
                                       command=lambda v: self.update_anti_detection_settings())
        self.click_min_delay.set(self.bot.anti_detection['click_variation']['min_delay'] * 1000)
        self.click_min_delay.pack(pady=5)

        tk.Label(click_frame, text="Delay m√°ximo (ms):", bg='#2a2a2a', fg='white').pack()
        self.click_max_delay = tk.Scale(click_frame, from_=100, to=200, orient='horizontal',
                                       bg='#2a2a2a', fg='white', highlightthickness=0,
                                       command=lambda v: self.update_anti_detection_settings())
        self.click_max_delay.set(self.bot.anti_detection['click_variation']['max_delay'] * 1000)
        self.click_max_delay.pack(pady=5)

        # ========== VARIA√á√ÉO DE MOVIMENTOS A/D ==========
        movement_frame = tk.LabelFrame(scrollable_frame, text="‚å®Ô∏è Varia√ß√£o de Movimentos A/D",
                                       bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        movement_frame.pack(fill='x', padx=20, pady=10)

        self.movement_variation_enabled = tk.BooleanVar(value=self.bot.anti_detection['movement_variation']['enabled'])
        tk.Checkbutton(movement_frame, text="Ativar varia√ß√£o de movimentos",
                      variable=self.movement_variation_enabled,
                      bg='#2a2a2a', fg='white', selectcolor='#2a2a2a',
                      command=self.update_anti_detection_settings).pack(pady=5)

        # Configura√ß√µes do movimento A
        tk.Label(movement_frame, text="Dura√ß√£o A - M√≠n (s):", bg='#2a2a2a', fg='white').pack()
        self.a_duration_min = tk.Scale(movement_frame, from_=1.0, to=2.0, resolution=0.1,
                                       orient='horizontal', bg='#2a2a2a', fg='white',
                                       highlightthickness=0,
                                       command=lambda v: self.update_anti_detection_settings())
        self.a_duration_min.set(self.bot.anti_detection['movement_variation']['a_duration_min'])
        self.a_duration_min.pack(pady=5)

        tk.Label(movement_frame, text="Dura√ß√£o A - M√°x (s):", bg='#2a2a2a', fg='white').pack()
        self.a_duration_max = tk.Scale(movement_frame, from_=1.0, to=2.0, resolution=0.1,
                                       orient='horizontal', bg='#2a2a2a', fg='white',
                                       highlightthickness=0,
                                       command=lambda v: self.update_anti_detection_settings())
        self.a_duration_max.set(self.bot.anti_detection['movement_variation']['a_duration_max'])
        self.a_duration_max.pack(pady=5)

        # Configura√ß√µes do movimento D
        tk.Label(movement_frame, text="Dura√ß√£o D - M√≠n (s):", bg='#2a2a2a', fg='white').pack()
        self.d_duration_min = tk.Scale(movement_frame, from_=0.8, to=1.5, resolution=0.1,
                                       orient='horizontal', bg='#2a2a2a', fg='white',
                                       highlightthickness=0,
                                       command=lambda v: self.update_anti_detection_settings())
        self.d_duration_min.set(self.bot.anti_detection['movement_variation']['d_duration_min'])
        self.d_duration_min.pack(pady=5)

        tk.Label(movement_frame, text="Dura√ß√£o D - M√°x (s):", bg='#2a2a2a', fg='white').pack()
        self.d_duration_max = tk.Scale(movement_frame, from_=0.8, to=1.5, resolution=0.1,
                                       orient='horizontal', bg='#2a2a2a', fg='white',
                                       highlightthickness=0,
                                       command=lambda v: self.update_anti_detection_settings())
        self.d_duration_max.set(self.bot.anti_detection['movement_variation']['d_duration_max'])
        self.d_duration_max.pack(pady=5)

        # ========== PAUSAS NATURAIS ==========
        breaks_frame = tk.LabelFrame(scrollable_frame, text="‚òï Pausas Naturais",
                                     bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        breaks_frame.pack(fill='x', padx=20, pady=10)

        self.natural_breaks_enabled = tk.BooleanVar(value=self.bot.anti_detection['natural_breaks']['enabled'])
        tk.Checkbutton(breaks_frame, text="Ativar pausas naturais",
                      variable=self.natural_breaks_enabled,
                      bg='#2a2a2a', fg='white', selectcolor='#2a2a2a',
                      command=self.update_anti_detection_settings).pack(pady=5)

        # Modo de pausa (tempo ou quantidade)
        mode_frame = tk.Frame(breaks_frame, bg='#2a2a2a')
        mode_frame.pack(pady=5)

        tk.Label(mode_frame, text="Modo de pausa:", bg='#2a2a2a', fg='white').pack(side='left', padx=5)

        self.break_mode = tk.StringVar(value=self.bot.anti_detection['natural_breaks']['mode'])
        tk.Radiobutton(mode_frame, text="Por Tempo", variable=self.break_mode, value='time',
                      bg='#2a2a2a', fg='white', selectcolor='#2a2a2a',
                      command=self.update_anti_detection_settings).pack(side='left', padx=5)
        tk.Radiobutton(mode_frame, text="Por Pescas", variable=self.break_mode, value='catches',
                      bg='#2a2a2a', fg='white', selectcolor='#2a2a2a',
                      command=self.update_anti_detection_settings).pack(side='left', padx=5)

        # Intervalo de tempo
        tk.Label(breaks_frame, text="Intervalo de tempo (minutos):", bg='#2a2a2a', fg='white').pack()
        self.break_time_interval = tk.Scale(breaks_frame, from_=10, to=120, orient='horizontal',
                                           bg='#2a2a2a', fg='white', highlightthickness=0,
                                           command=lambda v: self.update_anti_detection_settings())
        self.break_time_interval.set(self.bot.anti_detection['natural_breaks']['time_interval'])
        self.break_time_interval.pack(pady=5)

        # Intervalo de pescas
        tk.Label(breaks_frame, text="Intervalo de pescas:", bg='#2a2a2a', fg='white').pack()
        self.break_catches_interval = tk.Scale(breaks_frame, from_=20, to=100, orient='horizontal',
                                              bg='#2a2a2a', fg='white', highlightthickness=0,
                                              command=lambda v: self.update_anti_detection_settings())
        self.break_catches_interval.set(self.bot.anti_detection['natural_breaks']['catches_interval'])
        self.break_catches_interval.pack(pady=5)

        # Dura√ß√£o da pausa
        tk.Label(breaks_frame, text="Dura√ß√£o m√≠nima da pausa (minutos):", bg='#2a2a2a', fg='white').pack()
        self.break_duration_min = tk.Scale(breaks_frame, from_=1, to=10, resolution=0.5, orient='horizontal',
                                          bg='#2a2a2a', fg='white', highlightthickness=0,
                                          command=lambda v: self.update_anti_detection_settings())
        # Converter segundos para minutos na interface
        current_min_seconds = self.bot.anti_detection['natural_breaks']['pause_duration_min']
        self.break_duration_min.set(current_min_seconds / 60.0)
        self.break_duration_min.pack(pady=5)

        tk.Label(breaks_frame, text="Dura√ß√£o m√°xima da pausa (minutos):", bg='#2a2a2a', fg='white').pack()
        self.break_duration_max = tk.Scale(breaks_frame, from_=1, to=15, resolution=0.5, orient='horizontal',
                                          bg='#2a2a2a', fg='white', highlightthickness=0,
                                          command=lambda v: self.update_anti_detection_settings())
        # Converter segundos para minutos na interface
        current_max_seconds = self.bot.anti_detection['natural_breaks']['pause_duration_max']
        self.break_duration_max.set(current_max_seconds / 60.0)
        self.break_duration_max.pack(pady=5)

        # ========== MICRO PAUSAS REMOVIDAS ==========
        # Micro pausas aleat√≥rias foram removidas para melhor performance

        # ========== CONFIGURA√á√ÉO DE PRIORIDADE DE ISCAS ==========
        bait_frame = tk.LabelFrame(scrollable_frame, text="üé£ Prioridade de Iscas",
                                  bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        bait_frame.pack(fill='x', padx=20, pady=10)

        # Inicializar configura√ß√£o padr√£o se n√£o existir
        if not hasattr(self.bot, 'bait_priority'):
            self.bot.bait_priority = {
                'carne de urso': 1,
                'carne de lobo': 2,
                'trout': 3,
                'grub': 4,
                'worm': 5
            }

        # Inicializar lista de iscas habilitadas
        if not hasattr(self.bot, 'bait_enabled'):
            self.bot.bait_enabled = {
                'carne de urso': True,
                'carne de lobo': True,
                'trout': True,
                'grub': True,
                'worm': True
            }

        tk.Label(bait_frame, text="üîÑ Arraste as iscas para reordenar prioridade | ‚úÖ Use checkbox para ativar/desativar:",
                bg='#2a2a2a', fg='#ffaa00', font=('Arial', 10, 'bold')).pack(pady=10)

        # Frame para a lista reorden√°vel
        list_frame = tk.Frame(bait_frame, bg='#2a2a2a')
        list_frame.pack(fill='both', expand=True, padx=20, pady=10)

        # Listbox customizada para drag & drop
        self.bait_listbox = tk.Listbox(list_frame,
                                      bg='#3a3a3a', fg='white',
                                      selectbackground='#4a4a4a',
                                      font=('Arial', 11),
                                      height=6)
        self.bait_listbox.pack(side='left', fill='both', expand=True)

        # Frame para controles de cada isca
        controls_frame = tk.Frame(list_frame, bg='#2a2a2a')
        controls_frame.pack(side='right', fill='y', padx=(10, 0))

        # Vari√°veis para checkboxes e prioridades
        self.bait_enabled_vars = {}
        self.bait_priority_vars = {}

        # Criar lista ordenada por prioridade atual
        self.bait_names = ['carne de urso', 'carne de lobo', 'trout', 'grub', 'worm']
        self.ordered_baits = sorted(self.bait_names,
                                   key=lambda x: self.bot.bait_priority.get(x, 999))

        # Inicializar vari√°veis de prioridade
        for bait in self.bait_names:
            self.bait_priority_vars[bait] = tk.StringVar(
                value=str(self.bot.bait_priority.get(bait, 1)))

        # Atualizar listbox e criar checkboxes
        self.update_bait_listbox()

        # Bot√µes de movimento
        btn_frame = tk.Frame(controls_frame, bg='#2a2a2a')
        btn_frame.pack(pady=5)

        tk.Button(btn_frame, text="üî∫", command=self.move_bait_up,
                 bg='#4a4a4a', fg='white', width=3).pack(pady=2)
        tk.Button(btn_frame, text="üîª", command=self.move_bait_down,
                 bg='#4a4a4a', fg='white', width=3).pack(pady=2)

        # Checkboxes para habilitar/desabilitar
        tk.Label(controls_frame, text="Usar:", bg='#2a2a2a', fg='white',
                font=('Arial', 9, 'bold')).pack(pady=(10,5))

        for bait in self.ordered_baits:
            self.bait_enabled_vars[bait] = tk.BooleanVar(
                value=self.bot.bait_enabled.get(bait, True))
            cb = tk.Checkbutton(controls_frame, text=bait,
                               variable=self.bait_enabled_vars[bait],
                               bg='#2a2a2a', fg='white',
                               selectcolor='#4a4a4a',
                               activebackground='#2a2a2a',
                               activeforeground='white',
                               command=self.update_bait_enabled)
            cb.pack(anchor='w', pady=1)

        # Frame para reset
        reset_frame = tk.Frame(bait_frame, bg='#2a2a2a')
        reset_frame.pack(pady=10)

        reset_btn = tk.Button(reset_frame, text="üîÑ Restaurar Padr√£o",
                             command=self.reset_bait_priorities,
                             bg='#6c757d', fg='white', font=('Arial', 9),
                             padx=10, pady=5)
        reset_btn.pack(side='left', padx=5)

        # Bot√£o para salvar configura√ß√µes
        save_btn = tk.Button(scrollable_frame, text="üíæ Salvar Configura√ß√µes Anti-Detec√ß√£o",
                           command=self.save_anti_detection_config,
                           bg='#28a745', fg='white', font=('Arial', 10, 'bold'),
                           padx=20, pady=10)
        save_btn.pack(pady=20)

        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def toggle_anti_detection(self):
        """Ativar/desativar sistema anti-detec√ß√£o"""
        self.bot.anti_detection['enabled'] = self.anti_detection_enabled.get()
        status = "ATIVADO" if self.bot.anti_detection['enabled'] else "DESATIVADO"
        print(f"üõ°Ô∏è Sistema Anti-Detec√ß√£o {status}")

    def update_anti_detection_settings(self):
        """Atualizar configura√ß√µes de anti-detec√ß√£o em tempo real"""
        try:
            # Atualizar configura√ß√µes de cliques
            self.bot.anti_detection['click_variation']['enabled'] = self.click_variation_enabled.get()
            self.bot.anti_detection['click_variation']['min_delay'] = self.click_min_delay.get() / 1000
            self.bot.anti_detection['click_variation']['max_delay'] = self.click_max_delay.get() / 1000

            # Atualizar configura√ß√µes de movimentos
            self.bot.anti_detection['movement_variation']['enabled'] = self.movement_variation_enabled.get()
            self.bot.anti_detection['movement_variation']['a_duration_min'] = self.a_duration_min.get()
            self.bot.anti_detection['movement_variation']['a_duration_max'] = self.a_duration_max.get()
            self.bot.anti_detection['movement_variation']['d_duration_min'] = self.d_duration_min.get()
            self.bot.anti_detection['movement_variation']['d_duration_max'] = self.d_duration_max.get()

            # Atualizar pausas naturais
            self.bot.anti_detection['natural_breaks']['enabled'] = self.natural_breaks_enabled.get()
            self.bot.anti_detection['natural_breaks']['mode'] = self.break_mode.get()
            self.bot.anti_detection['natural_breaks']['time_interval'] = int(self.break_time_interval.get())
            self.bot.anti_detection['natural_breaks']['catches_interval'] = int(self.break_catches_interval.get())
            # Converter minutos para segundos
            self.bot.anti_detection['natural_breaks']['pause_duration_min'] = int(self.break_duration_min.get() * 60)
            self.bot.anti_detection['natural_breaks']['pause_duration_max'] = int(self.break_duration_max.get() * 60)

            # Micro pausas removidas para melhor performance

        except Exception as e:
            print(f"‚ùå Erro ao atualizar configura√ß√µes anti-detec√ß√£o: {e}")

    def update_bait_listbox(self):
        """Atualiza a listbox com a ordem atual das iscas"""
        try:
            self.bait_listbox.delete(0, tk.END)
            for i, bait in enumerate(self.ordered_baits):
                status = "‚úÖ" if self.bot.bait_enabled.get(bait, True) else "‚ùå"
                display_text = f"{i+1}. {status} {bait}"
                self.bait_listbox.insert(tk.END, display_text)
        except Exception as e:
            print(f"Erro ao atualizar listbox de iscas: {e}")

    def move_bait_up(self):
        """Move a isca selecionada para cima na prioridade"""
        try:
            selection = self.bait_listbox.curselection()
            if not selection or selection[0] == 0:
                return

            index = selection[0]
            # Trocar posi√ß√µes na lista ordenada
            self.ordered_baits[index], self.ordered_baits[index-1] = \
                self.ordered_baits[index-1], self.ordered_baits[index]

            # Atualizar prioridades no bot
            for i, bait in enumerate(self.ordered_baits):
                self.bot.bait_priority[bait] = i + 1

            # Atualizar interface
            self.update_bait_listbox()
            self.bait_listbox.selection_set(index-1)

        except Exception as e:
            print(f"Erro ao mover isca para cima: {e}")

    def move_bait_down(self):
        """Move a isca selecionada para baixo na prioridade"""
        try:
            selection = self.bait_listbox.curselection()
            if not selection or selection[0] >= len(self.ordered_baits) - 1:
                return

            index = selection[0]
            # Trocar posi√ß√µes na lista ordenada
            self.ordered_baits[index], self.ordered_baits[index+1] = \
                self.ordered_baits[index+1], self.ordered_baits[index]

            # Atualizar prioridades no bot
            for i, bait in enumerate(self.ordered_baits):
                self.bot.bait_priority[bait] = i + 1

            # Atualizar interface
            self.update_bait_listbox()
            self.bait_listbox.selection_set(index+1)

        except Exception as e:
            print(f"Erro ao mover isca para baixo: {e}")

    def update_bait_enabled(self):
        """Atualiza o estado de habilitado/desabilitado das iscas"""
        try:
            for bait, var in self.bait_enabled_vars.items():
                self.bot.bait_enabled[bait] = var.get()

            # Atualizar a visualiza√ß√£o da listbox
            self.update_bait_listbox()

        except Exception as e:
            print(f"Erro ao atualizar estado das iscas: {e}")

    def reset_bait_priorities(self):
        """Restaura as prioridades padr√£o das iscas"""
        try:
            # Restaurar prioridades padr√£o
            self.bot.bait_priority = {
                'carne de urso': 1,
                'carne de lobo': 2,
                'trout': 3,
                'grub': 4,
                'worm': 5
            }

            # Restaurar todas as iscas como habilitadas
            self.bot.bait_enabled = {
                'carne de urso': True,
                'carne de lobo': True,
                'trout': True,
                'grub': True,
                'worm': True
            }

            # Reordenar lista
            self.ordered_baits = sorted(self.bait_names,
                                       key=lambda x: self.bot.bait_priority.get(x, 999))

            # Atualizar checkboxes
            for bait, var in self.bait_enabled_vars.items():
                var.set(self.bot.bait_enabled.get(bait, True))

            # Atualizar interface
            self.update_bait_listbox()

            print("üîÑ Prioridades de isca restauradas para o padr√£o")

        except Exception as e:
            print(f"Erro ao restaurar prioridades: {e}")

    def save_bait_config(self):
        """Salva as configura√ß√µes de iscas no config.json"""
        try:
            # Carregar config atual
            import json
            config_path = 'config.json'
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
            except FileNotFoundError:
                config = {}

            # Atualizar configura√ß√µes de iscas
            config['bait_priority'] = self.bot.bait_priority
            config['bait_enabled'] = self.bot.bait_enabled

            # Salvar arquivo
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4, ensure_ascii=False)

            print("üíæ Configura√ß√µes de iscas salvas em config.json")

        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes de iscas: {e}")

    def save_anti_detection_config(self):
        """Salvar configura√ß√µes de anti-detec√ß√£o no arquivo"""
        try:
            self.update_anti_detection_settings()
            self.save_bait_config()  # Usar novo m√©todo de salvar iscas

            # Salvar no config.json
            with open('config.json', 'r', encoding='utf-8') as f:
                config = json.load(f)

            config['anti_detection'] = self.bot.anti_detection

            # Salvar prioridades de iscas
            if hasattr(self.bot, 'bait_priority'):
                config['bait_priority'] = self.bot.bait_priority

            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)

            print("‚úÖ Configura√ß√µes Anti-Detec√ß√£o e Prioridades de Iscas salvas com sucesso!")
            messagebox.showinfo("Sucesso", "Configura√ß√µes Anti-Detec√ß√£o e Prioridades de Iscas salvas!")

        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes: {e}")
            messagebox.showerror("Erro", f"Erro ao salvar: {e}")

    def update_bait_priorities(self):
        """Atualizar prioridades de iscas em tempo real"""
        try:
            # Verificar se j√° existe o atributo
            if not hasattr(self.bot, 'bait_priority'):
                self.bot.bait_priority = {}

            # Atualizar prioridades baseado nos valores da UI
            for bait, var in self.bait_priority_vars.items():
                try:
                    priority = int(var.get())
                    self.bot.bait_priority[bait] = priority
                except ValueError:
                    # Se valor inv√°lido, manter o atual
                    pass

            print(f"üé£ Prioridades de iscas atualizadas: {self.bot.bait_priority}")

        except Exception as e:
            print(f"‚ùå Erro ao atualizar prioridades de iscas: {e}")

    def reset_bait_priorities(self):
        """Restaurar prioridades de iscas para o padr√£o"""
        try:
            # Valores padr√£o
            default_priorities = {
                'carne de urso': 1,
                'carne de lobo': 2,
                'trout': 3,
                'grub': 4,
                'worm': 5
            }

            # Atualizar bot
            self.bot.bait_priority = default_priorities.copy()

            # Atualizar UI
            for bait, priority in default_priorities.items():
                if bait in self.bait_priority_vars:
                    self.bait_priority_vars[bait].set(str(priority))

            print("üîÑ Prioridades de iscas restauradas para o padr√£o")
            messagebox.showinfo("Sucesso", "Prioridades restauradas para o padr√£o!")

        except Exception as e:
            print(f"‚ùå Erro ao restaurar prioridades: {e}")
            messagebox.showerror("Erro", f"Erro ao restaurar prioridades: {e}")

    def start_bot(self):
        """Iniciar bot via interface"""
        if not self.bot.running:
            self.bot.start()
            print("üöÄ Bot iniciado via interface!")

    def pause_bot(self):
        """Pausar bot via interface"""
        print("[UI] Bot√£o pausar clicado!")
        if self.bot.running:
            self.bot.pause_bot()
            print("‚è∏Ô∏è Bot pausado via interface!")
        else:
            print("[WARN] Bot n√£o est√° rodando")

    def stop_bot(self):
        """Parar bot via interface"""
        print("[UI] Bot√£o parar clicado!")
        if self.bot.running:
            self.bot.stop()
            print("üõë Bot parado via interface!")
        else:
            print("[WARN] Bot n√£o est√° rodando")

    def save_config(self):
        """Salvar configura√ß√µes alteradas na interface"""
        try:
            # Atualizar configura√ß√µes do bot
            self.bot.config['cycle_timeout'] = int(self.cycle_timeout_var.get())
            self.bot.config['chest_side'] = self.chest_side_var.get()
            self.bot.config['macro_type'] = self.macro_type_var.get()
            # Usar auto_clean_interval_var para consist√™ncia
            self.bot.config['loot_interval'] = int(self.auto_clean_interval_var.get())
            self.bot.config['auto_clean_interval'] = int(self.auto_clean_interval_var.get())
            self.bot.config['auto_reload'] = self.auto_reload_var.get()
            self.bot.config['pair_switch_limit'] = int(self.pair_switch_var.get())
            self.bot.config['chest_distance'] = int(self.chest_distance_var.get())
            self.bot.config['clicks_per_second'] = int(self.clicks_per_second_var.get())
            self.bot.config['broken_rod_action'] = self.broken_rod_action_var.get()
            
            # Atualizar threshold de timeout para manuten√ß√£o
            timeout_threshold = int(self.timeout_threshold_var.get())
            self.bot.rod_system['timeout_threshold'] = timeout_threshold
            self.bot.config['timeout_threshold'] = timeout_threshold

            # Salvar no arquivo config.json
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(self.bot.config, f, indent=2, ensure_ascii=False)

            print("‚úÖ Configura√ß√µes salvas com sucesso!")
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas com sucesso!")

        except ValueError as e:
            print(f"‚ùå Erro nos valores das configura√ß√µes: {e}")
            messagebox.showerror("Erro", f"Erro nos valores das configura√ß√µes: {e}")
        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes: {e}")
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")

    def save_config_silent(self):
        """Salvar configura√ß√µes alteradas na interface SEM mostrar pop-ups"""
        try:
            # Atualizar configura√ß√µes do bot
            self.bot.config['cycle_timeout'] = int(self.cycle_timeout_var.get())
            self.bot.config['chest_side'] = self.chest_side_var.get()
            self.bot.config['macro_type'] = self.macro_type_var.get()
            # Usar auto_clean_interval_var para consist√™ncia
            self.bot.config['loot_interval'] = int(self.auto_clean_interval_var.get())
            self.bot.config['auto_clean_interval'] = int(self.auto_clean_interval_var.get())
            self.bot.config['auto_reload'] = self.auto_reload_var.get()
            self.bot.config['pair_switch_limit'] = int(self.pair_switch_var.get())
            self.bot.config['chest_distance'] = int(self.chest_distance_var.get())
            self.bot.config['clicks_per_second'] = int(self.clicks_per_second_var.get())
            
            # Atualizar threshold de timeout para manuten√ß√£o (save_config_silent)
            if hasattr(self, 'timeout_threshold_var'):
                timeout_threshold = int(self.timeout_threshold_var.get())
                self.bot.rod_system['timeout_threshold'] = timeout_threshold
                self.bot.config['timeout_threshold'] = timeout_threshold

            # Adicionar configura√ß√µes estruturadas de auto_clean
            if hasattr(self, 'auto_clean_enabled_var'):
                self.bot.config['auto_clean'] = {
                    'enabled': self.auto_clean_enabled_var.get(),
                    'interval': int(self.auto_clean_interval_var.get())
                }

            # Salvar no arquivo config.json
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(self.bot.config, f, indent=2, ensure_ascii=False)

            # Apenas log, sem pop-up
            print("üîÑ Configura√ß√µes atualizadas automaticamente")

        except ValueError as e:
            print(f"‚ùå Erro nos valores das configura√ß√µes: {e}")
        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes: {e}")

    def set_default_confidence(self):
        """Aplicar confian√ßa padr√£o (0.5) para todas as classes"""
        for class_name in self.yolo_classes:
            if class_name in self.confidence_vars:
                self.confidence_vars[class_name].set(0.5)
        print("üìä Confian√ßa padr√£o (0.5) aplicada para todas as classes!")

    def set_high_confidence(self):
        """Aplicar alta confian√ßa (0.8) para todas as classes"""
        for class_name in self.yolo_classes:
            if class_name in self.confidence_vars:
                self.confidence_vars[class_name].set(0.8)
        print("üéØ Alta confian√ßa (0.8) aplicada para todas as classes!")

    def save_confidence_config(self):
        """Salvar configura√ß√µes de confian√ßa por classe"""
        try:
            # Criar dicion√°rio de confian√ßa por classe
            class_confidence = {}
            for class_name, var in self.confidence_vars.items():
                class_confidence[class_name] = round(var.get(), 2)

            # Atualizar configura√ß√£o do bot
            self.bot.config['class_confidence'] = class_confidence

            # Salvar no arquivo config.json
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(self.bot.config, f, indent=2, ensure_ascii=False)

            print("‚úÖ Configura√ß√µes de confian√ßa salvas com sucesso!")
            messagebox.showinfo("Sucesso",
                              f"Configura√ß√µes de confian√ßa salvas para {len(self.yolo_classes)} classes!")

        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes de confian√ßa: {e}")
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes de confian√ßa: {e}")

    def update_stats(self):
        """Atualizar estat√≠sticas na interface"""
        if self.is_destroyed:
            return

        try:
            # Atualizar status
            if self.bot.running:
                if self.bot.paused:
                    self.status_label.config(text="‚è∏Ô∏è Pausado", fg="#ffc107")
                else:
                    self.status_label.config(text="üü¢ Executando", fg="#28a745")
            else:
                self.status_label.config(text="‚ö´ Parado", fg="#dc3545")

            # Atualizar stats
            uptime = int(time.time() - self.bot.start_time) if hasattr(self.bot, 'start_time') and self.bot.start_time else 0
            stats_text = f"Ciclos: {self.bot.ciclos_completados} | Peixes: {self.bot.peixes_capturados} | Uptime: {uptime}s"
            self.stats_label.config(text=stats_text)

            # Atualizar status de alimenta√ß√£o se a aba existe
            if hasattr(self, 'feeding_status_label'):
                current_slot = self.bot.alimentacao['current_slot']
                slot1_uses = self.bot.alimentacao['slot1_uses']
                slot2_uses = self.bot.alimentacao['slot2_uses']
                max_uses = self.bot.alimentacao['max_uses_per_slot']

                feeding_text = f"Slot Atual: {current_slot} | Slot1: {slot1_uses}/{max_uses} | Slot2: {slot2_uses}/{max_uses}"

                # Adicionar informa√ß√µes de triggers
                last_feed = self.bot.alimentacao['last_feed_time']
                if last_feed > 0:
                    time_since = int(time.time() - last_feed)
                    feeding_text += f"\n√öltima alimenta√ß√£o: {time_since}s atr√°s"
                else:
                    feeding_text += f"\nNunca alimentou"

                self.feeding_status_label.config(text=feeding_text)

            # Atualizar status de limpeza autom√°tica se existe
            if hasattr(self, 'auto_clean_status_label') and hasattr(self, 'auto_clean_enabled_var'):
                if self.auto_clean_enabled_var.get():
                    interval = int(self.auto_clean_interval_var.get())
                    current = self.bot.auto_clean['fish_count_since_last']
                    remaining = interval - current

                    if remaining <= 0:
                        status_text = "üîÑ Limpeza autom√°tica pendente!"
                        color = "#ffc107"
                    else:
                        status_text = f"üìä Pr√≥xima limpeza em: {remaining} pescas"
                        color = "#28a745"

                    self.auto_clean_status_label.config(text=status_text, fg=color)

                    # Atualizar configura√ß√£o do bot
                    self.bot.auto_clean['enabled'] = True
                    self.bot.auto_clean['interval'] = interval
                else:
                    self.auto_clean_status_label.config(text="‚ùå Limpeza autom√°tica desativada", fg="#dc3545")
                    self.bot.auto_clean['enabled'] = False

            # Reagendar pr√≥xima atualiza√ß√£o
            self.main_window.after(1000, self.update_stats)

        except Exception:
            # Silenciar erros para n√£o crashar
            pass

    def create_language_tab(self):
        """Criar aba de sele√ß√£o de idioma"""
        from i18n import i18n, _

        language_frame = tk.Frame(self.notebook, bg='#1a1a1a')
        self.notebook.add(language_frame, text=_('language_tab'))

        # T√≠tulo
        title_label = tk.Label(language_frame,
                              text=_('language_selection'),
                              font=('Arial', 14, 'bold'),
                              fg='#ffaa00', bg='#1a1a1a')
        title_label.pack(pady=15)

        # Frame principal com scroll
        canvas = tk.Canvas(language_frame, bg='#1a1a1a', highlightthickness=0)
        scrollbar = tk.Scrollbar(language_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#1a1a1a')

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # ========== SELE√á√ÉO DE IDIOMA ==========
        lang_frame = tk.LabelFrame(scrollable_frame, text=_('current_language'),
                                   bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        lang_frame.pack(fill='x', padx=20, pady=10)

        # Mostrar idioma atual
        current_lang_label = tk.Label(lang_frame,
                                      text=f"{_('current_language')}: {i18n.get_language_name()}",
                                      font=('Arial', 11),
                                      fg='#00ff00', bg='#2a2a2a')
        current_lang_label.pack(pady=10)

        # Variable para o idioma selecionado
        self.selected_language = tk.StringVar(value=i18n.current_language)

        # Radio buttons para idiomas dispon√≠veis
        languages = {'pt': 'Portugu√™s (Brasil)', 'en': 'English (US)'}  # Apenas idiomas implementados
        for lang_code, lang_name in languages.items():
                radio = tk.Radiobutton(lang_frame,
                                       text=lang_name,
                                       variable=self.selected_language,
                                       value=lang_code,
                                       bg='#2a2a2a', fg='white',
                                       selectcolor='#2a2a2a',
                                       font=('Arial', 10),
                                       command=self.on_language_change)
                radio.pack(anchor='w', padx=20, pady=5)

        # ========== DETEC√á√ÉO AUTOM√ÅTICA ==========
        auto_frame = tk.LabelFrame(scrollable_frame, text=_('auto_detect'),
                                   bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold'))
        auto_frame.pack(fill='x', padx=20, pady=10)

        # Mostrar idioma do sistema
        system_lang_label = tk.Label(auto_frame,
                                      text=f"{_('system_language')}: {i18n.get_language_name(i18n.system_language)}",
                                      font=('Arial', 10),
                                      fg='#cccccc', bg='#2a2a2a')
        system_lang_label.pack(pady=5)

        # Bot√£o para detectar automaticamente
        auto_detect_btn = tk.Button(auto_frame,
                                    text=_('auto_detect'),
                                    command=self.auto_detect_language,
                                    bg='#17a2b8', fg='white',
                                    font=('Arial', 10, 'bold'),
                                    padx=10, pady=5)
        auto_detect_btn.pack(pady=10)

        # ========== APLICAR MUDAN√áAS ==========
        apply_frame = tk.Frame(scrollable_frame, bg='#1a1a1a')
        apply_frame.pack(fill='x', padx=20, pady=20)

        # Bot√£o aplicar
        apply_btn = tk.Button(apply_frame,
                              text=_('apply_language'),
                              command=self.apply_language_change,
                              bg='#28a745', fg='white',
                              font=('Arial', 12, 'bold'),
                              padx=20, pady=10)
        apply_btn.pack(pady=10)

        # Status label
        self.language_status_label = tk.Label(apply_frame,
                                              text="",
                                              font=('Arial', 9),
                                              fg='#ffc107', bg='#1a1a1a')
        self.language_status_label.pack(pady=5)

        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y", pady=10)

    def on_language_change(self):
        """Callback quando idioma √© alterado"""
        from i18n import _
        selected_lang = self.selected_language.get()
        self.language_status_label.config(
            text=f"{_('restart_required')}",
            fg='#ffc107'
        )

    def auto_detect_language(self):
        """Detectar idioma do sistema automaticamente"""
        from i18n import i18n, _
        self.selected_language.set(i18n.system_language)
        self.language_status_label.config(
            text=f"{_('system_language')}: {i18n.get_language_name(i18n.system_language)}",
            fg='#17a2b8'
        )

    def apply_language_change(self):
        """üåç Aplicar mudan√ßa de idioma EM TEMPO REAL - SEM RESTART"""
        from i18n import i18n, _

        try:
            selected_lang = self.selected_language.get()
            print(f"üîç DEBUG: Idioma selecionado: {selected_lang}")
            print(f"üîç DEBUG: Idioma atual antes da mudan√ßa: {i18n.current_language}")

            if selected_lang == i18n.current_language:
                print("‚ö†Ô∏è DEBUG: Idioma selecionado √© o mesmo que o atual")
                self.language_status_label.config(
                    text=f"Current Language: {i18n.get_language_name()}",
                    fg='#28a745'
                )
                return

            print(f"üåç DEBUG: Alterando idioma de {i18n.current_language} para {selected_lang}")

            # ALTERAR IDIOMA DIRETAMENTE SEM RELOAD
            print("üîç DEBUG: Chamando i18n.set_language()...")
            success = i18n.set_language(selected_lang)
            
            if not success:
                print(f"‚ùå DEBUG: Falha ao alterar idioma para {selected_lang}")
                return
                
            print(f"üîç DEBUG: Idioma atual ap√≥s set_language: {i18n.current_language}")
            
            # Salvar prefer√™ncia
            print("üîç DEBUG: Salvando prefer√™ncia...")
            i18n.save_language_preference()

            # ATUALIZAR INTERFACE SEM RELOAD DO M√ìDULO
            print("üîç DEBUG: Chamando update_interface_language()...")
            self.update_interface_language()

            # Recriar a fun√ß√£o _ com o novo idioma
            from i18n import _
            
            # Testar se a tradu√ß√£o est√° funcionando
            test_translation = _('bot_status')
            print(f"üîç DEBUG: Teste de tradu√ß√£o 'bot_status': '{test_translation}'")

            self.language_status_label.config(
                text=f"‚úÖ Success - Current Language: {i18n.get_language_name()}",
                fg='#28a745'
            )

            # Mostrar confirma√ß√£o
            messagebox.showinfo(
                "Success",
                f"üåç Language changed to: {i18n.get_language_name()}\n"
                f"‚úÖ Interface updated successfully!"
            )
            
            print("‚úÖ DEBUG: Mudan√ßa de idioma conclu√≠da com sucesso!")

        except Exception as e:
            print(f"‚ùå DEBUG: Erro ao aplicar mudan√ßa de idioma: {e}")
            import traceback
            traceback.print_exc()
            self.language_status_label.config(
                text=f"‚ùå Error: {str(e)}",
                fg='#dc3545'
            )

    def update_interface_language(self):
        """üîÑ Atualizar TODOS os textos da interface para novo idioma"""
        from i18n import i18n, _

        try:
            print(f"üîÑ DEBUG: Iniciando atualiza√ß√£o da interface para idioma: {i18n.current_language}")

            # üè∑Ô∏è ATUALIZAR T√çTULOS DAS ABAS
            if hasattr(self, 'notebook'):
                print("üîç DEBUG: Atualizando t√≠tulos das abas...")
                tab_count = self.notebook.index("end")
                print(f"üîç DEBUG: Total de abas encontradas: {tab_count}")
                
                for i in range(tab_count):
                    current_text = self.notebook.tab(i, "text")
                    print(f"üîç DEBUG: Aba {i}: '{current_text}'")
                    
                    if "Controle" in current_text or "Control" in current_text:
                        new_text = f"üéÆ {_('control_tab')}"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba Controle atualizada para: '{new_text}'")
                    elif "Configura√ß√£o" in current_text or "Configuration" in current_text or "Settings" in current_text:
                        new_text = f"‚öôÔ∏è {_('config_tab')}"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba Configura√ß√£o atualizada para: '{new_text}'")
                    elif "Alimenta√ß√£o" in current_text or "Feeding" in current_text:
                        new_text = f"üçñ {_('feeding_tab')}"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba Alimenta√ß√£o atualizada para: '{new_text}'")
                    elif "Confian√ßa" in current_text or "Confidence" in current_text:
                        new_text = f"üéØ {_('confidence_tab')}"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba Confian√ßa atualizada para: '{new_text}'")
                    elif "CATCH" in current_text or "Viewer" in current_text:
                        new_text = "üêü CATCH Viewer"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba CATCH Viewer mantida: '{new_text}'")
                    elif "Anti" in current_text or "Detection" in current_text:
                        new_text = f"üõ°Ô∏è {_('anti_detection_tab')}"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba Anti-Detec√ß√£o atualizada para: '{new_text}'")
                    elif "Idioma" in current_text or "Language" in current_text:
                        new_text = f"üåç {_('language_tab')}"
                        self.notebook.tab(i, text=new_text)
                        print(f"‚úÖ DEBUG: Aba Idioma atualizada para: '{new_text}'")
            else:
                print("‚ùå DEBUG: Notebook n√£o encontrado")

            # üîÑ ATUALIZAR TODOS OS WIDGETS TRADUZ√çVEIS AUTOMATICAMENTE
            print("üîç DEBUG: Atualizando widgets traduz√≠veis...")
            self.update_all_translatable_widgets()
            
            # üîÑ ATUALIZAR ELEMENTOS ESPEC√çFICOS
            print("üîç DEBUG: Atualizando abas espec√≠ficas...")
            self.update_control_tab_language()
            self.update_config_tab_language()
            self.update_feeding_tab_language()
            self.update_confidence_tab_language()
            self.update_anti_detection_tab_language()

            # üè∑Ô∏è ATUALIZAR T√çTULO DA JANELA
            if hasattr(self, 'main_window'):
                new_title = f"üé£ {_('bot_title')}"
                self.main_window.title(new_title)
                print(f"‚úÖ DEBUG: T√≠tulo da janela atualizado para: '{new_title}'")

            print(f"‚úÖ DEBUG: Interface COMPLETA atualizada para: {i18n.get_language_name()}")

        except Exception as e:
            print(f"‚ùå DEBUG: Erro ao atualizar interface: {e}")
            import traceback
            traceback.print_exc()

    def update_control_tab_language(self):
        """üéÆ Atualizar textos da aba Controle"""
        from i18n import _
        try:
            # Buscar e atualizar TODOS os widgets da aba de controle
            if hasattr(self, 'notebook'):
                control_tab = None
                for i in range(self.notebook.index("end")):
                    tab_text = self.notebook.tab(i, "text")
                    if "Controle" in tab_text or "Control" in tab_text:
                        control_tab = self.notebook.nametowidget(self.notebook.tabs()[i])
                        break
                
                if control_tab:
                    self.update_widgets_recursively(control_tab, _)

            # Status do Bot espec√≠fico
            if hasattr(self, 'status_label'):
                current_status = self.status_label.cget('text')
                if "‚ö´" in current_status:
                    self.status_label.config(text=f"‚ö´ {_('inactive')}")
                elif "üü¢" in current_status:
                    self.status_label.config(text=f"üü¢ {_('active')}")
                elif "‚è∏Ô∏è" in current_status:
                    self.status_label.config(text=f"‚è∏Ô∏è {_('paused')}")

            # Bot√µes principais
            if hasattr(self, 'start_button'):
                self.start_button.config(text=f"üöÄ {_('start')}")
            if hasattr(self, 'stop_button'):
                self.stop_button.config(text=f"üõë {_('stop')}")
            if hasattr(self, 'pause_button'):
                self.pause_button.config(text=f"‚è∏Ô∏è {_('pause')}")

        except Exception as e:
            print(f"‚ùå Erro ao atualizar aba Controle: {e}")

    def update_widgets_recursively(self, parent_widget, _):
        """üîÑ Atualizar todos os widgets filhos recursivamente usando chaves de tradu√ß√£o"""
        try:
            from i18n import i18n
            print(f"üîç DEBUG: Atualizando widgets para idioma: {i18n.current_language}")
            
            # Testar tradu√ß√£o diretamente
            test_translation = _('bot_status')
            print(f"üîç DEBUG: Teste de tradu√ß√£o 'bot_status': '{test_translation}'")
            
            # Dicion√°rio de identifica√ß√£o de widgets por texto conhecido
            widget_translations = {
                # Textos que devem ser traduzidos para as chaves espec√≠ficas
                ('Status do Bot', 'Bot Status'): ('bot_status', 'üìä'),
                ('Estat√≠sticas', 'Statistics'): ('statistics', 'üìà'),
                ('Limpeza Autom√°tica', 'Auto Clean'): ('auto_clean', 'üßπ'),
                ('Limpar invent√°rio a cada', 'Clean inventory every'): ('clean_inventory_every', ''),
                ('pescas', 'catches'): ('catches', ''),
                ('Salvar Configura√ß√µes', 'Save Settings'): ('save_settings', 'üíæ'),
                ('Modo de Alimenta√ß√£o', 'Feeding Mode'): ('feeding_mode', 'üçñ'),
                ('Status Atual', 'Current Status'): ('current_status', ''),
                ('Triggers de Alimenta√ß√£o', 'Feeding Triggers'): ('feeding_triggers', '‚ö°'),
                ('Modo de Trigger', 'Trigger Mode'): ('trigger_mode', ''),
                ('Timeout do Ciclo (s)', 'Cycle Timeout (s)'): ('timeout_cycle', '‚è±Ô∏è'),
                ('Lado do Ba√∫', 'Chest Side'): ('chest_side', 'üì¶'),
                ('Tipo Macro', 'Macro Type'): ('macro_type', '‚öôÔ∏è'),
                ('Limite Troca Par', 'Pair Switch Limit'): ('pair_switch_limit', 'üîÑ'),
                ('Dist√¢ncia Ba√∫ (px)', 'Chest Distance (px)'): ('chest_distance', 'üìè'),
                
                # Mais elementos da interface
                ('Configura√ß√µes', 'Settings'): ('settings', '‚öôÔ∏è'),
                ('Controle', 'Control'): ('control_tab', 'üéÆ'),
                ('Alimenta√ß√£o', 'Feeding'): ('feeding_tab', 'üçñ'),
                ('Confian√ßa', 'Confidence'): ('confidence_tab', 'üéØ'),
                ('Anti-Detec√ß√£o', 'Anti-Detection'): ('anti_detection_tab', 'üõ°Ô∏è'),
                ('Idioma', 'Language'): ('language_tab', 'üåç'),
                
                # Bot√µes e a√ß√µes
                ('Iniciar', 'Start'): ('start', 'üöÄ'),
                ('Parar', 'Stop'): ('stop', 'üõë'),
                ('Pausar', 'Pause'): ('pause', '‚è∏Ô∏è'),
                ('Continuar', 'Resume'): ('resume', '‚ñ∂Ô∏è'),
                
                # Status
                ('Ativo', 'Active'): ('active', ''),
                ('Inativo', 'Inactive'): ('inactive', ''),
                ('Pausado', 'Paused'): ('paused', ''),
                ('Pronto', 'Ready'): ('ready', ''),
                ('Carregando', 'Loading'): ('loading', ''),
                
                # Sistema de alimenta√ß√£o
                ('Sistema de Alimenta√ß√£o', 'Feeding System'): ('feeding_system', 'üçñ'),
                ('Slots Fixos', 'Fixed Slots'): ('feeding_mode_fixed', ''),
                ('Detec√ß√£o Autom√°tica', 'Auto Detection'): ('feeding_mode_auto', ''),
                ('Trigger por Tempo', 'Time Trigger'): ('feeding_trigger_time', ''),
                ('Trigger por Pescas', 'Catch Trigger'): ('feeding_trigger_catches', ''),
            }
            
            # Percorrer todos os widgets filhos
            for child in parent_widget.winfo_children():
                try:
                    # Atualizar LabelFrame
                    if isinstance(child, tk.LabelFrame):
                        current_text = child.cget('text')
                        clean_text = self.clean_text_for_comparison(current_text)
                        
                        for text_variations, (translation_key, emoji) in widget_translations.items():
                            if clean_text in text_variations:
                                new_text = f"{emoji} {_(translation_key)}".strip() if emoji else _(translation_key)
                                child.config(text=new_text)
                                print(f"‚úÖ DEBUG: LabelFrame atualizado: '{current_text}' -> '{new_text}'")
                                break
                    
                    # Atualizar Label
                    elif isinstance(child, tk.Label):
                        current_text = child.cget('text')
                        clean_text = self.clean_text_for_comparison(current_text)
                        
                        for text_variations, (translation_key, emoji) in widget_translations.items():
                            if clean_text in text_variations:
                                new_text = f"{emoji} {_(translation_key)}".strip() if emoji else _(translation_key)
                                child.config(text=new_text)
                                print(f"‚úÖ DEBUG: Label atualizado: '{current_text}' -> '{new_text}'")
                                break
                    
                    # Atualizar Button
                    elif isinstance(child, tk.Button):
                        current_text = child.cget('text')
                        clean_text = self.clean_text_for_comparison(current_text)
                        
                        # Bot√µes espec√≠ficos
                        if clean_text in ('Salvar Configura√ß√µes', 'Save Settings'):
                            child.config(text=f"üíæ {_('save_settings')}")
                            print(f"‚úÖ DEBUG: Button atualizado: '{current_text}' -> 'üíæ {_('save_settings')}'")
                        elif clean_text in ('Iniciar', 'Start'):
                            child.config(text=f"üöÄ {_('start')}")
                        elif clean_text in ('Parar', 'Stop'):
                            child.config(text=f"üõë {_('stop')}")
                        elif clean_text in ('Pausar', 'Pause'):
                            child.config(text=f"‚è∏Ô∏è {_('pause')}")
                    
                    # Recurs√£o para widgets filhos
                    self.update_widgets_recursively(child, _)
                    
                except Exception as widget_error:
                    # Ignorar erros de widgets espec√≠ficos
                    continue
                    
        except Exception as e:
            print(f"‚ùå Erro na atualiza√ß√£o recursiva: {e}")
    
    def clean_text_for_comparison(self, text):
        """üßπ Limpar texto removendo emojis e espa√ßos extras para compara√ß√£o"""
        try:
            # Remover emojis e s√≠mbolos especiais
            clean = ''.join(c for c in text if not self.is_emoji(c) and ord(c) < 127 or c.isalpha() or c.isspace())
            return clean.strip()
        except:
            return text.strip()

    def is_emoji(self, char):
        """üîç Verificar se um caractere √© emoji"""
        try:
            return ord(char) > 0x1F600
        except:
            return False

    def update_config_tab_language(self):
        """‚öôÔ∏è Atualizar textos da aba Configura√ß√£o"""
        from i18n import _
        try:
            if hasattr(self, 'notebook'):
                for i in range(self.notebook.index("end")):
                    tab_text = self.notebook.tab(i, "text")
                    if "Configura√ß√£o" in tab_text or "Configuration" in tab_text or "Settings" in tab_text:
                        config_tab = self.notebook.nametowidget(self.notebook.tabs()[i])
                        self.update_widgets_recursively(config_tab, _)
                        break
        except Exception as e:
            print(f"‚ùå Erro ao atualizar aba Configura√ß√£o: {e}")

    def update_feeding_tab_language(self):
        """üçñ Atualizar textos da aba Alimenta√ß√£o"""
        from i18n import _
        try:
            if hasattr(self, 'notebook'):
                for i in range(self.notebook.index("end")):
                    tab_text = self.notebook.tab(i, "text")
                    if "Alimenta√ß√£o" in tab_text or "Feeding" in tab_text:
                        feeding_tab = self.notebook.nametowidget(self.notebook.tabs()[i])
                        self.update_widgets_recursively(feeding_tab, _)
                        break
        except Exception as e:
            print(f"‚ùå Erro ao atualizar aba Alimenta√ß√£o: {e}")

    def update_confidence_tab_language(self):
        """üéØ Atualizar textos da aba Confian√ßa"""
        from i18n import _
        try:
            if hasattr(self, 'notebook'):
                for i in range(self.notebook.index("end")):
                    tab_text = self.notebook.tab(i, "text")
                    if "Confian√ßa" in tab_text or "Confidence" in tab_text:
                        confidence_tab = self.notebook.nametowidget(self.notebook.tabs()[i])
                        self.update_widgets_recursively(confidence_tab, _)
                        break
        except Exception as e:
            print(f"‚ùå Erro ao atualizar aba Confian√ßa: {e}")

    def update_anti_detection_tab_language(self):
        """üõ°Ô∏è Atualizar textos da aba Anti-Detec√ß√£o"""
        from i18n import _
        try:
            if hasattr(self, 'notebook'):
                for i in range(self.notebook.index("end")):
                    tab_text = self.notebook.tab(i, "text")
                    if "Anti" in tab_text or "Detection" in tab_text:
                        anti_detection_tab = self.notebook.nametowidget(self.notebook.tabs()[i])
                        self.update_widgets_recursively(anti_detection_tab, _)
                        break
        except Exception as e:
            print(f"‚ùå Erro ao atualizar aba Anti-Detec√ß√£o: {e}")

    def register_translatable_widget(self, widget, widget_type, translation_key, widget_id=None):
        """üìù Registrar widget para tradu√ß√£o autom√°tica"""
        try:
            if widget_id is None:
                widget_id = f"{widget_type}_{len(self.translatable_widgets[widget_type])}"
            
            self.translatable_widgets[widget_type][widget_id] = {
                'widget': widget,
                'key': translation_key
            }
        except Exception as e:
            print(f"‚ùå Erro ao registrar widget traduz√≠vel: {e}")

    def update_all_translatable_widgets(self):
        """üîÑ Atualizar TODOS os widgets traduz√≠veis"""
        from i18n import _
        
        try:
            # Atualizar labels
            for widget_id, info in self.translatable_widgets['labels'].items():
                try:
                    widget = info['widget']
                    key = info['key']
                    if widget.winfo_exists():
                        widget.config(text=_(key))
                except:
                    pass

            # Atualizar bot√µes
            for widget_id, info in self.translatable_widgets['buttons'].items():
                try:
                    widget = info['widget']
                    key = info['key']
                    if widget.winfo_exists():
                        widget.config(text=_(key))
                except:
                    pass

            # Atualizar frames
            for widget_id, info in self.translatable_widgets['frames'].items():
                try:
                    widget = info['widget']
                    key = info['key']
                    if widget.winfo_exists():
                        widget.config(text=_(key))
                except:
                    pass

            # Atualizar checkboxes
            for widget_id, info in self.translatable_widgets['checkboxes'].items():
                try:
                    widget = info['widget']
                    key = info['key']
                    if widget.winfo_exists():
                        widget.config(text=_(key))
                except:
                    pass

            print("‚úÖ Todos os widgets traduz√≠veis foram atualizados")

        except Exception as e:
            print(f"‚ùå Erro ao atualizar widgets traduz√≠veis: {e}")

    def save_all_configs(self):
        """üîß M√âTODO CENTRALIZADO - Salvar todas as configura√ß√µes de uma vez"""
        try:
            # Carregar config atual para evitar sobrescrever outras configura√ß√µes
            current_config = {}
            try:
                with open('config.json', 'r', encoding='utf-8') as f:
                    current_config = json.load(f)
            except FileNotFoundError:
                pass

            # ‚öôÔ∏è Configura√ß√µes Gerais
            if hasattr(self, 'cycle_timeout_var'):
                current_config['cycle_timeout'] = int(self.cycle_timeout_var.get())
            if hasattr(self, 'chest_side_var'):
                current_config['chest_side'] = self.chest_side_var.get()
            if hasattr(self, 'macro_type_var'):
                current_config['macro_type'] = self.macro_type_var.get()
            # Usar auto_clean_interval_var para evitar duplicata
            if hasattr(self, 'auto_clean_interval_var'):
                current_config['loot_interval'] = int(self.auto_clean_interval_var.get())
            if hasattr(self, 'auto_reload_var'):
                current_config['auto_reload'] = self.auto_reload_var.get()
            if hasattr(self, 'pair_switch_var'):
                current_config['pair_switch_limit'] = int(self.pair_switch_var.get())
            if hasattr(self, 'chest_distance_var'):
                current_config['chest_distance'] = int(self.chest_distance_var.get())

            # üçñ Configura√ß√µes de Alimenta√ß√£o
            if hasattr(self, 'feeding_mode'):
                feeding_config = {}
                feeding_config['feeding_mode'] = self.feeding_mode.get()
                feeding_config['trigger_mode'] = getattr(self, 'feeding_trigger', tk.StringVar()).get()
                feeding_config['feeds_per_session'] = int(getattr(self, 'feeds_per_session_var', tk.StringVar(value="5")).get())
                feeding_config['trigger_minutes'] = int(getattr(self, 'trigger_minutes_var', tk.StringVar(value="10")).get())
                feeding_config['trigger_catches'] = int(getattr(self, 'trigger_catches_var', tk.StringVar(value="15")).get())

                # Salvar posi√ß√µes se foram definidas
                if hasattr(self.bot, 'alimentacao'):
                    feeding_config.update({
                        'slot1_position': self.bot.alimentacao['slot_positions'][1],
                        'slot2_position': self.bot.alimentacao['slot_positions'][2],
                        'eat_position': self.bot.alimentacao['eat_position'],
                        'max_uses_per_slot': self.bot.alimentacao['max_uses_per_slot']
                    })

                current_config['feeding'] = feeding_config

            # üéØ Configura√ß√µes de Confian√ßa
            if hasattr(self, 'confidence_vars'):
                class_confidence = {}
                for class_name, var in self.confidence_vars.items():
                    class_confidence[class_name] = round(var.get(), 2)
                current_config['class_confidence'] = class_confidence

            # üõ°Ô∏è Sistema Anti-Detec√ß√£o
            if hasattr(self, 'anti_detection_enabled'):
                current_config['anti_detection'] = self.bot.anti_detection.copy()

            # üßπ Limpeza Autom√°tica
            if hasattr(self, 'auto_clean_enabled_var'):
                current_config['auto_clean'] = {
                    'enabled': self.auto_clean_enabled_var.get(),
                    'interval': int(getattr(self, 'auto_clean_interval_var', tk.StringVar(value="10")).get())
                }

            # üé£ Prioridades de Isca
            if hasattr(self.bot, 'bait_priority'):
                current_config['bait_priority'] = self.bot.bait_priority.copy()

            # üåç Configura√ß√µes de Idioma (deixar para i18n.py gerenciar)
            # O sistema i18n j√° salva automaticamente em language_config.json

            # Salvar arquivo unificado
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(current_config, f, indent=2, ensure_ascii=False)

            # Atualizar config do bot
            self.bot.config = current_config

            print("‚úÖ TODAS as configura√ß√µes salvas com sucesso!")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes centralizadas: {e}")
            import traceback
            traceback.print_exc()
            return False

    def load_all_configs(self):
        """üîß M√âTODO CENTRALIZADO - Carregar todas as configura√ß√µes de uma vez"""
        try:
            with open('config.json', 'r', encoding='utf-8') as f:
                config = json.load(f)

            # ‚öôÔ∏è Configura√ß√µes Gerais
            if hasattr(self, 'cycle_timeout_var') and 'cycle_timeout' in config:
                self.cycle_timeout_var.set(config['cycle_timeout'])
            if hasattr(self, 'chest_side_var') and 'chest_side' in config:
                self.chest_side_var.set(config['chest_side'])
            if hasattr(self, 'macro_type_var') and 'macro_type' in config:
                self.macro_type_var.set(config['macro_type'])

            # üçñ Configura√ß√µes de Alimenta√ß√£o
            if 'feeding' in config:
                feeding = config['feeding']
                if hasattr(self, 'feeding_mode') and 'feeding_mode' in feeding:
                    self.feeding_mode.set(feeding['feeding_mode'])

            # üéØ Configura√ß√µes de Confian√ßa
            if 'class_confidence' in config and hasattr(self, 'confidence_vars'):
                for class_name, confidence in config['class_confidence'].items():
                    if class_name in self.confidence_vars:
                        self.confidence_vars[class_name].set(confidence)

            # üßπ Configura√ß√µes de Limpeza Autom√°tica
            if 'auto_clean' in config:
                auto_clean = config['auto_clean']
                if hasattr(self, 'auto_clean_enabled_var') and 'enabled' in auto_clean:
                    self.auto_clean_enabled_var.set(auto_clean['enabled'])
                if hasattr(self, 'auto_clean_interval_var') and 'interval' in auto_clean:
                    self.auto_clean_interval_var.set(str(auto_clean['interval']))
                print(f"üßπ Configura√ß√µes de limpeza autom√°tica carregadas: {auto_clean}")
            elif 'auto_clean_interval' in config:
                # Compatibilidade com formato antigo
                if hasattr(self, 'auto_clean_interval_var'):
                    self.auto_clean_interval_var.set(str(config['auto_clean_interval']))
                print(f"üßπ Intervalo de limpeza carregado (formato antigo): {config['auto_clean_interval']}")

            # ‚è±Ô∏è Configura√ß√£o de Threshold de Timeout para Manuten√ß√£o
            if hasattr(self, 'timeout_threshold_var') and 'timeout_threshold' in config:
                self.timeout_threshold_var.set(str(config['timeout_threshold']))
                self.bot.rod_system['timeout_threshold'] = config['timeout_threshold']
                print(f"‚è±Ô∏è Threshold de timeout carregado: {config['timeout_threshold']}")

            # Configura√ß√µes carregadas silenciosamente
            return True

        except FileNotFoundError:
            print("‚ö†Ô∏è Arquivo config.json n√£o encontrado - usando configura√ß√µes padr√£o")
            return False
        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes centralizadas: {e}")
            return False

    def on_auto_clean_interval_changed(self, *args):
        """Callback quando o intervalo de limpeza autom√°tica √© alterado"""
        try:
            new_interval = int(self.auto_clean_interval_var.get())
            
            # Valida√ß√£o: valor deve ser positivo e razo√°vel
            if new_interval <= 0:
                print("‚ö†Ô∏è Intervalo deve ser maior que 0")
                return
            if new_interval > 100:
                print("‚ö†Ô∏è Intervalo muito alto, m√°ximo recomendado: 100")
                # Permitir, mas avisar
            
            # Atualizar configura√ß√£o do bot imediatamente
            if hasattr(self, 'bot') and hasattr(self.bot, 'auto_clean'):
                self.bot.auto_clean['interval'] = new_interval
                print(f"üßπ Intervalo de limpeza atualizado para: {new_interval} pescas")
            
            # Salvar configura√ß√£o silenciosamente (sem pop-up)
            self.save_config_silent()
        except ValueError:
            # Valor inv√°lido (n√£o √© n√∫mero), ignorar silenciosamente
            pass
        except Exception as e:
            print(f"‚ùå Erro ao atualizar intervalo de limpeza: {e}")

    def on_auto_clean_enabled_changed(self, *args):
        """Callback quando a ativa√ß√£o de limpeza autom√°tica √© alterada"""
        try:
            new_enabled = self.auto_clean_enabled_var.get()
            # Atualizar configura√ß√£o do bot imediatamente
            if hasattr(self, 'bot') and hasattr(self.bot, 'auto_clean'):
                self.bot.auto_clean['enabled'] = new_enabled
                status = "ativada" if new_enabled else "desativada"
                print(f"üßπ Limpeza autom√°tica {status}")
            
            # Salvar configura√ß√£o silenciosamente
            self.save_config_silent()
        except Exception as e:
            print(f"‚ùå Erro ao atualizar ativa√ß√£o de limpeza: {e}")

    def save_auto_clean_config(self):
        """Salvar apenas as configura√ß√µes de limpeza autom√°tica"""
        try:
            # Carregar configura√ß√£o atual
            try:
                with open('config.json', 'r', encoding='utf-8') as f:
                    config = json.load(f)
            except:
                config = {}

            # Atualizar apenas configura√ß√µes de limpeza autom√°tica
            config['auto_clean'] = {
                'enabled': self.auto_clean_enabled_var.get(),
                'interval': int(self.auto_clean_interval_var.get())
            }
            
            # Para compatibilidade com c√≥digo antigo
            config['auto_clean_interval'] = int(self.auto_clean_interval_var.get())

            # Salvar no arquivo
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)

            # Atualizar bot imediatamente
            if hasattr(self, 'bot') and hasattr(self.bot, 'auto_clean'):
                self.bot.auto_clean['enabled'] = self.auto_clean_enabled_var.get()
                self.bot.auto_clean['interval'] = int(self.auto_clean_interval_var.get())

            print("‚úÖ Configura√ß√µes de limpeza autom√°tica salvas!")
            messagebox.showinfo("Sucesso", "Configura√ß√µes de limpeza autom√°tica salvas com sucesso!")

        except ValueError:
            messagebox.showerror("Erro", "Por favor, insira um n√∫mero v√°lido para o intervalo!")
        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes de limpeza: {e}")
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")

    def is_alive(self):
        """Verificar se a janela ainda est√° viva"""
        try:
            return not self.is_destroyed and self.main_window.winfo_exists()
        except:
            return False

# =============================================================================
# üîí DI√ÅLOGO DE LICENCIAMENTO
# =============================================================================
class LicenseDialog:
    def __init__(self, bot, parent=None):
        self.bot = bot
        self.result = None

        self.dialog = tk.Toplevel(parent) if parent else tk.Tk()
        self.dialog.title("üîê Ativa√ß√£o de Licen√ßa")
        self.dialog.geometry("500x300")
        self.dialog.configure(bg='#1a1a1a')
        self.dialog.resizable(False, False)

        # Centralizar janela
        self.dialog.transient(parent) if parent else None
        self.dialog.grab_set()

        self.create_dialog()

    def create_dialog(self):
        main_frame = tk.Frame(self.dialog, bg='#1a1a1a', padx=20, pady=20)
        main_frame.pack(fill='both', expand=True)

        # T√≠tulo
        title_label = tk.Label(main_frame,
                             text="üîê Ativa√ß√£o da Licen√ßa",
                             font=('Arial', 16, 'bold'),
                             fg='#00aaff',
                             bg='#1a1a1a')
        title_label.pack(pady=10)

        # Informa√ß√µes
        info_text = f"Hardware ID: {self.bot.license_manager.hardware_id[:16]}..."
        info_label = tk.Label(main_frame, text=info_text,
                            font=('Arial', 9),
                            fg='#cccccc',
                            bg='#1a1a1a')
        info_label.pack(pady=5)

        # Campo de entrada
        tk.Label(main_frame, text="Digite sua chave de ativa√ß√£o:",
                font=('Arial', 12),
                fg='white',
                bg='#1a1a1a').pack(pady=10)

        self.key_entry = tk.Entry(main_frame,
                                font=('Arial', 11),
                                width=40)
        self.key_entry.pack(pady=5)
        self.key_entry.focus()

        # Bot√µes
        button_frame = tk.Frame(main_frame, bg='#1a1a1a')
        button_frame.pack(pady=20)

        tk.Button(button_frame, text="‚úÖ Ativar",
                 command=self.activate_license,
                 bg='#28a745', fg='white',
                 font=('Arial', 11, 'bold'),
                 padx=20, pady=5).pack(side='left', padx=10)

        tk.Button(button_frame, text="‚ùå Cancelar",
                 command=self.cancel,
                 bg='#dc3545', fg='white',
                 font=('Arial', 11, 'bold'),
                 padx=20, pady=5).pack(side='left', padx=10)

        # Status
        self.status_label = tk.Label(main_frame,
                                   text="Digite sua chave de ativa√ß√£o acima",
                                   font=('Arial', 10),
                                   fg='#ffc107',
                                   bg='#1a1a1a')
        self.status_label.pack(pady=10)

        # Bind Enter
        self.key_entry.bind('<Return>', lambda e: self.activate_license())

    def activate_license(self):
        key = self.key_entry.get().strip()
        if not key:
            self.status_label.config(text="‚ùå Digite uma chave v√°lida", fg='#dc3545')
            return

        self.status_label.config(text="üîÑ Validando licen√ßa...", fg='#ffc107')
        self.dialog.update()

        # Tentar ativar
        success, message = self.bot.license_manager.activate(key)

        if success:
            self.status_label.config(text="‚úÖ Licen√ßa ativada com sucesso!", fg='#28a745')
            self.result = key
            self.dialog.after(1500, self.dialog.destroy)
        else:
            self.status_label.config(text=f"‚ùå {message}", fg='#dc3545')

    def cancel(self):
        self.result = None
        self.dialog.destroy()

    def show(self):
        self.dialog.wait_window()
        return self.result

# =============================================================================
# üéÆ CLASSE PRINCIPAL DO BOT DE PESCA
# =============================================================================
class FishingBot:
    def __init__(self):
        self.running = False
        self.paused = False
        self.timeout_segundos = 45
        self.ciclos_completados = 0
        self.peixes_capturados = 0
        self.start_time = None

        # Sistema de Estado Global - CR√çTICO PARA SINCRONIA COM THREAD SAFETY
        self._state_lock = threading.RLock()  # Lock para proteger estados
        self.game_state = {
            'inventory_open': False,
            'chest_open': False,
            'fishing_active': False,
            'right_mouse_down': False,
            'last_tab_press': 0,
            'last_action_time': 0,
            'action_in_progress': False,
            'feeding_active': False,
            'chest_detection_active': False,
            'loot_detection_active': False,
            'current_rod_in_hand': 1,  # üéØ NOVO: Vara atualmente na m√£o (1-6)
            # üéØ SISTEMA DE COORDENA√á√ÉO DE OPERA√á√ïES
            'switching_rod': False,           # Trocando vara
            'reloading_rod': False,          # Recarregando vara com isca
            'replacing_rod': False,          # Substituindo vara quebrada
            'chest_opening': False,          # Abrindo ba√∫
            'searching_rods': False,         # Procurando varas no ba√∫
            'searching_baits': False,        # Procurando iscas no ba√∫
            'auto_cleaning': False,          # Limpeza autom√°tica ativa
            'macro_fishing_active': False,   # Macro principal de pesca ativo
            'operation_queue': [],           # Fila de opera√ß√µes pendentes
            'current_operation': None        # Opera√ß√£o atualmente executando
        }

        # üéØ SISTEMA INTELIGENTE DE COORDENA√á√ÉO DE OPERA√á√ïES
        self.operation_coordinator = self._init_operation_coordinator()

        # üé£ SISTEMA AVAN√áADO DE RASTREAMENTO DE VARAS NA M√ÉO
        self.rod_hand_tracking = {
            'current_rod': 1,              # Vara atual na m√£o (1-6)
            'last_switch_time': 0,         # Timestamp da √∫ltima troca
            'switch_confirmations': {},    # Confirma√ß√µes visuais de troca
            'manual_override': False,      # Override manual do tracking
            'detection_history': [],       # Hist√≥rico de detec√ß√µes para precis√£o
            'confidence_threshold': 0.8,   # Confian√ßa m√≠nima para tracking
            'visual_indicator_active': True # Mostrar no viewer
        }

        # ‚ö° SISTEMA CENTRAL DE COORDENA√á√ÉO INTELIGENTE
        self.coordination_system = {
            'chest_detection_result': None,  # Cache da √∫ltima detec√ß√£o de ba√∫
            'chest_last_check': 0,
            'resource_locks': {  # Evita a√ß√µes duplicadas
                'chest_opening': False,
                'inventory_opening': False,
                'feeding_execution': False,
                'rod_management': False
            },
            'scheduled_tasks': set(),  # Evita tarefas duplicadas
            'priority_coordination': {},  # Coordena tarefas por recurso
            'smart_queue': {  # üß† FILA INTELIGENTE PARA OPERA√á√ïES SIMULT√ÇNEAS
                'chest_operations': [],  # Fila de opera√ß√µes que precisam do ba√∫
                'inventory_operations': [],  # Fila de opera√ß√µes que precisam do invent√°rio
                'combined_operations': [],  # Opera√ß√µes que podem ser combinadas
                'executing': False
            }
        }

        # Posi√ß√µes configur√°veis
        self.pos_bau = [1305, 866]
        self.pos_comida = [1099, 374]

        # Sistema de Alimenta√ß√£o com 2 slots
        self.alimentacao = {
            'ativada': True,
            'feeding_mode': 'detecao_auto',  # üîç PADR√ÉO: detec√ß√£o autom√°tica
            'trigger_mode': 'catches',     # üîò MODO: 'catches' OU 'time' (EXCLUSIVO)
            'current_slot': 1,              # Slot atual (1 ou 2)
            'slot1_uses': 0,               # Usos do slot 1
            'slot2_uses': 0,               # Usos do slot 2
            'max_uses_per_slot': 20,       # 20 usos m√°ximo por slot
            'slot_positions': {
                1: [1306, 858],            # Posi√ß√£o slot 1
                2: [1403, 877]             # Posi√ß√£o slot 2
            },
            'eat_position': EAT_POSITION_DEFAULT,   # Posi√ß√£o para comer
            'feeds_per_session': 5,        # Quantas vezes comer por sess√£o
            'trigger_minutes': 10,         # A cada X minutos
            'trigger_catches': 15,         # Ou a cada X pescas
            'last_feed_time': 0            # √öltimo tempo de alimenta√ß√£o
            # REMOVIDO: 'ultimo_ciclo': 0  (n√£o usado no novo sistema)
        }
        # REMOVIDO: self.intervalo_alimentacao_ciclos = 5  (sistema fallback antigo)

        # Sistema de Limpeza Autom√°tica (ser√° configurado ap√≥s load_config)
        self.auto_clean = {
            'enabled': True,                   # Ativado por padr√£o
            'interval': 10,                    # Padr√£o tempor√°rio - ser√° atualizado
            'fish_count_since_last': 0,        # Contador de pescas
            'last_clean_time': 0,              # √öltimo tempo de limpeza
            'in_progress': False,              # Limpeza em andamento
            'real_fish_caught': 0              # Contador real de peixes capturados (n√£o detec√ß√µes)
        }

        # üõ°Ô∏è SISTEMA DE ANTI-DETEC√á√ÉO AVAN√áADO
        self.anti_detection = {
            'enabled': False,                   # Sistema desabilitado por padr√£o para m√°xima performance

            # Varia√ß√£o de cliques (desabilitada para m√°xima efici√™ncia)
            'click_variation': {
                'enabled': False,
                'min_delay': 0.08,              # Delay m√≠nimo entre cliques (80ms)
                'max_delay': 0.12,              # Delay m√°ximo entre cliques (120ms)
                'base_delay': 0.10              # Delay base (100ms)
            },

            # Varia√ß√£o nos movimentos A/D (desabilitada para m√°xima efici√™ncia)
            'movement_variation': {
                'enabled': False,
                'a_duration_min': 1.4,          # Dura√ß√£o m√≠nima do A (1.4s)
                'a_duration_max': 1.6,          # Dura√ß√£o m√°xima do A (1.6s)
                'd_duration_min': 1.0,          # Dura√ß√£o m√≠nima do D (1.0s)
                'd_duration_max': 1.2,          # Dura√ß√£o m√°xima do D (1.2s)
                'pause_between_min': 0.015,     # Pausa m√≠nima entre A-D (15ms)
                'pause_between_max': 0.025      # Pausa m√°xima entre A-D (25ms)
            },

            # Pausas naturais (desabilitadas para m√°xima performance)
            'natural_breaks': {
                'enabled': False,
                'mode': 'time',                 # 'time' ou 'catches'
                'time_interval': 30,            # Pausar a cada X minutos
                'catches_interval': 50,         # Ou a cada X pescas
                'pause_duration_min': 10,       # Dura√ß√£o m√≠nima da pausa (segundos)
                'pause_duration_max': 30,       # Dura√ß√£o m√°xima da pausa (segundos)
                'last_break_time': 0,          # Timestamp da √∫ltima pausa
                'catches_since_break': 0       # Pescas desde √∫ltima pausa
            },

            # Micro pausas aleat√≥rias REMOVIDAS para m√°xima performance

            # Varia√ß√£o na velocidade de resposta
            'reaction_time': {
                'enabled': True,
                'min_reaction': 0.2,           # Rea√ß√£o m√≠nima (200ms)
                'max_reaction': 0.5            # Rea√ß√£o m√°xima (500ms)
            }
        }

        # REMOVIDO: auto_store (duplicava funcionalidade do auto_clean)
        # Agora tudo √© unificado no sistema auto_clean

        # Carregar configura√ß√µes
        self.load_config()

        # üéØ Inicializar gerenciador de confian√ßa de templates
        self.template_confidence_manager = TemplateConfidenceManager()

        # üéØ Inicializar TemplateManager centralizado ANTES de usar
        self.template_manager = TemplateManager()
        print("üéØ TemplateManager inicializado no FishingBot")

        # Sistema YOLO
        self.init_template_system()
        
        # üéØ Carregar templates centralizados na inicializa√ß√£o
        print("üîÑ Pr√©-carregando templates na inicializa√ß√£o...")
        if self.template_manager.load_all_templates():
            stats = self.template_manager.get_stats()
            print(f"‚úÖ Templates pr√©-carregados: {stats['count']} templates, {stats['memory_mb']:.1f}MB")
        else:
            print("‚ö†Ô∏è Falha ao pr√©-carregar templates - ser√£o carregados sob demanda")

        # Sistema de Varas
        self.init_rod_system()

        # Sistema de Prioridades THREAD-SAFE
        self.priority_queue = []
        self._priority_lock = threading.Lock()

        # Locks para PyAutoGUI - PREVENIR COMANDOS SIMULT√ÇNEOS
        self._mouse_lock = threading.Lock()
        self._keyboard_lock = threading.Lock()

        # Sistema de detec√ß√£o em background com thread safety
        self.last_catch_detection = {'detected': False, 'confidence': 0, 'time': 0}

        # Interface
        self.ui = None

        # Licenciamento
        self.license_manager = LicenseManager()
        self.licensed = False

        # Verificar licen√ßa
        self.check_license()

        # Thread safety para detec√ß√£o
        self.detection_lock = threading.Lock()

    # üéØ ===== SISTEMA INTELIGENTE DE COORDENA√á√ÉO DE OPERA√á√ïES =====

    def _init_operation_coordinator(self):
        """üéØ Inicializar sistema de coordena√ß√£o inteligente"""
        return {
            # üèÜ MATRIZ DE PRIORIDADES (0 = m√°xima prioridade)
            'priorities': {
                'macro_fishing': 0,           # Macro principal de pesca
                'switching_rod': 1,           # Troca de vara
                'reloading_rod': 2,          # Recarga de vara
                'replacing_rod': 3,          # Substitui√ß√£o de vara quebrada
                'chest_opening': 4,          # Abertura de ba√∫
                'searching_rods': 5,         # Busca de varas no ba√∫
                'searching_baits': 6,        # Busca de iscas no ba√∫
                'auto_cleaning': 7,          # Limpeza autom√°tica
                'feeding': 8                 # Alimenta√ß√£o
            },

            # üö´ MATRIZ DE EXCLUS√ÉO M√öTUA - Opera√ß√µes que N√ÉO podem ocorrer simultaneamente
            'conflicts': {
                'macro_fishing': ['switching_rod', 'reloading_rod', 'replacing_rod', 'chest_opening',
                                 'searching_rods', 'searching_baits', 'auto_cleaning', 'feeding'],
                'switching_rod': ['macro_fishing', 'reloading_rod', 'replacing_rod'],
                'reloading_rod': ['macro_fishing', 'switching_rod', 'replacing_rod'],
                'replacing_rod': ['macro_fishing', 'switching_rod', 'reloading_rod', 'searching_rods'],
                'chest_opening': ['macro_fishing'],  # Removido conflito com auto_cleaning
                'searching_rods': ['macro_fishing', 'replacing_rod'],
                'searching_baits': ['macro_fishing'],
                'auto_cleaning': ['macro_fishing'],  # auto_cleaning pode abrir ba√∫ internamente
                'feeding': ['macro_fishing']
            },

            # ‚úÖ PR√â-CONDI√á√ïES para cada opera√ß√£o
            'preconditions': {
                'macro_fishing': ['inventory_closed', 'chest_closed', 'valid_rod_in_hand'],
                'switching_rod': ['macro_fishing_stopped', 'inventory_closed'],
                'reloading_rod': ['macro_fishing_stopped', 'chest_closed'],
                'replacing_rod': ['macro_fishing_stopped'],
                'chest_opening': ['macro_fishing_stopped', 'inventory_closed'],
                'searching_rods': ['chest_open', 'macro_fishing_stopped'],
                'searching_baits': ['chest_open', 'macro_fishing_stopped'],
                'auto_cleaning': ['macro_fishing_stopped'],
                'feeding': ['macro_fishing_stopped', 'inventory_closed']
            }
        }

    def can_execute_operation(self, operation_name):
        """üîç Verificar se uma opera√ß√£o pode ser executada agora"""
        with self._state_lock:
            try:
                # 1. Verificar se h√° opera√ß√£o conflitante ativa
                conflicts = self.operation_coordinator['conflicts'].get(operation_name, [])
                for conflict in conflicts:
                    # Mapear nomes de opera√ß√µes para keys de estado corretos
                    if conflict == 'auto_cleaning':
                        state_key = 'cleaning_active'
                    elif conflict == 'macro_fishing':
                        state_key = 'macro_fishing_active'
                    else:
                        state_key = f"{conflict}_active"

                    if self.game_state.get(state_key, False):
                        print(f"‚ùå {operation_name} bloqueada por {conflict} ativo")
                        return False

                # 2. Verificar pr√©-condi√ß√µes espec√≠ficas
                preconditions = self.operation_coordinator['preconditions'].get(operation_name, [])
                for precondition in preconditions:
                    if not self._check_precondition(precondition):
                        print(f"‚ùå {operation_name} bloqueada: pr√©-condi√ß√£o '{precondition}' n√£o atendida")
                        return False

                print(f"‚úÖ {operation_name} pode ser executada")
                return True

            except Exception as e:
                print(f"‚ùå Erro ao verificar opera√ß√£o {operation_name}: {e}")
                return False

    def _check_precondition(self, precondition):
        """üîç Verificar uma pr√©-condi√ß√£o espec√≠fica"""
        try:
            if precondition == 'inventory_closed':
                return not self.game_state.get('inventory_open', False)
            elif precondition == 'chest_closed':
                return not self.game_state.get('chest_open', False)
            elif precondition == 'macro_fishing_stopped':
                return not self.game_state.get('macro_fishing_active', False)
            elif precondition == 'valid_rod_in_hand':
                # Verificar se h√° uma vara v√°lida na m√£o
                current_rod = self.rod_hand_tracking.get('current_rod', 1)
                return current_rod >= 1 and current_rod <= 6
            elif precondition == 'chest_open':
                return self.game_state.get('chest_open', False)
            else:
                print(f"‚ö†Ô∏è Pr√©-condi√ß√£o desconhecida: {precondition}")
                return True
        except Exception as e:
            print(f"‚ùå Erro ao verificar pr√©-condi√ß√£o {precondition}: {e}")
            return False

    def request_operation(self, operation_name, operation_func, priority=None, context=""):
        """üéØ Solicitar execu√ß√£o de uma opera√ß√£o com coordena√ß√£o inteligente"""
        with self._state_lock:
            try:
                # Definir prioridade baseada no tipo de opera√ß√£o
                if priority is None:
                    priority = self.operation_coordinator['priorities'].get(operation_name, 99)

                # Verificar se pode executar imediatamente
                if self.can_execute_operation(operation_name):
                    print(f"üöÄ Executando {operation_name} imediatamente - {context}")
                    return self._execute_operation_safely(operation_name, operation_func)
                else:
                    # Adicionar √† fila de prioridades
                    operation_request = {
                        'name': operation_name,
                        'func': operation_func,
                        'priority': priority,
                        'context': context,
                        'timestamp': time.time()
                    }

                    self.game_state['operation_queue'].append(operation_request)
                    self.game_state['operation_queue'].sort(key=lambda x: x['priority'])

                    print(f"‚è≥ {operation_name} adicionada √† fila (prioridade {priority}) - {context}")
                    return False

            except Exception as e:
                print(f"‚ùå Erro ao solicitar opera√ß√£o {operation_name}: {e}")
                return False

    def _execute_operation_safely(self, operation_name, operation_func):
        """üîí Executar opera√ß√£o com prote√ß√£o de estado"""
        with self._state_lock:
            try:
                # Marcar opera√ß√£o como ativa - mapear nomes corretos
                if operation_name == 'auto_cleaning':
                    state_key = 'cleaning_active'
                elif operation_name == 'macro_fishing':
                    state_key = 'macro_fishing_active'
                else:
                    state_key = f"{operation_name}_active"

                self.game_state[state_key] = True
                self.game_state['action_in_progress'] = True
                self.game_state['current_operation'] = operation_name

                print(f"üîÑ Iniciando execu√ß√£o protegida de {operation_name}")

                # Executar opera√ß√£o
                result = operation_func()

                print(f"‚úÖ {operation_name} conclu√≠da com resultado: {result}")
                return result

            except Exception as e:
                print(f"‚ùå Erro durante execu√ß√£o de {operation_name}: {e}")
                return False

            finally:
                # Limpar estado da opera√ß√£o
                try:
                    # Mapear nomes corretos para cleanup
                    if operation_name == 'auto_cleaning':
                        state_key = 'cleaning_active'
                        self.auto_clean['in_progress'] = False
                    elif operation_name == 'macro_fishing':
                        state_key = 'macro_fishing_active'
                    else:
                        state_key = f"{operation_name}_active"

                    self.game_state[state_key] = False
                    self.game_state['action_in_progress'] = False
                    self.game_state['current_operation'] = None

                    # Processar pr√≥xima opera√ß√£o na fila
                    self._process_operation_queue()
                except Exception as cleanup_error:
                    print(f"‚ö†Ô∏è Erro no cleanup de {operation_name}: {cleanup_error}")

    def _process_operation_queue(self):
        """‚ö° Processar fila de opera√ß√µes pendentes"""
        try:
            if not self.game_state['operation_queue']:
                return

            # Tentar executar opera√ß√µes pendentes na ordem de prioridade
            executed_operations = []

            for i, operation_request in enumerate(self.game_state['operation_queue']):
                if self.can_execute_operation(operation_request['name']):
                    print(f"üéØ Executando opera√ß√£o pendente: {operation_request['name']}")

                    result = self._execute_operation_safely(
                        operation_request['name'],
                        operation_request['func']
                    )

                    executed_operations.append(i)

                    # Executar apenas uma opera√ß√£o por vez para evitar conflitos
                    break

            # Remover opera√ß√µes executadas da fila
            for i in reversed(executed_operations):
                self.game_state['operation_queue'].pop(i)

        except Exception as e:
            print(f"‚ùå Erro ao processar fila de opera√ß√µes: {e}")

    def get_operation_status(self):
        """üìä Obter status atual das opera√ß√µes"""
        with self._state_lock:
            active_operations = []
            for key, value in self.game_state.items():
                if key.endswith('_active') or key in ['switching_rod', 'reloading_rod', 'replacing_rod',
                                                    'chest_opening', 'searching_rods', 'searching_baits',
                                                    'auto_cleaning', 'feeding_active']:
                    if value:
                        active_operations.append(key)

            return {
                'active_operations': active_operations,
                'current_operation': self.game_state.get('current_operation'),
                'queue_size': len(self.game_state.get('operation_queue', []))
            }

    def print_coordination_status(self):
        """üìä Imprimir status completo do sistema de coordena√ß√£o"""
        status = self.get_operation_status()

        print("\nüéØ ===== STATUS DO SISTEMA DE COORDENA√á√ÉO =====")
        print(f"üìä Opera√ß√£o Atual: {status['current_operation'] or 'NENHUMA'}")
        print(f"‚è≥ Fila de Espera: {status['queue_size']} opera√ß√µes")

        if status['active_operations']:
            print("üîÑ Opera√ß√µes Ativas:")
            for op in status['active_operations']:
                print(f"   ‚Ä¢ {op}")
        else:
            print("‚úÖ Nenhuma opera√ß√£o ativa - Sistema livre")

        if self.game_state.get('operation_queue'):
            print("‚è∞ Pr√≥ximas na Fila:")
            for i, op in enumerate(self.game_state['operation_queue'][:3]):
                print(f"   {i+1}. {op['name']} (prioridade {op['priority']}) - {op['context']}")

        print("=" * 50)

    def emergency_clear_operations(self):
        """üö® Limpar todas as opera√ß√µes em caso de emerg√™ncia"""
        with self._state_lock:
            print("üö® LIMPEZA DE EMERG√äNCIA DAS OPERA√á√ïES!")

            # Limpar todos os estados de opera√ß√£o
            for key in self.game_state.keys():
                if key.endswith('_active') or key in ['switching_rod', 'reloading_rod', 'replacing_rod',
                                                    'chest_opening', 'searching_rods', 'searching_baits',
                                                    'auto_cleaning', 'feeding_active']:
                    self.game_state[key] = False

            # Limpar fila e opera√ß√£o atual
            self.game_state['operation_queue'] = []
            self.game_state['current_operation'] = None

            print("‚úÖ Todos os estados de opera√ß√£o foram limpos!")

    def safe_set_state(self, key, value):
        """THREAD-SAFE: Definir estado com lock"""
        with self._state_lock:
            self.game_state[key] = value

    def safe_get_state(self, key, default=None):
        """THREAD-SAFE: Obter estado com lock"""
        with self._state_lock:
            return self.game_state.get(key, default)

    def safe_update_states(self, updates):
        """THREAD-SAFE: Atualizar m√∫ltiplos estados atomicamente"""
        with self._state_lock:
            for key, value in updates.items():
                self.game_state[key] = value

    def safe_mouse_action(self, action_type, *args, **kwargs):
        """THREAD-SAFE: Executar a√ß√£o de mouse com lock e foco no jogo"""
        with self._mouse_lock:
            # Garantir que a janela do jogo esteja em foco
            focus_game_window()
            
            if action_type == 'click':
                return pyautogui.click(*args, **kwargs)
            elif action_type == 'rightClick':
                return pyautogui.rightClick(*args, **kwargs)
            elif action_type == 'mouseDown':
                return pyautogui.mouseDown(*args, **kwargs)
            elif action_type == 'mouseUp':
                return pyautogui.mouseUp(*args, **kwargs)
            elif action_type == 'moveTo':
                return pyautogui.moveTo(*args, **kwargs)
            else:
                print(f"‚ö†Ô∏è A√ß√£o de mouse desconhecida: {action_type}")
                return False

    def safe_keyboard_action(self, action_type, *args, **kwargs):
        """THREAD-SAFE: Executar a√ß√£o de teclado com lock e foco no jogo"""
        with self._keyboard_lock:
            # Garantir que a janela do jogo esteja em foco
            focus_game_window()
            
            if action_type == 'press':
                return pyautogui.press(*args, **kwargs)
            elif action_type == 'keyDown':
                return pyautogui.keyDown(*args, **kwargs)
            elif action_type == 'keyUp':
                return pyautogui.keyUp(*args, **kwargs)
            else:
                print(f"‚ö†Ô∏è A√ß√£o de teclado desconhecida: {action_type}")
                return False

    def load_config(self):
        """Carregar configura√ß√µes do arquivo config.json"""
        try:
            with open('config.json', 'r', encoding='utf-8') as f:
                self.config = json.load(f)
            print("‚úÖ Configura√ß√µes carregadas com sucesso!")

            # Verificar se existe configura√ß√£o de confian√ßa por classe
            if 'class_confidence' not in self.config:
                self.config['class_confidence'] = self.get_default_class_confidence()
                print("üìä Configura√ß√µes de confian√ßa por classe n√£o encontradas, usando padr√£o.")

            # üçñ CARREGAR CONFIGURA√á√ïES DE ALIMENTA√á√ÉO SALVAS
            self.load_feeding_config_from_file()

            # üé£ CARREGAR PRIORIDADES DE ISCAS SALVAS
            self.load_bait_priority_config()

            # üõ°Ô∏è CARREGAR CONFIGURA√á√ïES ANTI-DETEC√á√ÉO
            self.load_anti_detection_config()

            # üßπ CARREGAR CONFIGURA√á√ïES DE LIMPEZA AUTOM√ÅTICA
            self.load_auto_clean_config()

        except FileNotFoundError:
            # Configura√ß√µes padr√£o se arquivo n√£o existir
            self.config = {
                "cycle_timeout": 60,
                "chest_side": "left",
                "confidence_threshold": 0.8,
                "model_path": "best.pt",
                "auto_reload": True,
                "loot_interval": 10,
                "auto_clean_interval": 10,
                "pair_switch_limit": 20,
                "feed_clicks": 5,
                "clicks_per_second": 12,
                "chest_distance": 300,
                "chest_absolute_pos": {"left": {"x": 0, "y": 0}, "right": {"x": 0, "y": 0}},
                "class_confidence": self.get_default_class_confidence()
            }
            print("‚ö†Ô∏è Arquivo config.json n√£o encontrado, usando configura√ß√µes padr√£o.")
            self.save_default_config()
        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes: {e}")
            # Usar configura√ß√µes padr√£o
            self.config = {
                "cycle_timeout": 60,
                "chest_side": "left",
                "confidence_threshold": 0.8,
                "model_path": "best.pt",
                "auto_reload": True,
                "loot_interval": 10,
                "pair_switch_limit": 20,
                "class_confidence": self.get_default_class_confidence()
            }

    def load_anti_detection_config(self):
        """Carregar configura√ß√µes do sistema anti-detec√ß√£o"""
        try:
            # Configura√ß√µes padr√£o do sistema anti-detec√ß√£o
            default_anti_detection = {
                'enabled': True,
                'click_variation': {
                    'enabled': True,
                    'min_delay': 0.08,  # 80ms
                    'max_delay': 0.15   # 150ms
                },
                'movement_variation': {
                    'enabled': True,
                    'a_duration_min': 1.2,
                    'a_duration_max': 1.8,
                    'd_duration_min': 1.0,
                    'd_duration_max': 1.4
                },
                'natural_breaks': {
                    'enabled': True,
                    'mode': 'catches',  # 'time' ou 'catches'
                    'time_interval': 45,  # minutos
                    'catches_interval': 50,  # n√∫mero de pescas
                    'pause_duration_min': 15,  # segundos
                    'pause_duration_max': 45   # segundos
                },
                # Micro pausas removidas
            }

            # Verificar se existe no config carregado
            if hasattr(self, 'config') and 'anti_detection' in self.config:
                self.anti_detection = self.config['anti_detection']
                print("‚úÖ Configura√ß√µes anti-detec√ß√£o carregadas do arquivo")
            else:
                # Usar configura√ß√µes padr√£o
                self.anti_detection = default_anti_detection
                print("‚öôÔ∏è Usando configura√ß√µes anti-detec√ß√£o padr√£o")

                # Salvar padr√£o no arquivo se n√£o existe
                if hasattr(self, 'config'):
                    self.config['anti_detection'] = self.anti_detection

        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes anti-detec√ß√£o: {e}")
            # Fallback para configura√ß√µes b√°sicas
            self.anti_detection = {
                'enabled': True,
                'click_variation': {'enabled': True, 'min_delay': 0.08, 'max_delay': 0.15},
                'movement_variation': {'enabled': True, 'a_duration_min': 1.2, 'a_duration_max': 1.8, 'd_duration_min': 1.0, 'd_duration_max': 1.4},
                'natural_breaks': {'enabled': True, 'mode': 'catches', 'time_interval': 45, 'catches_interval': 50, 'pause_duration_min': 15, 'pause_duration_max': 45}
            }

    def get_default_class_confidence(self):
        """Obter configura√ß√µes padr√£o de confian√ßa por classe"""
        yolo_classes = ['anchova', 'aranque', 'barril aberto', 'carne de lobo', 'carne de urso',
                       'cartao azul', 'conforto', 'cortar', 'file de peixe', 'flare', 'gordura',
                       'inventario aberto', 'parca', 'peixe capturado', 'salmao', 'sardinha',
                       'scrap', 'truta', 'smalltrout', 'tubarao', 'vara', 'vara com isca']

        # Configura√ß√µes espec√≠ficas por classe (ajustar conforme necess√°rio)
        default_confidences = {}
        for class_name in yolo_classes:
            # Classes importantes com confian√ßa alta
            if class_name in ['peixe capturado', 'vara', 'vara com isca', 'barril aberto', 'inventario aberto']:
                default_confidences[class_name] = 0.8
            # Peixes com confian√ßa m√©dia-alta
            elif class_name in ['anchova', 'aranque', 'salmao', 'sardinha', 'truta', 'smalltrout', 'tubarao']:
                default_confidences[class_name] = 0.7
            # Iscas com confian√ßa m√©dia-alta
            elif class_name in ['carne de lobo', 'carne de urso']:
                default_confidences[class_name] = 0.7
            # Outras classes com confian√ßa padr√£o
            else:
                default_confidences[class_name] = 0.5

        return default_confidences

    def load_feeding_config_from_file(self):
        """Carregar configura√ß√µes de alimenta√ß√£o salvas do config.json"""
        try:
            if 'feeding' in self.config:
                feeding_config = self.config['feeding']
                print("üçñ Carregando configura√ß√µes de alimenta√ß√£o salvas...")

                # Atualizar posi√ß√µes dos slots se existirem
                if 'slot1_position' in feeding_config:
                    self.alimentacao['slot_positions'][1] = feeding_config['slot1_position']
                    print(f"   üìç Slot 1: {feeding_config['slot1_position']}")

                if 'slot2_position' in feeding_config:
                    self.alimentacao['slot_positions'][2] = feeding_config['slot2_position']
                    print(f"   üìç Slot 2: {feeding_config['slot2_position']}")

                if 'eat_position' in feeding_config:
                    self.alimentacao['eat_position'] = feeding_config['eat_position']
                    print(f"   üçñ Posi√ß√£o comer: {feeding_config['eat_position']}")

                # Atualizar outras configura√ß√µes
                if 'feeds_per_session' in feeding_config:
                    self.alimentacao['feeds_per_session'] = feeding_config['feeds_per_session']
                    print(f"   üî¢ Comidas por sess√£o: {feeding_config['feeds_per_session']}")

                if 'max_uses_per_slot' in feeding_config:
                    self.alimentacao['max_uses_per_slot'] = feeding_config['max_uses_per_slot']
                    print(f"   üìà M√°x usos por slot: {feeding_config['max_uses_per_slot']}")

                if 'trigger_minutes' in feeding_config:
                    self.alimentacao['trigger_minutes'] = feeding_config['trigger_minutes']
                    print(f"   ‚è∞ Trigger minutos: {feeding_config['trigger_minutes']}")

                if 'trigger_catches' in feeding_config:
                    self.alimentacao['trigger_catches'] = feeding_config['trigger_catches']
                    print(f"   üé£ Trigger pescas: {feeding_config['trigger_catches']}")

                if 'trigger_mode' in feeding_config:
                    self.alimentacao['trigger_mode'] = feeding_config['trigger_mode']
                    print(f"   üîò Modo trigger: {feeding_config['trigger_mode']}")

                print("‚úÖ Configura√ß√µes de alimenta√ß√£o carregadas do arquivo!")

            else:
                print("‚ö†Ô∏è Nenhuma configura√ß√£o de alimenta√ß√£o salva encontrada, usando padr√µes.")

        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes de alimenta√ß√£o: {e}")

    def load_auto_clean_config(self):
        """Carregar configura√ß√µes de limpeza autom√°tica do config.json"""
        try:
            if 'auto_clean_interval' in self.config:
                self.auto_clean['interval'] = self.config['auto_clean_interval']
                print(f"üßπ Intervalo de limpeza autom√°tica carregado: {self.auto_clean['interval']} pescas")
            else:
                print("‚ö†Ô∏è Configura√ß√£o de limpeza autom√°tica n√£o encontrada, usando padr√£o: 10 pescas")
        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes de limpeza: {e}")

    def load_bait_priority_config(self):
        """Carregar configura√ß√µes de prioridade de iscas do config.json"""
        try:
            # Carregar prioridades de iscas
            if 'bait_priority' in self.config:
                self.bait_priority = self.config['bait_priority']
                print("üé£ Configura√ß√µes de prioridade de iscas carregadas:")
                for bait, priority in sorted(self.bait_priority.items(), key=lambda x: x[1]):
                    print(f"   {priority}. {bait}")
            else:
                # Usar configura√ß√£o padr√£o
                self.bait_priority = {
                    'carne de urso': 1,
                    'carne de lobo': 2,
                    'trout': 3,
                    'grub': 4,
                    'worm': 5
                }
                print("‚ö†Ô∏è Configura√ß√£o de prioridade de iscas n√£o encontrada, usando padr√£o:")
                for bait, priority in sorted(self.bait_priority.items(), key=lambda x: x[1]):
                    print(f"   {priority}. {bait}")

            # Carregar estados de iscas habilitadas/desabilitadas
            if 'bait_enabled' in self.config:
                self.bait_enabled = self.config['bait_enabled']
                print("‚úÖ Configura√ß√µes de iscas habilitadas carregadas:")
                for bait, enabled in self.bait_enabled.items():
                    status = "‚úÖ" if enabled else "‚ùå"
                    print(f"   {status} {bait}")
            else:
                # Padr√£o: todas as iscas habilitadas
                self.bait_enabled = {
                    'carne de urso': True,
                    'carne de lobo': True,
                    'trout': True,
                    'grub': True,
                    'worm': True
                }
                print("‚ö†Ô∏è Configura√ß√£o de iscas habilitadas n√£o encontrada, todas ativadas por padr√£o")

        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes de prioridade de iscas: {e}")
            # Fallback para configura√ß√£o padr√£o
            self.bait_priority = {
                'carne de urso': 1,
                'carne de lobo': 2,
                'trout': 3,
                'grub': 4,
                'worm': 5
            }
            self.bait_enabled = {
                'carne de urso': True,
                'carne de lobo': True,
                'trout': True,
                'grub': True,
                'worm': True
            }

    def get_unified_template_threshold(self, template_name):
        """üéØ M√©todo utilit√°rio para obter threshold unificado com Catch Viewer

        Este m√©todo garante que TODOS os sistemas de detec√ß√£o usem os mesmos
        thresholds configurados na UI do Catch Viewer
        """
        try:
            # Remover extens√£o se houver
            clean_name = template_name.replace('.png', '').replace('.PNG', '')

            # Usar template_confidence_manager (mesmo sistema do Catch Viewer)
            if hasattr(self, 'template_confidence_manager') and self.template_confidence_manager:
                threshold = self.template_confidence_manager.get_template_confidence(clean_name)
                return threshold

            # üéØ PRIMEIRO: Verificar template_confidence do config.json
            template_confidence = self.config.get('template_confidence', {})

            # Verificar mapeamento direto do template
            if clean_name in template_confidence:
                return template_confidence[clean_name]

            # üêõ CORRE√á√ÉO ESPEC√çFICA: Mapear worm ‚Üí minhoca
            if clean_name == 'worm' and 'minhoca' in template_confidence:
                return template_confidence['minhoca']

            # Verificar outros mapeamentos espec√≠ficos conhecidos
            template_mapping = {
                'carneurso': 'carne_urso_1',
                'carnedeurso': 'carne_urso_2',
                'wolfmeat': 'carne_lobo_1',
                'carnedelobu': 'carne_lobo_2',
                'grub': 'isca_1',
                'gruub': 'isca_2',
                'smalltrout': 'truta_1'
            }

            mapped_name = template_mapping.get(clean_name)
            if mapped_name and mapped_name in template_confidence:
                return template_confidence[mapped_name]

            # Fallback: thresholds padr√£o se n√£o houver template_confidence_manager
            default_thresholds = {
                'catch': 0.8,
                'varaquebrada': 0.7,
                'VARANOBAUCI': 0.7,
                'varacomisca': 0.7,
                'comiscavara': 0.8,
                'namaocomisca': 0.8,
                'comiscanamao': 0.7,
                'semiscavara': 0.7,
                'varasemisca': 0.7,
                'semiscanam': 0.7,
                'namaosemisca': 0.7,
                'enbausi': 0.7,
                'eat': 0.8,
                'inventory': 0.8,
                'loot': 0.8,
                'worm': 0.6,  # üêõ MINHOCA: threshold mais baixo
                'minhoca': 0.6,  # üêõ MINHOCA: threshold mais baixo
                'grub': 0.6,  # üêõ ISCA: threshold mais baixo tamb√©m
                'carneurso': 0.6,  # üêõ CARNE URSO: threshold mais baixo
                'wolfmeat': 0.6,  # üêõ CARNE LOBO: threshold mais baixo
                'smalltrout': 0.6  # üêõ TRUTA: threshold mais baixo
            }

            return default_thresholds.get(clean_name, 0.7)

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao obter threshold para {template_name}: {e}")
            return 0.7  # Fallback seguro

    def clear_detection_cache(self):
        """üßπ Limpar todos os caches de detec√ß√£o para garantir dados atualizados"""
        try:
            # Limpar cache do full_detection_cache
            if hasattr(self, 'full_detection_cache'):
                self.full_detection_cache = {
                    'baits_in_inventory': [],
                    'baits_in_chest': [],
                    'rods_in_chest': [],
                    'all_items': [],
                    'cached_at': 0,
                    'cache_timeout': 30
                }
                print("   üì¶ Cache de detec√ß√µes gerais limpo")

            # Limpar cache da interface (Catch Viewer)
            if hasattr(self, 'ui') and self.ui and hasattr(self.ui, 'rod_status_tracking'):
                self.ui.rod_status_tracking = {
                    'available_with_bait': [],
                    'available_without_bait': [],
                    'broken_rods': [],
                    'empty_slots': [],
                    'slots': {},
                    'inventory_was_open': False,
                    'last_inventory_check': 0,
                    'last_update': time.time(),
                    'preserved': False
                }
                print("   üìä Cache do Catch Viewer limpo")
        except Exception as e:
            print(f"‚ùå Erro ao limpar cache de detec√ß√£o: {e}")

    def auto_clear_cache_on_error(self, error_context=""):
        """üîß Auto-limpeza do cache quando detectar problemas"""
        print(f"\n‚ö†Ô∏è DETECTADO PROBLEMA - AUTO-LIMPEZA DE CACHE ({error_context})")
        print("="*60)
        
        try:
            # For√ßar limpeza de caches cr√≠ticos
            cache_cleared = 0
            
            # 1. Templates corrompidos
            if hasattr(self, 'template_manager') and self.template_manager:
                old_size = self.template_manager.get_cache_size()
                self.template_manager.clear_cache()
                print(f"üßπ {old_size} templates removidos do cache")
                cache_cleared += 1
            
            # 2. Cache de tela corrompido
            screen_caches = ['_screen_gray_cache', '_quick_screen_cache']
            for cache_name in screen_caches:
                if hasattr(self, cache_name):
                    delattr(self, cache_name)
                    print(f"üßπ Cache de tela limpo: {cache_name}")
                    cache_cleared += 1
            
            # 3. Cache de templates corrompido
            template_caches = ['_template_cache', '_quick_template_cache']
            for cache_name in template_caches:
                if hasattr(self, cache_name):
                    cache_obj = getattr(self, cache_name)
                    if isinstance(cache_obj, dict):
                        cache_obj.clear()
                    delattr(self, cache_name)
                    print(f"üßπ Cache de templates limpo: {cache_name}")
                    cache_cleared += 1
            
            # 4. Recrear inst√¢ncia MSS se necess√°rio
            if hasattr(self, 'sct') and self.sct:
                try:
                    self.sct.close()
                    import mss
                    self.sct = mss.mss()
                    print("üì∏ Inst√¢ncia MSS recriada")
                    cache_cleared += 1
                except:
                    pass
            
            # 5. Garbage collection
            import gc
            collected = gc.collect()
            
            if cache_cleared > 0:
                print(f"‚úÖ Auto-limpeza conclu√≠da: {cache_cleared} caches limpos, {collected} objetos coletados")
                print("üîÑ Sistema deve funcionar normalmente agora")
            else:
                print("üí° Nenhum cache problem√°tico detectado")
                
        except Exception as e:
            print(f"‚ùå Erro na auto-limpeza: {e}")

            # Limpar cache de templates (se existir)
            if hasattr(self, '_template_cache'):
                self._template_cache.clear()
                print("   üéØ Cache de templates limpo")

            if hasattr(self, '_quick_template_cache'):
                self._quick_template_cache.clear()
                print("   ‚ö° Cache de templates r√°pidos limpo")

            print("üßπ Limpeza de cache conclu√≠da - dados frescos garantidos!")

        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza de cache: {e}")

    def init_template_system(self):
        """üéØ Inicializar sistema Template Matching (substitui√ß√£o do YOLO)"""
        try:
            print("üéØ Inicializando sistema Template Matching...")

            # Inicializar captura de tela
            self.sct = mss.mss()

            # Criar lock para thread safety
            self.template_lock = threading.Lock()

            # üéØ Sistema de Templates com Fallbacks Inteligentes
            # üîß IMPORTANTE: Backups s√£o a MESMA COISA - se n√£o detectar um, usa outro
            self.template_classes = {
                # ‚ö° DETEC√á√ïES CR√çTICAS
                'peixe_capturado': ['catch.png'],         # Peixe capturado - CR√çTICO
                'inventario_aberto': ['inventory.png'],   # Invent√°rio aberto
                'barril_aberto': ['loot.png'],           # Ba√∫/barril aberto

                # üé£ SISTEMA DE VARAS (com fallbacks autom√°ticos)
                'vara_com_isca': ['comiscavara.png', 'varacomisca.png', 'namaocomisca.png', 'comiscanamao.png', 'VARANOBAUCI.png'],     # COM ISCA
                'vara_sem_isca': ['semiscavara.png', 'varasemisca.png', 'semiscanam.png', 'namaosemisca.png', 'enbausi.png'],     # SEM ISCA
                'vara_quebrada': ['varaquebrada.png'],                       # Vara quebrada

                # üêü PEIXES (com fallbacks bilinguais)
                'anchova': ['anchovy.png'],                             # Anchovy (EN) = Anchova (PT)
                'salmao': ['salmon.png', 'SALMONN.png'],               # MESMA COISA - backups
                'sardinha': ['sardine.png'],                           # Sardine (EN) = Sardinha (PT)
                'truta': ['smalltrout.png', 'TROUTT.png'],            # MESMA COISA - backups
                'tubarao': ['shark.png'],                              # Shark (EN) = Tubar√£o (PT)
                'perca_amarela': ['yellowperch.png'],                  # Yellow Perch (EN)
                'arenque': ['herring.png'],                            # Herring (EN) = Arenque (PT)
                'peixe_cru': ['peixecru.png', 'rawfish.png'],          # MESMA COISA - PT/EN

                # ü•© ISCAS E CARNES (com fallbacks)
                'carne_urso': ['carnedeurso.png', 'carneurso.png'],    # MESMA COISA - backups
                'carne_lobo': ['wolfmeat.png'],                        # Wolf Meat (EN)
                'isca': ['grub.png'],                                  # Grub/Larva
                'minhoca': ['worm.png'],                               # Worm (EN) = Minhoca (PT)

                # üçñ ALIMENTA√á√ÉO
                'file_frito': ['filefrito.png'],                       # Fried Fillet (PT)
                'comer': ['eat.png'],                                  # Eat action

                # üì¶ CONTAINERS (organizados por tipo)
                'caixa_grande': ['largebox.png'],
                'caixa_salmao': ['salmonbox.png'],
                'caixa_truta': ['smalltroutbox.png'],
                'caixa_perca': ['yellowperchbox.png'],
                'caixa_lobo': ['wolfmeatbox.png'],
                'caixa_grub': ['grubbox.png'],
                'caixa_worm': ['wormbox.png'],

                # üîß OUTROS ITENS
                'scrap': ['scrap.png'],
                'sinalizador': ['flare.png'],                          # Flare (EN) = Sinalizador (PT)
                'cartao_azul': ['bluecard.png'],                       # Blue Card (EN)
                'gut': ['gut.png'],                                    # Tripas

                # üíÄ ITENS PARA GUARDAR NO BA√ö
                'bullet': ['bullet.png'],                              # Muni√ß√£o
                'BONE': ['BONE.png'],                                  # Fragmentos de osso
                'fat': ['fat.png']                                     # Gordura animal
            }

            # Verificar quais templates existem
            templates_path = "templates"
            if not os.path.exists(templates_path):
                os.makedirs(templates_path)
                print(f"üìÅ Criada pasta: {templates_path}")

            self.available_templates = {}
            for class_name, template_files in self.template_classes.items():
                # Suporte a arrays de fallbacks
                if isinstance(template_files, list):
                    found_template = None
                    for template_file in template_files:
                        template_path = os.path.join(templates_path, template_file)
                        if os.path.exists(template_path):
                            found_template = template_path
                            self.available_templates[class_name] = template_path

                            # Mostrar qual fallback foi usado
                            if len(template_files) > 1:
                                fallback_index = template_files.index(template_file)
                                if fallback_index == 0:
                                    print(f"‚úÖ {_('template_found')}: {_(class_name)} ({template_file})")
                                else:
                                    print(f"üîÑ {_('template_found')} (fallback {fallback_index+1}): {_(class_name)} ({template_file})")
                            else:
                                print(f"‚úÖ {_('template_found')}: {_(class_name)} ({template_file})")
                            break

                    if not found_template:
                        fallback_list = " | ".join(template_files)
                        print(f"‚ö†Ô∏è {_('template_not_found')}: {_(class_name)} ({fallback_list})")

                else:
                    # Compatibilidade com formato antigo (string √∫nica)
                    template_path = os.path.join(templates_path, template_files)
                    if os.path.exists(template_path):
                        self.available_templates[class_name] = template_path
                        print(f"‚úÖ {_('template_found')}: {_(class_name)} ({template_files})")
                    else:
                        print(f"‚ö†Ô∏è {_('template_not_found')}: {_(class_name)} ({template_files})")

            # Remover atributos YOLO (compatibilidade)

            print("‚úÖ Sistema Template Matching inicializado!")
            print(f"   üìÅ Pasta templates: {templates_path}")
            print(f"   üéØ Templates dispon√≠veis: {len(self.available_templates)}")

        except Exception as e:
            print(f"‚ùå Erro ao inicializar Template Matching: {e}")
            import traceback
            traceback.print_exc()
            self.sct = None
            self.template_lock = None
            self.available_templates = {}

    def init_rod_system(self):
        """Inicializar sistema de varas APRIMORADO com rastreamento individual"""
        self.rod_system = {
            'current_pair': 0,  # 0=(1,2), 1=(3,4), 2=(5,6)
            'current_rod': 1,   # 1 ou 2 (dentro da dupla)
            'pairs': [(1,2), (3,4), (5,6)],
            'rod1_usage': 0,    # Usos da vara 1 na dupla atual (peixes capturados)
            'rod2_usage': 0,    # Usos da vara 2 na dupla atual (peixes capturados)
            'rod1_cycles': 0,   # Ciclos da vara 1 (peixes + timeouts)
            'rod2_cycles': 0,   # Ciclos da vara 2 (peixes + timeouts)
            'max_usage_per_rod': 20,  # 20 usos por vara
            'max_cycles_per_rod': 20,  # 20 ciclos por vara individual (fixo)
            'max_usage_per_pair': 40, # 40 usos por dupla (20+20)
            'catches_count': 0, # Peixes capturados
            'switch_threshold': 30,  # Trocar dupla a cada 30 pescas
            # üé£ NOVO: Rastreamento individual de cada vara
            'rod_tracking': {
                1: {'uses': 0, 'initial_uses': 20, 'reload_uses': 0, 'total_max': 20,
                    'has_bait': True, 'reloaded': False, 'broken': False, 'timeouts': 0},
                2: {'uses': 0, 'initial_uses': 20, 'reload_uses': 0, 'total_max': 20,
                    'has_bait': True, 'reloaded': False, 'broken': False, 'timeouts': 0},
                3: {'uses': 0, 'initial_uses': 20, 'reload_uses': 0, 'total_max': 20,
                    'has_bait': True, 'reloaded': False, 'broken': False, 'timeouts': 0},
                4: {'uses': 0, 'initial_uses': 20, 'reload_uses': 0, 'total_max': 20,
                    'has_bait': True, 'reloaded': False, 'broken': False, 'timeouts': 0},
                5: {'uses': 0, 'initial_uses': 20, 'reload_uses': 0, 'total_max': 20,
                    'has_bait': True, 'reloaded': False, 'broken': False, 'timeouts': 0},
                6: {'uses': 0, 'initial_uses': 20, 'reload_uses': 0, 'total_max': 20,
                    'has_bait': True, 'reloaded': False, 'broken': False, 'timeouts': 0}
            },

            # üö® SISTEMA DE TIMEOUT INTELIGENTE
            'rod1_timeouts': 0,    # Timeouts consecutivos da vara 1 na dupla atual
            'rod2_timeouts': 0,    # Timeouts consecutivos da vara 2 na dupla atual
            'timeout_threshold': 3,  # 3 timeouts = vara provavelmente vazia
            'last_successful_rod': None,  # √öltima vara que pescou com sucesso

            # üé£ SISTEMA INTELIGENTE DE DETEC√á√ÉO DE VARAS
            'available_rods': [],  # Lista de slots com varas detectadas (1-6)
            'empty_rods': [],  # Lista de varas vazias que precisam recarga
            'initial_rod_count': 0,  # Quantidade de varas no in√≠cio
            'min_rods_needed': 2,  # M√≠nimo de varas para continuar pescando
            'last_rod_check': 0,  # Timestamp da √∫ltima verifica√ß√£o
            'rod_check_interval': 60  # Verificar varas a cada 60 segundos
        }
        print("‚úÖ Sistema de varas inicializado!")

    def handle_timeout_intelligence(self):
        """üö® Sistema inteligente de timeout - detecta vara sem isca e toma a√ß√µes"""
        current_rod = self.rod_system['current_rod']
        absolute_rod = self.get_absolute_rod_number()
        print(f"\nüö® [TIMEOUT] Analisando timeout na vara {current_rod} (slot {absolute_rod})...")

        # Rastrear hist√≥rico de timeouts por vara
        if not hasattr(self, 'timeout_history'):
            self.timeout_history = {}

        if absolute_rod not in self.timeout_history:
            self.timeout_history[absolute_rod] = []

        current_time = time.time()
        self.timeout_history[absolute_rod].append(current_time)

        # Limpar timeouts antigos (mais de 2 minutos)
        self.timeout_history[absolute_rod] = [t for t in self.timeout_history[absolute_rod]
                                             if current_time - t < 120]

        # Incrementar contador de timeout E ciclo da vara atual
        if current_rod == 1:
            self.rod_system['rod1_timeouts'] += 1
            self.rod_system['rod1_cycles'] += 1  # NOVO: Contar timeout como ciclo
            timeouts_atual = self.rod_system['rod1_timeouts']
            timeouts_outra = self.rod_system['rod2_timeouts']
        else:
            self.rod_system['rod2_timeouts'] += 1
            self.rod_system['rod2_cycles'] += 1  # NOVO: Contar timeout como ciclo
            timeouts_atual = self.rod_system['rod2_timeouts']
            timeouts_outra = self.rod_system['rod1_timeouts']

        threshold = self.rod_system['timeout_threshold']

        print(f"   üìä Status timeouts: Vara 1 = {self.rod_system['rod1_timeouts']}, Vara 2 = {self.rod_system['rod2_timeouts']}")
        print(f"   üîÑ Status ciclos: Vara 1 = {self.rod_system['rod1_cycles']}/{self.rod_system['max_cycles_per_rod']}, Vara 2 = {self.rod_system['rod2_cycles']}/{self.rod_system['max_cycles_per_rod']}")
        print(f"   ‚ö†Ô∏è Vara {absolute_rod}: {timeouts_atual}/{threshold} timeouts")

        # üîç DETEC√á√ÉO INTELIGENTE: Threshold configur√°vel de timeouts = verificar isca  
        if len(self.timeout_history[absolute_rod]) >= threshold:
            print(f"‚ö†Ô∏è VARA {absolute_rod} COM {len(self.timeout_history[absolute_rod])} TIMEOUTS RECENTES!")
            print("üì∏ Verificando estado das varas com TAB...")

            # Pressionar TAB para melhor visualiza√ß√£o
            self.close_inventory_with_delay("Auto opera√ß√£o")
            
            # üîß OTIMIZA√á√ÉO: Verificar e fazer manuten√ß√£o completa j√° que invent√°rio est√° aberto
            print(f"üîß [TIMEOUT] Atingido threshold de {threshold} timeouts - executando manuten√ß√£o completa...")
            
            # Abrir ba√∫ para manuten√ß√£o completa (mesmo processo que limpeza/alimenta√ß√£o)
            print("üì¶ [TIMEOUT] Abrindo ba√∫ para manuten√ß√£o completa...")
            chest_success = self.open_chest()
            
            if chest_success:
                time.sleep(2)  # Aguardar ba√∫ abrir
                print("üîß [TIMEOUT] Executando manuten√ß√£o completa das varas...")
                maintenance_done = self.check_and_maintain_rods_after_cleanup()
                
                # Fechar ba√∫ ap√≥s manuten√ß√£o
                self.close_inventory_with_delay("Auto opera√ß√£o")
                
                if maintenance_done:
                    print("‚úÖ [TIMEOUT] Manuten√ß√£o completa realizada ap√≥s timeouts!")
                    # Resetar timeouts ap√≥s manuten√ß√£o
                    self.rod_system['rod1_timeouts'] = 0
                    self.rod_system['rod2_timeouts'] = 0
                    print("üîÑ [TIMEOUT] Timeouts resetados ap√≥s manuten√ß√£o")
                else:
                    print("‚ÑπÔ∏è [TIMEOUT] Nenhuma manuten√ß√£o necess√°ria")
            else:
                print("‚ùå [TIMEOUT] Falha ao abrir ba√∫ para manuten√ß√£o")

            # Usar rod_status_tracking se dispon√≠vel
            if hasattr(self, 'rod_status_tracking'):
                self.update_rod_status_from_catch_viewer()

                # Verificar se a vara atual est√° sem isca
                if absolute_rod in self.rod_status_tracking.get('available_without_bait', []):
                    print(f"‚ùå CONFIRMADO: Vara {absolute_rod} est√° SEM ISCA!")

                    # Tentar recarregar
                    if self.config.get('rod_reload_system', {}).get('auto_reload_enabled', True):
                        print("üîÑ Tentando recarregar vara...")
                        if self.auto_reload_rod(absolute_rod):
                            print("‚úÖ Vara recarregada!")
                            self.timeout_history[absolute_rod].clear()
                            self.rod_system['rod1_timeouts'] = 0
                            self.rod_system['rod2_timeouts'] = 0
                            return "rod_reloaded"

                    # Se n√£o conseguiu recarregar, trocar para vara com isca
                    return self.smart_rod_switch()

            # Fechar TAB
            pyautogui.press('tab')
            time.sleep(0.3)

        # üéØ L√ìGICA INTELIGENTE DE DECIS√ÉO

        if timeouts_atual >= threshold:
            print(f"üö® VARA {current_rod} PROVAVELMENTE VAZIA! ({timeouts_atual} timeouts consecutivos)")

            # Verificar se a outra vara da dupla tamb√©m tem muitos timeouts
            if timeouts_outra >= threshold:
                print(f"üö® AMBAS VARAS DA DUPLA VAZIAS! Movendo para pr√≥xima dupla...")
                print(f"   ‚Ä¢ Vara 1: {self.rod_system['rod1_timeouts']} timeouts")
                print(f"   ‚Ä¢ Vara 2: {self.rod_system['rod2_timeouts']} timeouts")

                # üé£ SISTEMA INTELIGENTE: Marcar varas como vazias e recarregar
                print("\nüîç Ambas varas vazias - marcando para recarga...")

                # Marcar varas atuais como vazias (precisam recarga de isca)
                current_pair = self.get_current_rod_pair()
                for rod_slot in current_pair:
                    if rod_slot not in self.rod_system['empty_rods']:
                        self.rod_system['empty_rods'].append(rod_slot)

                print(f"   ‚Ä¢ Varas marcadas para recarga: {self.rod_system['empty_rods']}")

                # Detectar quantas varas ainda temos no total
                rod_count = len(self.rod_system.get('available_rods', []))

                # Se n√£o temos varas nenhuma, buscar no ba√∫
                if rod_count == 0:
                    print("‚ùå TODAS as varas quebraram! Buscando no ba√∫...")
                    if not self.search_rods_in_chest():
                        print("‚ùå Sem varas no ba√∫! Parando bot...")
                        self.running = False
                        return "no_rods"

                # Reset contadores de timeout antes de trocar dupla
                self.rod_system['rod1_timeouts'] = 0
                self.rod_system['rod2_timeouts'] = 0

                # Trocar para pr√≥xima dupla
                self.switch_rod_pair()
                return "pair_switched"

            else:
                print(f"üîÑ TENTANDO VARA {2 if current_rod == 1 else 1} DA MESMA DUPLA...")
                print(f"   ‚Ä¢ Vara {2 if current_rod == 1 else 1} tem apenas {timeouts_outra} timeouts - pode ter isca")

                # Trocar para a outra vara da dupla
                self.switch_rod_in_pair()
                return "rod_switched"

        else:
            print(f"‚è≥ Timeout isolado ({timeouts_atual}/{threshold}) - continuando com vara {current_rod}")
            return "continue"

    def update_rod_status_from_catch_viewer(self):
        """Atualizar status das varas usando dados do Catch Viewer"""
        # Esta fun√ß√£o ser√° chamada para sincronizar dados do Catch Viewer
        # O Catch Viewer j√° atualiza self.rod_status_tracking automaticamente
        pass

    def detect_rod_needs_bait(self, rod_number):
        """Detectar se uma vara espec√≠fica precisa de isca"""
        try:
            # Usar template matching para detectar vara sem isca
            import cv2
            import numpy as np
            import mss

            # Capturar tela - REFATORADO
            screen = capture_screen_safe()

            # Templates de vara sem isca
            templates_no_bait = ['varasemisca.png', 'semiscavara.png', 'semiscanam.png', 'namaosemisca.png', 'enbausi.png']

            for template_name in templates_no_bait:
                template_path = f"templates/{template_name}"
                template = load_template_safe(template_path)
                if template is not None:
                        # Template matching
                        result = cv2.matchTemplate(screen[:,:,:3], template, cv2.TM_CCOEFF_NORMED)
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        # Usar threshold unificado com Catch Viewer
                        threshold = self.get_unified_template_threshold(template_name)

                        if max_val > threshold:
                            print(f"   üéØ Vara sem isca detectada: {template_name} (conf: {max_val:.2f})")
                            return True

            return False

        except Exception as e:
            print(f"   ‚ùå Erro ao detectar vara sem isca: {e}")
            return False

    def check_empty_slots_and_verify(self):
        """Verificar slots vazios e checar se alguma vara ficou sem isca"""
        print("\nüîç VERIFICANDO SLOTS VAZIOS E STATUS DAS VARAS...")

        # Fechar invent√°rio para melhor detec√ß√£o
        if self.game_state.get('inventory_open', False):
            print("üì¶ Fechando invent√°rio para verifica√ß√£o...")
            self.close_inventory_with_delay("Auto opera√ß√£o")
            self.game_state['inventory_open'] = False

        # Verificar cada slot
        empty_slots = []
        rods_without_bait = []

        for slot in range(1, 7):
            print(f"üéØ Verificando slot {slot}...")

            # Selecionar o slot
            focus_game_window()  # Garantir foco antes de pressionar tecla
            pyautogui.press(str(slot))
            time.sleep(0.3)

            # Verificar se tem vara
            has_rod = self.detect_rod_in_slot(slot)

            if not has_rod:
                print(f"   ‚ùå Slot {slot} est√° VAZIO")
                empty_slots.append(slot)
            else:
                # Verificar se tem isca
                if self.detect_rod_needs_bait(slot):
                    print(f"   ‚ö†Ô∏è Slot {slot} tem vara SEM ISCA")
                    rods_without_bait.append(slot)
                else:
                    print(f"   ‚úÖ Slot {slot} tem vara com isca")

        # Se encontrou slots problem√°ticos, abrir TAB para melhor visualiza√ß√£o
        if empty_slots or rods_without_bait:
            print("\nüì∏ Abrindo invent√°rio (TAB) para verifica√ß√£o detalhada...")
            pyautogui.press('tab')
            time.sleep(1.0)

            # An√°lise mais detalhada com invent√°rio aberto
            print("\nüìä RESUMO DA VERIFICA√á√ÉO:")
            print(f"   ‚Ä¢ Slots vazios: {empty_slots}")
            print(f"   ‚Ä¢ Varas sem isca: {rods_without_bait}")

            # Fechar invent√°rio
            time.sleep(1.5)
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # Tomar a√ß√µes necess√°rias
            if rods_without_bait:
                print("\nüîß Iniciando recarga de varas sem isca...")
                for rod_slot in rods_without_bait:
                    self.auto_reload_rod(rod_slot)

            if len(empty_slots) >= 3:
                print("\n‚ö†Ô∏è Muitos slots vazios! Buscando varas no ba√∫...")
                self.check_and_refill_rods()

        return empty_slots, rods_without_bait

    def detect_rod_with_bait_check(self, detection):
        """
        Detecta vara e verifica isca baseado na posi√ß√£o da detec√ß√£o

        Args:
            detection: Dict com informa√ß√µes da detec√ß√£o YOLO/Template

        Returns:
            dict: {'slot': int, 'has_rod': bool, 'has_bait': bool/None}
        """
        try:
            if not detection or 'center' not in detection:
                return {'slot': None, 'has_rod': False, 'has_bait': None}

            center_x, center_y = detection['center']

            # Determinar qual slot baseado na posi√ß√£o X
            SLOT_X_RANGES = {
                1: (670, 750),   # ~709
                2: (765, 845),   # ~805
                3: (860, 940),   # ~899
                4: (950, 1030),  # ~992
                5: (1050, 1130), # ~1092
                6: (1145, 1225)  # ~1188
            }

            slot = None
            for s, (min_x, max_x) in SLOT_X_RANGES.items():
                if min_x <= center_x <= max_x:
                    slot = s
                    break

            if not slot:
                return {'slot': None, 'has_rod': True, 'has_bait': None}

            # Calcular posi√ß√£o da isca (canto superior esquerdo)
            # Offset: isca est√° ~36px √† esquerda e ~33px acima do centro
            bait_x = center_x - 36
            bait_y = center_y - 33

            # Verificar isca usando a mesma l√≥gica do teste que funciona
            has_bait = self.check_bait_at_position(bait_x, bait_y)

            return {
                'slot': slot,
                'has_rod': True,
                'has_bait': has_bait,
                'rod_center': (center_x, center_y),
                'bait_check_pos': (bait_x, bait_y)
            }

        except Exception as e:
            print(f"‚ùå Erro ao detectar vara com isca: {e}")
            return {'slot': None, 'has_rod': False, 'has_bait': None}

    def check_bait_at_position(self, x, y):
        """
        Verifica se h√° isca em uma posi√ß√£o espec√≠fica usando regi√£o 5x5

        Returns:
            bool: True se tem isca, False se n√£o tem, None se erro
        """
        try:
            # Cores alvo COM ISCA (tons brancos/claros)
            target_colors = [
                (226, 226, 226),  # #e2e2e2
                (228, 228, 236),  # #e4e4ec
                (225, 228, 233),  # #e1e4e9
                (225, 228, 234),  # #e1e4ea
                (225, 228, 232),  # #e1e4e8
                (229, 230, 230),  # #e5e6e6
                (226, 226, 227),  # #e2e2e3
                (237, 241, 245)   # #edf1f5
            ]

            # Capturar regi√£o 5x5
            region_size = 5
            screenshot = self.sct.grab({
                "top": int(y - region_size//2),
                "left": int(x - region_size//2),
                "width": region_size,
                "height": region_size
            })

            img_array = np.array(screenshot)
            bait_pixels = 0
            total_pixels = 0

            # Analisar pixels
            for py in range(min(region_size, img_array.shape[0])):
                for px in range(min(region_size, img_array.shape[1])):
                    if img_array.size > 0:
                        pixel = img_array[py, px]

                        if len(pixel) >= 3:
                            if len(pixel) == 4:  # BGRA
                                r, g, b = pixel[2], pixel[1], pixel[0]
                            else:  # RGB
                                r, g, b = pixel[0], pixel[1], pixel[2]

                            total_pixels += 1

                            # Verificar se √© cor de isca (toler√¢ncia 10)
                            for target_r, target_g, target_b in target_colors:
                                if (abs(r - target_r) <= 10 and
                                    abs(g - target_g) <= 10 and
                                    abs(b - target_b) <= 10):
                                    bait_pixels += 1
                                    break

            # Decis√£o: >50% = com isca
            if total_pixels > 0:
                percentage = (bait_pixels / total_pixels) * 100
                return percentage > 50

            return False

        except Exception as e:
            print(f"‚ùå Erro ao verificar isca na posi√ß√£o ({x},{y}): {e}")
            return None

    def analyze_inventory_rods_with_bait(self):
        """
        Analisa todas as varas no invent√°rio e seus estados de isca
        Combina detec√ß√£o YOLO de varas com an√°lise de cores para isca

        Returns:
            dict: {slot: {'has_rod': bool, 'has_bait': bool, 'position': tuple}}
        """
        try:
            results = {}

            # Primeiro detectar varas com YOLO
            detections = self.detect_objects_in_inventory()

            if not detections:
                print("‚ö†Ô∏è Nenhuma detec√ß√£o encontrada no invent√°rio")
                return results

            # Filtrar apenas varas
            rod_detections = []
            for det in detections:
                if det.get('class') in ['vara', 'vara com isca', 'vara_com_isca', 'rod']:
                    rod_detections.append(det)

            print(f"üé£ Encontradas {len(rod_detections)} varas no invent√°rio")

            # Para cada vara detectada, verificar isca
            for detection in rod_detections:
                result = self.detect_rod_with_bait_check(detection)

                if result['slot'] and result['has_rod']:
                    # Calcular posi√ß√£o da isca usando offset
                    center_x, center_y = detection.get('center', (0, 0))
                    bait_x = center_x + self.config['bait_detection']['offset']['x']  # -36
                    bait_y = center_y + self.config['bait_detection']['offset']['y']  # -34

                    # Verificar se tem isca na posi√ß√£o calculada
                    has_bait = self.check_bait_at_position(bait_x, bait_y)

                    results[result['slot']] = {
                        'has_rod': True,
                        'has_bait': has_bait if has_bait is not None else False,
                        'position': detection.get('center'),
                        'bait_check_position': (bait_x, bait_y),
                        'confidence': detection.get('confidence', 0.0)
                    }

                    print(f"üéØ Slot {result['slot']}: Vara {'COM' if has_bait else 'SEM'} isca")

            # Verificar slots vazios (sem vara detectada)
            for slot in range(1, 7):
                if slot not in results:
                    results[slot] = {
                        'has_rod': False,
                        'has_bait': None,
                        'position': None,
                        'bait_check_position': None,
                        'confidence': 0.0
                    }

            return results

        except Exception as e:
            print(f"‚ùå Erro analyze_inventory_rods_with_bait: {e}")
            return {}

    def detect_rod_in_slot(self, slot_number):
        """Detectar se h√° uma vara em um slot espec√≠fico"""
        try:
            # Posi√ß√µes dos slots
            SLOT_POSITIONS = {
                1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
                4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
            }

            if slot_number not in SLOT_POSITIONS:
                return False

            slot_x, slot_y = SLOT_POSITIONS[slot_number]

            # Usar template matching ou YOLO para detectar vara na posi√ß√£o
            import cv2
            import numpy as np
            import mss

            with mss.mss() as sct:
                # Capturar regi√£o ao redor do slot
                region = {
                    'top': slot_y - 50,
                    'left': slot_x - 50,
                    'width': 100,
                    'height': 100
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)

            # Templates de vara
            vara_templates = ['VARANOBAUCI.png', 'varacomisca.png', 'varasemisca.png', 'comiscavara.png', 'semiscavara.png', 'namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'enbausi.png']  # üéØ VARANOBAUCI primeiro

            for template_name in vara_templates:
                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path)
                    if template is not None and template.shape[0] <= screen.shape[0] and template.shape[1] <= screen.shape[1]:
                        result = cv2.matchTemplate(screen[:,:,:3], template, cv2.TM_CCOEFF_NORMED)
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        # Usar threshold unificado com Catch Viewer
                        threshold = self.get_unified_template_threshold(template_name)

                        if max_val > threshold:
                            return True

            # Se n√£o encontrou com templates, tentar detec√ß√£o por cor como fallback
            try:
                color_result = self.check_rod_bait_by_pixel_color(slot_x, slot_y, check_size=20)

                # Se encontrou qualquer cor de vara (com ou sem isca), considerar que tem vara
                if color_result and (color_result.get('has_bait') is not None):
                    return True

                # Verificar se h√° cores significativas na regi√£o (n√£o s√≥ fundo preto/vazio)
                details = color_result.get('details', {}) if color_result else {}
                if (details.get('bait_pixels', 0) > 0 or
                    details.get('no_bait_pixels', 0) > 0):
                    return True
            except:
                pass

            return False

        except Exception as e:
            print(f"   ‚ùå Erro ao detectar vara no slot {slot_number}: {e}")
            return False

    def smart_rod_switch(self):
        """Troca inteligente de vara baseada em disponibilidade de isca COM coordena√ß√£o"""

        # üéØ USAR SISTEMA DE COORDENA√á√ÉO
        return self.request_operation(
            'switching_rod',
            self._protected_rod_switch,
            context="Troca inteligente de vara"
        )

    def _protected_rod_switch(self):
        """üîí Troca de vara protegida pelo sistema de coordena√ß√£o"""
        if not hasattr(self, 'rod_status_tracking'):
            return "continue"

        available_bait = self.rod_status_tracking.get('available_with_bait', [])
        available_no_bait = self.rod_status_tracking.get('available_without_bait', [])
        broken = self.rod_status_tracking.get('broken_rods', [])

        print(f"üìä Estado geral das varas:")
        print(f"   ‚úÖ Com isca: {available_bait}")
        print(f"   ‚ö†Ô∏è Sem isca: {available_no_bait}")
        print(f"   ‚ùå Quebradas: {broken}")

        current_rod = self.get_absolute_rod_number()

        # Se temos varas com isca dispon√≠veis
        if available_bait:
            # Filtrar vara atual
            other_rods = [r for r in available_bait if r != current_rod]

            if other_rods:
                # PRIORIDADE VARANOBAUCI (rod 1) - sempre preferir se dispon√≠vel
                if 1 in other_rods:
                    target_rod = 1
                    print(f"üéØ PRIORIDADE VARANOBAUCI: Trocando para rod 1 (tem isca)")
                else:
                    # Escolher pr√≥xima vara com isca
                    if len(other_rods) >= 2:
                        # Formar nova dupla inteligente
                        new_pair = other_rods[:2]
                        print(f"üé£ Formando nova dupla inteligente: {new_pair}")

                        # Trocar para primeira vara da nova dupla
                        target_rod = new_pair[0]
                    else:
                        # S√≥ tem uma vara com isca
                        target_rod = other_rods[0]

                print(f"üîÑ Trocando para vara {target_rod} (tem isca)")
                self.switch_to_absolute_rod(target_rod)

                # Limpar timeouts
                self.rod_system['rod1_timeouts'] = 0
                self.rod_system['rod2_timeouts'] = 0

                return "rod_switched"

        # Se n√£o tem varas com isca, precisamos recarregar todas
        if len(available_no_bait) >= 4:
            print("‚ö†Ô∏è Muitas varas sem isca! Recarregamento em massa necess√°rio!")
            self.reload_all_rods()
            return "mass_reload"

        return "continue"

    def switch_to_absolute_rod(self, rod_number):
        """Trocar para uma vara espec√≠fica pelo n√∫mero absoluto (1-6)"""
        print(f"üéØ Trocando para vara {rod_number}...")

        # Mapear para sistema de duplas
        if rod_number in [1, 2]:
            self.rod_system['current_pair'] = '1-2'
            self.rod_system['current_rod'] = 1 if rod_number == 1 else 2
        elif rod_number in [3, 4]:
            self.rod_system['current_pair'] = '3-4'
            self.rod_system['current_rod'] = 1 if rod_number == 3 else 2
        elif rod_number in [5, 6]:
            self.rod_system['current_pair'] = '5-6'
            self.rod_system['current_rod'] = 1 if rod_number == 5 else 2

        # Pressionar tecla da vara
        focus_game_window()  # Garantir foco antes de trocar vara
        pyautogui.press(str(rod_number))
        
        # AGUARDAR 2 SEGUNDOS + 4 CLIQUES DEVAGAR (como solicitado para pesca)
        print("‚è∞ Aguardando 2 segundos ap√≥s troca de vara...")
        time.sleep(2.0)
        
        # 4 cliques devagar para garantir que a pesca comece corretamente
        print("üêå Executando 4 cliques devagar ap√≥s troca (1s cada)...")
        for i in range(4):
            print(f"   üêå Clique devagar {i+1}/4")
            pyautogui.click(button='left')
            time.sleep(1.0)

        print(f"‚úÖ Trocado para vara {rod_number} (dupla {self.rod_system['current_pair']})")

    def reload_all_rods(self):
        """Recarregar todas as varas sem isca"""
        if not hasattr(self, 'rod_status_tracking'):
            return

        no_bait_rods = self.rod_status_tracking.get('available_without_bait', [])

        print(f"üîß Iniciando recarga em massa de {len(no_bait_rods)} varas...")

        for rod in no_bait_rods:
            print(f"   ‚Ä¢ Recarregando vara {rod}...")
            self.switch_to_absolute_rod(rod)
            time.sleep(0.5)

            if self.auto_reload_rod(rod):
                print(f"   ‚úÖ Vara {rod} recarregada!")
            else:
                print(f"   ‚ùå Falha ao recarregar vara {rod}")

        print("‚úÖ Recarga em massa conclu√≠da!")

    def initial_inventory_check(self):
        """Verifica√ß√£o inicial ao iniciar bot - abre invent√°rio por alguns segundos"""
        print("\nüîç VERIFICA√á√ÉO INICIAL DE INVENT√ÅRIO...")

        # Abrir invent√°rio
        print("üì¶ Abrindo invent√°rio para an√°lise inicial...")
        pyautogui.press('tab')
        time.sleep(2.0)  # Dar tempo para o Catch Viewer detectar

        # Aguardar detec√ß√µes se Catch Viewer estiver rodando
        if hasattr(self, 'catch_viewer_running') and self.catch_viewer_running:
            print("üîç Aguardando detec√ß√µes do Catch Viewer...")
            for i in range(10):  # Aguardar at√© 5 segundos
                time.sleep(0.5)
                if hasattr(self, 'rod_status_tracking') and self.rod_status_tracking.get('slots'):
                    print(f"‚úÖ Detec√ß√µes encontradas ap√≥s {(i+1)*0.5:.1f}s")
                    break

        # Mostrar status detectado
        if hasattr(self, 'rod_status_tracking'):
            print("\nüìä STATUS INICIAL DAS VARAS:")
            print(f"   ‚Ä¢ Com isca: {self.rod_status_tracking.get('available_with_bait', [])}")
            print(f"   ‚Ä¢ Sem isca: {self.rod_status_tracking.get('available_without_bait', [])}")
            print(f"   ‚Ä¢ Quebradas: {self.rod_status_tracking.get('broken_rods', [])}")

            # Tomar decis√µes baseadas no status
            with_bait = self.rod_status_tracking.get('available_with_bait', [])
            without_bait = self.rod_status_tracking.get('available_without_bait', [])

            if len(with_bait) < 2:
                print("‚ö†Ô∏è Poucas varas com isca! Considerando recarga...")
                if len(without_bait) >= 2:
                    print("üîß Recarregando varas sem isca...")
                    for slot in without_bait[:2]:
                        self.auto_reload_rod(slot)

        # Fechar invent√°rio com delay adequado
        self.close_inventory_with_delay("Verifica√ß√£o inicial conclu√≠da")

        print("‚úÖ Verifica√ß√£o inicial conclu√≠da!\n")

    def apply_intelligent_rod_switching(self):
        """Aplicar troca inteligente baseada nos dados do Catch Viewer"""
        if not hasattr(self, 'rod_status_tracking'):
            return

        # S√≥ aplicar se os dados s√£o recentes (√∫ltimos 30 segundos)
        last_check = self.rod_status_tracking.get('last_inventory_check', 0)
        if time.time() - last_check > 30:
            return  # Dados muito antigos

        available_bait = self.rod_status_tracking.get('available_with_bait', [])
        current_rod = self.get_absolute_rod_number()

        # VERIFICAR SE PRECISA DE MANUTEN√á√ÉO COMPLETA
        without_bait = self.rod_status_tracking.get('available_without_bait', [])
        broken = self.rod_status_tracking.get('broken_rods', [])

        # Se muitas varas problem√°ticas, fazer manuten√ß√£o completa
        if len(without_bait) >= 3 or len(broken) >= 1:
            print(f"\nüîß MANUTEN√á√ÉO NECESS√ÅRIA: {len(without_bait)} sem isca, {len(broken)} quebradas")
            self.comprehensive_rod_management()
            return

        # Se vara atual n√£o tem isca, usar sistema de troca inteligente
        if current_rod not in available_bait:
            print(f"\nüîÑ VARA {current_rod} SEM ISCA - usando sistema inteligente...")

            if len(available_bait) >= 2:
                # M√∫ltiplas varas dispon√≠veis - troca normal
                next_rod = self.normal_intelligent_rod_switch()
                print(f"üéØ Trocado para vara {next_rod}")
            elif len(available_bait) == 1:
                # Apenas 1 vara com isca - prote√ß√£o anti-bug
                print("‚ö†Ô∏è APENAS 1 VARA COM ISCA - aplicando prote√ß√£o")
                next_rod = self.intelligent_rod_switch_with_protection()
                print(f"üõ°Ô∏è Prote√ß√£o aplicada, usando vara {next_rod}")
            else:
                # Nenhuma vara com isca - CR√çTICO
                print("‚ùå CR√çTICO: Nenhuma vara com isca!")
                self.comprehensive_rod_management()
                return

    def start_with_inventory_check(self):
        """Fun√ß√£o chamada quando F9 √© pressionado - inicia com verifica√ß√£o"""
        if not self.running:
            print("\nüöÄ INICIANDO BOT COM VERIFICA√á√ÉO INTELIGENTE...")

            # Fazer verifica√ß√£o inicial
            self.initial_inventory_check()

            # Iniciar bot normalmente
            self.running = True
            self.paused = False
            self.start_time = time.time()

            print("üé£ Bot iniciado com dados atualizados!")

            # Iniciar loop principal em thread separada
            import threading
            bot_thread = threading.Thread(target=self.main_loop, daemon=True)
            bot_thread.start()
        else:
            print("‚ö†Ô∏è Bot j√° est√° rodando!")

    def reset_timeout_counters(self):
        """üîÑ Resetar contadores de timeout quando pesca com sucesso"""
        current_rod = self.rod_system['current_rod']

        # Zerar timeouts da vara que pescou com sucesso
        if current_rod == 1:
            if self.rod_system['rod1_timeouts'] > 0:
                print(f"‚úÖ VARA 1 PESCOU! Resetando {self.rod_system['rod1_timeouts']} timeouts")
                self.rod_system['rod1_timeouts'] = 0
        else:
            if self.rod_system['rod2_timeouts'] > 0:
                print(f"‚úÖ VARA 2 PESCOU! Resetando {self.rod_system['rod2_timeouts']} timeouts")
                self.rod_system['rod2_timeouts'] = 0

        # Marcar como √∫ltima vara bem-sucedida
        self.rod_system['last_successful_rod'] = current_rod

    def ensure_game_ready_for_fishing(self):
        """Parar completamente a pesca e liberar todos os controles"""
        print("üõë [PREPARA√á√ÉO] Parando pesca e liberando controles...")
        
        # Parar flags de pesca e threads
        self.game_state['fishing_active'] = False
        self.game_state['peixe_detectado_fase_lenta'] = True  # Parar A/D e cliques
        
        # Liberar bot√µes do mouse
        try:
            if self.game_state.get('right_mouse_down', False):
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='right')
                self.game_state['right_mouse_down'] = False
            print("   üñ±Ô∏è Bot√£o direito liberado")
                
            # Liberar bot√£o esquerdo tamb√©m se estiver pressionado
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='left')
            print("   üñ±Ô∏è Bot√£o esquerdo liberado")
        except:
            pass
        
        # Liberar teclas A/D se estiverem pressionadas
        try:
            # Lista de teclas que podem estar pressionadas
            possible_keys = ['a', 'd', 'w', 's', 'shift', 'ctrl', 'alt']
            for key in possible_keys:
                pyautogui.keyUp(key)
            print("   ‚å®Ô∏è Todas as teclas liberadas")
        except:
            pass
        
        # Aguardar threads pararem completamente
        time.sleep(0.3)
        
        print("‚úÖ [PREPARA√á√ÉO] Jogo pronto para opera√ß√µes especiais")
        return True

    def update_rod_usage(self, rod_number, is_timeout=False):
        """Atualizar uso de uma vara espec√≠fica"""
        if rod_number in self.rod_system['rod_tracking']:
            rod_data = self.rod_system['rod_tracking'][rod_number]

            # Incrementar uso (pesca normal ou timeout)
            rod_data['uses'] += 1

            # Se foi timeout, contar separadamente
            if is_timeout:
                rod_data['timeouts'] += 1
                print(f"‚è±Ô∏è Timeout na vara {rod_number} (Total timeouts: {rod_data['timeouts']})")

            # Verificar se precisa recarregar (chegou em 20 usos e n√£o foi recarregada)
            if rod_data['uses'] == rod_data['initial_uses'] and not rod_data['reloaded']:
                rod_data['has_bait'] = False
                print(f"‚ö†Ô∏è Vara {rod_number} SEM ISCA! Precisa recarregar ({rod_data['uses']}/{rod_data['initial_uses']} usos)")
                return 'needs_reload'

            # Verificar se est√° perto de quebrar
            elif rod_data['uses'] >= rod_data['total_max']:
                rod_data['broken'] = True
                print(f"üíî Vara {rod_number} QUEBROU! ({rod_data['uses']}/{rod_data['total_max']} usos)")
                return 'broken'

            # Avisos
            remaining = rod_data['total_max'] - rod_data['uses']
            if remaining <= 5:
                print(f"‚ö†Ô∏è Vara {rod_number}: Apenas {remaining} usos restantes!")
            elif remaining == 10 and not rod_data['reloaded']:
                print(f"üí° Vara {rod_number}: 10 usos restantes - considere recarregar")

            # Status normal
            print(f"üé£ Vara {rod_number}: {rod_data['uses']}/{rod_data['total_max']} usos")
            return 'ok'

        return None

    def reload_rod_with_bait(self, rod_number):
        """Recarregar vara com isca"""
        if rod_number in self.rod_system['rod_tracking']:
            rod_data = self.rod_system['rod_tracking'][rod_number]

            if not rod_data['reloaded']:
                rod_data['reloaded'] = True
                rod_data['has_bait'] = True
                rod_data['total_max'] = rod_data['initial_uses'] + rod_data['reload_uses']  # 20 + 10 = 30
                print(f"‚úÖ Vara {rod_number} RECARREGADA! Agora pode usar at√© {rod_data['total_max']} vezes")
                return True
            else:
                print(f"‚ùå Vara {rod_number} j√° foi recarregada antes")
                return False

        return False

    def auto_reload_rod(self, rod_number=None):
        """üéØ SISTEMA SIMPLIFICADO: Usar drag & drop para recarregar vara espec√≠fica ou todas"""
        print(f"\nüéØ AUTO RELOAD SIMPLIFICADO...")

        # Se rod_number especificado, focar nela primeiro
        if rod_number:
            print(f"üéØ Foco na vara {rod_number}")
            # Equipar a vara espec√≠fica primeiro
            focus_game_window()  # Garantir foco antes de trocar vara
            pyautogui.press(str(rod_number))
            time.sleep(0.5)

        # Usar o sistema simplificado de drag & drop
        return self.smart_reload_rod(rod_number)

    def get_rod_status_display(self):
        """Obter status visual de todas as varas para mostrar na interface"""
        status_lines = []
        for rod_num in range(1, 7):
            if rod_num in self.rod_system['rod_tracking']:
                rod = self.rod_system['rod_tracking'][rod_num]

                # √çcones de status
                if rod['broken']:
                    icon = "üíî"
                elif not rod['has_bait']:
                    icon = "‚ö†Ô∏è"
                elif rod['uses'] >= 25:
                    icon = "üî¥"
                elif rod['uses'] >= 15:
                    icon = "üü°"
                else:
                    icon = "üü¢"

                # Barra de progresso
                max_uses = rod['total_max']
                uses = rod['uses']
                percent = (uses / max_uses) * 100
                bar_length = 10
                filled = int(bar_length * uses / max_uses)
                bar = "‚ñà" * filled + "‚ñë" * (bar_length - filled)

                # Linha de status
                bait_status = "COM ISCA" if rod['has_bait'] else "SEM ISCA"
                reload_status = "(R)" if rod['reloaded'] else ""

                status_lines.append(
                    f"{icon} Vara {rod_num}: [{bar}] {uses}/{max_uses} {bait_status} {reload_status}"
                )

        return "\n".join(status_lines)

    def detect_available_rods_initial(self):
        """üé£ Detectar varas dispon√≠veis no in√≠cio (SEM buscar no ba√∫)"""
        print("\nüîç Detectando varas no invent√°rio...")

        try:
            # Abrir invent√°rio
            focus_game_window()  # Garantir foco antes de pressionar TAB
            pyautogui.press('tab')
            time.sleep(0.8)
            self.game_state['inventory_open'] = True

            # Detectar objetos
            detections = self.detect_objects()

            # Procurar varas APENAS no invent√°rio do jogador (x < 1242)
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']
            available_rods = []

            for detection in detections:
                if detection['class'] in rod_classes:
                    # IMPORTANTE: Apenas varas no invent√°rio do jogador (esquerda da linha)
                    if detection['center'][0] < 1242:
                        slot = self.get_inventory_slot_from_position(detection['center'])
                        if slot and slot <= 6 and slot not in available_rods:
                            available_rods.append(slot)
                            print(f"   ‚úÖ Vara detectada no slot {slot}")

            # Fechar invent√°rio
            self.close_inventory_with_delay("Auto opera√ß√£o")
            self.game_state['inventory_open'] = False

            # Atualizar sistema
            self.rod_system['available_rods'] = sorted(available_rods)
            self.rod_system['initial_rod_count'] = len(available_rods)

            # Ajustar pares baseado na quantidade de varas
            if len(available_rods) >= 6:
                self.rod_system['pairs'] = [(1,2), (3,4), (5,6)]
            elif len(available_rods) >= 4:
                self.rod_system['pairs'] = [(1,2), (3,4)]
            elif len(available_rods) >= 2:
                self.rod_system['pairs'] = [(1,2)]

            return len(available_rods)

        except Exception as e:
            print(f"‚ùå Erro ao detectar varas: {e}")
            return 0

    def detect_available_rods(self):
        """üé£ SISTEMA COM TRACKING: Detectar varas dispon√≠veis com controle de detec√ß√µes m√∫ltiplas"""
        print("\nüîç DETECTANDO VARAS DISPON√çVEIS COM TRACKING...")

        try:
            # Abrir invent√°rio se n√£o estiver aberto
            if not self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                time.sleep(0.8)
                self.game_state['inventory_open'] = True

            # Detectar objetos no invent√°rio
            detections = self.detect_objects()

            # Procurar por varas de pesca
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            # üéØ TRACKING: Processar detec√ß√µes com controle de duplicatas
            rod_tracking_data = self.process_rod_detections_with_tracking(detections, rod_classes)

            # Extrair informa√ß√µes do tracking
            available_rods = rod_tracking_data['available_slots']
            empty_rods = rod_tracking_data['empty_slots']
            rods_with_bait = rod_tracking_data['baited_slots']

            # Atualizar sistema de varas COM INFORMA√á√ïES DETALHADAS
            self.rod_system['available_rods'] = sorted(available_rods)
            self.rod_system['empty_rods'] = sorted(empty_rods)
            self.rod_system['rods_with_bait'] = sorted(rods_with_bait)
            self.rod_system['initial_rod_count'] = len(available_rods)
            self.rod_system['last_rod_check'] = time.time()
            self.rod_system['rod_state_data'] = rod_tracking_data['rod_states']  # Estados detalhados

            print(f"\nüìä RESUMO DE VARAS:")
            print(f"   ‚Ä¢ Total de varas: {len(available_rods)}")
            print(f"   ‚Ä¢ Varas dispon√≠veis: {available_rods}")
            print(f"   ‚Ä¢ Varas vazias: {empty_rods}")

            return len(available_rods)

        except Exception as e:
            print(f"‚ùå Erro ao detectar varas: {e}")
            return 0

    def get_inventory_slot_from_position(self, position):
        """Determinar slot do invent√°rio baseado na posi√ß√£o X,Y - VERS√ÉO CORRIGIDA"""
        x, y = position

        # COORDENADAS DOS SLOTS 1-6 (X,Y) - COORDENADAS REAIS
        SLOT_POSITIONS = {
            1: (709, 1005),   # Slot 1
            2: (805, 1005),   # Slot 2
            3: (899, 1005),   # Slot 3
            4: (992, 1005),   # Slot 4
            5: (1092, 1005),  # Slot 5
            6: (1188, 1005)   # Slot 6
        }

        # Faixa Y v√°lida para hotbar (ajustada para Y=1005)
        hotbar_y_min = 970
        hotbar_y_max = 1040

        # Verificar se est√° na faixa Y da hotbar
        if hotbar_y_min <= y <= hotbar_y_max:
            # Encontrar o slot mais pr√≥ximo baseado na dist√¢ncia euclidiana
            closest_slot = None
            min_distance = float('inf')

            for slot_num, (slot_x, slot_y) in SLOT_POSITIONS.items():
                # Calcular dist√¢ncia euclidiana considerando X e Y
                distance = ((x - slot_x) ** 2 + (y - slot_y) ** 2) ** 0.5

                # Toler√¢ncia maior (60 pixels) para acomodar varia√ß√µes
                if distance < 60 and distance < min_distance:
                    min_distance = distance
                    closest_slot = slot_num

            if closest_slot:
                slot_x, slot_y = SLOT_POSITIONS[closest_slot]
                print(f"   üìç Vara em ({x},{y}) ‚Üí Slot {closest_slot} [centro: ({slot_x},{slot_y}), dist: {min_distance:.1f}px]")
                return closest_slot
            else:
                print(f"   ‚ùå Posi√ß√£o ({x},{y}) n√£o corresponde a nenhum slot (dist m√≠nima: {min_distance:.1f}px)")
                return None

        return None

    def is_rod_empty(self, detection):
        """Verificar se uma vara est√° vazia (sem isca) - Vers√£o com detec√ß√£o de cor"""
        try:
            # Primeiro tentar detec√ß√£o por cor
            color_result = self.is_rod_empty_by_color(detection)

            # Se n√£o conseguiu detectar por cor, usar heur√≠stica do template matching
            if hasattr(detection, 'class') and detection.get('class'):
                template_class = detection['class']
                if 'sem isca' in template_class.lower() or 'empty' in template_class.lower():
                    print(f"   üéØ Template matching: vara vazia ({template_class})")
                    return True
                elif 'com isca' in template_class.lower() or 'baited' in template_class.lower():
                    print(f"   üéØ Template matching: vara com isca ({template_class})")
                    return False

            # Usar resultado da detec√ß√£o por cor se dispon√≠vel
            return color_result

        except Exception as e:
            print(f"‚ùå Erro na verifica√ß√£o de vara vazia: {e}")
            return False  # Em caso de erro, assumir que tem isca

    def search_rods_in_chest(self):
        """üéØ Buscar varas no ba√∫ quando necess√°rio (APENAS quando varas quebram)"""
        print("\nüîç BUSCANDO VARAS DE REPOSI√á√ÉO NO BA√ö...")

        try:
            # Abrir ba√∫ se n√£o estiver aberto
            if not self.game_state.get('chest_open', False):
                print("üì¶ Abrindo ba√∫ para buscar varas de reposi√ß√£o...")
                self.open_chest_with_macro()
                time.sleep(1.5)

            # Detectar objetos
            detections = self.detect_objects()

            # Classes de varas que queremos buscar
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            rods_in_chest = []
            rods_in_inventory = []

            for detection in detections:
                if detection['class'] in rod_classes:
                    x_pos = detection['center'][0]

                    # IMPORTANTE: Usar x=1242 como linha divis√≥ria
                    if x_pos > 1242:  # Est√° no BA√ö (lado direito)
                        rods_in_chest.append(detection)
                        print(f"   üì¶ Vara no BA√ö: {detection['class']} em x={x_pos}")
                    elif x_pos < 1242:  # Est√° no invent√°rio (lado esquerdo)
                        slot = self.get_inventory_slot_from_position(detection['center'])
                        if slot and slot <= 6:
                            rods_in_inventory.append(slot)

            print(f"\nüìä Status atual:")
            print(f"   ‚Ä¢ Varas no invent√°rio: {len(rods_in_inventory)} slots {rods_in_inventory}")
            print(f"   ‚Ä¢ Varas dispon√≠veis no ba√∫: {len(rods_in_chest)}")

            # Calcular quantas varas precisamos
            slots_vazios = []
            for slot in range(1, 7):
                if slot not in rods_in_inventory:
                    slots_vazios.append(slot)

            print(f"   ‚Ä¢ Slots vazios para preencher: {slots_vazios}")

            # Transferir apenas o necess√°rio
            transferred = 0
            max_transfer = min(len(rods_in_chest), len(slots_vazios))

            if max_transfer > 0:
                print(f"\nüì• Transferindo {max_transfer} vara(s) do ba√∫...")

                for i in range(max_transfer):
                    rod = rods_in_chest[i]
                    x, y = rod['center']

                    print(f"   [{i+1}/{max_transfer}] Transferindo vara em ({x}, {y})...")

                    # Clicar com shift para transferir r√°pido
                    pyautogui.moveTo(x, y, duration=0.2)
                    time.sleep(0.1)

                    with pyautogui.hold('shift'):
                        pyautogui.click(x, y)

                    transferred += 1
                    time.sleep(0.3)

                print(f"‚úÖ {transferred} vara(s) transferida(s) com sucesso!")
            else:
                print("‚ö†Ô∏è Nenhuma vara dispon√≠vel no ba√∫ ou invent√°rio cheio")

            # Fechar ba√∫
            self.close_inventory_with_delay("Auto opera√ß√£o")
            self.game_state['chest_open'] = False

            # Re-detectar varas ap√≥s transfer√™ncia
            if transferred > 0:
                self.detect_available_rods()

            return transferred > 0

        except Exception as e:
            print(f"‚ùå Erro ao buscar varas no ba√∫: {e}")
            # Garantir que ba√∫ seja fechado
            if self.game_state.get('chest_open', False):
                pyautogui.press('tab')
                self.game_state['chest_open'] = False
            return False

    def smart_reload_rod(self, rod_slot=None):
        """üéØ M√âTODO SIMPLIFICADO: Drag & Drop isca para vara sem isca"""
        print(f"\nüéØ RECARGA SIMPLIFICADA - Drag & Drop...")

        try:
            # Abrir invent√°rio
            if not self.game_state.get('inventory_open', False):
                print("üì¶ Abrindo invent√°rio...")
                pyautogui.press('tab')
                time.sleep(0.8)
                self.game_state['inventory_open'] = True

            # Detectar objetos no invent√°rio para iscas
            print("üîç Detectando iscas dispon√≠veis...")
            detections = self.detect_objects()

            # Filtrar apenas lado do invent√°rio (esquerdo) para iscas
            inventory_detections = [d for d in detections if d.get('center', [0, 0])[0] < 1242]

            # Encontrar iscas dispon√≠veis (com prioridade)
            available_baits = []
            
            for detection in inventory_detections:
                item_class = detection.get('class', '').lower()

                # Verificar se √© isca usando prioridade configurada
                normalized_name = self.normalize_item_name(item_class)
                if hasattr(self, 'bait_priority') and normalized_name in self.bait_priority:
                    # Verificar se isca est√° habilitada
                    if hasattr(self, 'bait_enabled') and self.bait_enabled.get(normalized_name, True):
                        available_baits.append({
                            'detection': detection,
                            'name': normalized_name,
                            'priority': self.bait_priority[normalized_name]
                        })

            # USAR ROD_STATUS_TRACKING PARA VARAS SEM ISCA (mais preciso que YOLO)
            print("üîç Detectando varas sem isca via template matching...")
            rods_without_bait = []
            
            # Verificar rod_status_tracking para varas APENAS sem isca
            if hasattr(self, 'rod_status_tracking'):
                # Converter slots para posi√ß√µes
                SLOT_POSITIONS = {
                    1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
                    4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
                }
                
                # Verificar cada slot para garantir que s√≥ tem vara SEM isca
                for slot in range(1, 7):
                    is_rod_without_bait = False
                    
                    # Verificar no tracking direto
                    if slot in self.rod_status_tracking.get('available_without_bait', []):
                        is_rod_without_bait = True
                    
                    # Verificar no status detalhado dos slots
                    if 'slots' in self.rod_status_tracking:
                        slot_info = self.rod_status_tracking['slots'].get(slot)
                        if slot_info:
                            status = slot_info.get('status', '').upper()
                            # APENAS se status √© explicitamente "SEM ISCA"
                            if status == 'SEM ISCA':
                                is_rod_without_bait = True
                            # Se tem "COM ISCA", NUNCA adicionar
                            elif status == 'COM ISCA':
                                is_rod_without_bait = False
                    
                    # Garantir que N√ÉO est√° na lista de varas com isca
                    if slot in self.rod_status_tracking.get('available_with_bait', []):
                        is_rod_without_bait = False
                    
                    # S√≥ adicionar se confirmado como vara sem isca
                    if is_rod_without_bait and slot in SLOT_POSITIONS:
                        slot_pos = SLOT_POSITIONS[slot]
                        print(f"   ‚úÖ Slot {slot}: Confirmado como vara SEM isca")
                        rods_without_bait.append({
                            'center': slot_pos,
                            'class': 'vara sem isca',
                            'slot': slot
                        })
                    elif slot in SLOT_POSITIONS:
                        # Log do motivo da exclus√£o
                        slot_info = self.rod_status_tracking.get('slots', {}).get(slot, {})
                        status = slot_info.get('status', 'Desconhecido')
                        print(f"   ‚ùå Slot {slot}: Ignorado - Status: {status}")
                        
            # Se rod_status_tracking n√£o tem dados, fallback para YOLO
            if not rods_without_bait:
                print("‚ö†Ô∏è Fallback: usando detec√ß√£o YOLO para varas sem isca...")
                for detection in inventory_detections:
                    item_class = detection.get('class', '').lower()
                    if ('varasemisca' in item_class or 'semiscavara' in item_class or 'semiscanam' in item_class or 'namaosemisca' in item_class or
                          ('vara' in item_class and 'comisca' not in item_class and 'quebrada' not in item_class and 'namaocomisca' not in item_class and 'comiscanamao' not in item_class)):
                        rods_without_bait.append(detection)

            print(f"   üìä Encontrado: {len(available_baits)} iscas, {len(rods_without_bait)} varas sem isca")

            if not available_baits:
                print("   ‚ùå Nenhuma isca dispon√≠vel!")
                self.close_inventory_with_delay("Sem iscas")
                return False

            if not rods_without_bait:
                print("   ‚úÖ Todas as varas j√° t√™m isca!")
                self.close_inventory_with_delay("Todas com isca")
                return True

            # Ordenar iscas por prioridade (menor n√∫mero = maior prioridade)
            available_baits.sort(key=lambda x: x['priority'])

            # üéØ DRAG & DROP MELHORADO: Garantir que todas as varas sejam recarregadas
            reloads_done = 0
            max_reloads = min(len(available_baits), len(rods_without_bait))
            
            # Avisar se h√° varas sem isca suficientes
            if len(rods_without_bait) > len(available_baits):
                print(f"   ‚ö†Ô∏è ATEN√á√ÉO: {len(rods_without_bait)} varas sem isca, mas apenas {len(available_baits)} iscas dispon√≠veis!")
                print(f"   üìã Apenas {max_reloads} varas ser√£o recarregadas agora")

            for i in range(max_reloads):
                bait = available_baits[i]
                rod = rods_without_bait[i]

                bait_pos = bait['detection']['center']
                rod_pos = rod['center']

                print(f"   üé£ [{i+1}/{max_reloads}] Drag & Drop: {bait['name']} ‚Üí vara sem isca")
                print(f"      ü•© Isca: {bait_pos} ‚Üí üé£ Vara: {rod_pos}")

                # DRAG & DROP: Arrastar isca para vara
                focus_game_window()  # Garantir foco antes do drag
                pyautogui.drag(bait_pos[0], bait_pos[1],
                              rod_pos[0], rod_pos[1],
                              duration=0.5)
                time.sleep(0.4)  # ‚úÖ OTIMIZADO: Reduzido de 0.8s para 0.4s

                reloads_done += 1

            print(f"   ‚úÖ {reloads_done} varas recarregadas com Drag & Drop!")
            
            # Verificar se ainda h√° varas sem isca
            remaining_rods = len(rods_without_bait) - reloads_done
            if remaining_rods > 0:
                print(f"   ‚ö†Ô∏è ATEN√á√ÉO: {remaining_rods} varas ainda sem isca!")
                print(f"   üí° Sugest√£o: Busque mais iscas no ba√∫ ou aguarde pr√≥xima execu√ß√£o")

            # Fechar invent√°rio
            self.close_inventory_with_delay("Recarga conclu√≠da")
            self.game_state['inventory_open'] = False

            return reloads_done > 0

        except Exception as e:
            print(f"   ‚ùå Erro na recarga simplificada: {e}")
            # Garantir que invent√°rio seja fechado
            if self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                self.game_state['inventory_open'] = False
            return False

    def check_and_manage_rods(self):
        """üéØ Sistema de gerenciamento de varas (busca no ba√∫ APENAS quando quebram)"""
        print("\nüé£ GERENCIAMENTO DE VARAS QUEBRADAS...")

        # Detectar varas dispon√≠veis
        rod_count = self.detect_available_rods()

        # S√≥ buscar no ba√∫ se tiver MUITO poucas varas (quando quebram)
        # N√ÉO buscar automaticamente s√≥ porque tem menos de 6
        if rod_count == 0:
            print("‚ùå TODAS AS VARAS QUEBRARAM! Buscando reposi√ß√£o no ba√∫...")
            if self.search_rods_in_chest():
                rod_count = self.detect_available_rods()
                if rod_count == 0:
                    print("‚ùå Sem varas no ba√∫! Imposs√≠vel continuar!")
                    return False

        # Recarregar varas vazias (sem isca) usando sistema autom√°tico
        print("\nüîß Verificando e recarregando varas sem isca...")

        # Abrir invent√°rio para verificar status das varas
        if not self.game_state.get('inventory_open', False):
            focus_game_window()  # Garantir foco antes de pressionar TAB
            pyautogui.press('tab')
            time.sleep(0.8)
            self.game_state['inventory_open'] = True

        # Verificar status atual de todas as varas (1-6)
        rod_status = {}
        rod_positions = {
            1: [709, 1005], 2: [805, 1005], 3: [899, 1005],
            4: [992, 1005], 5: [1092, 1005], 6: [1188, 1005]
        }

        for i in range(1, 7):
            if i in rod_positions:
                has_bait = self.detect_rod_with_bait_at_position(
                    rod_positions[i][0], rod_positions[i][1]
                )
                rod_status[i] = "with_bait" if has_bait else "no_bait"

        # Usar sistema autom√°tico de recarga
        self.auto_reload_rods_without_bait(rod_status)

        # Fechar invent√°rio
        if self.game_state.get('inventory_open', False):
            pyautogui.press('tab')
            time.sleep(0.5)
            self.game_state['inventory_open'] = False

        # Ajustar sistema de pares baseado nas varas dispon√≠veis
        if rod_count < 6:
            print(f"\n‚öôÔ∏è Ajustando sistema para {rod_count} varas...")
            if rod_count >= 4:
                self.rod_system['pairs'] = [(1,2), (3,4)]
                print("   ‚Ä¢ Usando 2 pares: (1,2) e (3,4)")
            elif rod_count >= 2:
                self.rod_system['pairs'] = [(1,2)]
                print("   ‚Ä¢ Usando 1 par: (1,2)")
            else:
                print("   ‚ùå Varas insuficientes!")
                return False

        return True

    def get_random_delay(self, min_val, max_val):
        """Gerar delay aleat√≥rio entre min e max"""
        import random
        return random.uniform(min_val, max_val)

    def apply_reaction_time(self):
        """Tempo de rea√ß√£o desabilitado para m√°xima velocidade"""
        return  # Fun√ß√£o desabilitada para m√°xima efici√™ncia na pesca

    def check_natural_break(self):
        """Verificar se √© hora de fazer uma pausa natural"""
        if not self.anti_detection['enabled'] or not self.anti_detection['natural_breaks']['enabled']:
            return False

        breaks = self.anti_detection['natural_breaks']

        # Inicializar last_break_time na primeira verifica√ß√£o
        if breaks['last_break_time'] == 0:
            breaks['last_break_time'] = time.time()
            return False  # N√£o pausar logo no in√≠cio

        # Verificar por tempo
        if breaks['mode'] == 'time':
            time_since_break = time.time() - breaks['last_break_time']
            if time_since_break >= breaks['time_interval'] * 60:  # Converter minutos para segundos
                return True

        # Verificar por pescas
        elif breaks['mode'] == 'catches':
            if breaks['catches_since_break'] >= breaks['catches_interval']:
                return True

        return False

    def release_all_keys(self):
        """Liberar todos os bot√µes e teclas antes de pausas"""
        try:
            print("   üîÑ Liberando todas as teclas e bot√µes...")

            # Liberar bot√µes do mouse
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='right')
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='left')
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='middle')

            # Liberar teclas comuns do jogo
            keys_to_release = ['a', 'd', 'w', 's', 'shift', 'ctrl', 'alt', 'space']
            for key in keys_to_release:
                try:
                    keyboard.release(key)
                except:
                    pass  # Ignorar erros se tecla n√£o estiver pressionada

            time.sleep(0.2)
            print("   ‚úÖ Todas as teclas liberadas")

        except Exception as e:
            print(f"   ‚ö†Ô∏è Erro ao liberar teclas: {e}")

    def toggle_anti_detection(self):
        """Alternar sistema anti-detec√ß√£o via hotkey"""
        try:
            current_status = self.anti_detection['enabled']
            self.anti_detection['enabled'] = not current_status

            status_text = "HABILITADO" if self.anti_detection['enabled'] else "DESABILITADO"
            print(f"\nüõ°Ô∏è Sistema Anti-Detec√ß√£o: {status_text}")

            if self.anti_detection['enabled']:
                breaks = self.anti_detection['natural_breaks']
                if breaks['enabled']:
                    if breaks['mode'] == 'time':
                        print(f"   ‚è∞ Pausas a cada {breaks['time_interval']} minutos")
                    else:
                        print(f"   üé£ Pausas a cada {breaks['catches_interval']} pescas")
                else:
                    print("   üîß Apenas varia√ß√µes de timing ativas")
            else:
                print("   üöÄ Modo performance - sem pausas ou varia√ß√µes")

            # Salvar no config
            try:
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                print("   üíæ Configura√ß√£o salva")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Erro ao salvar config: {e}")

        except Exception as e:
            print(f"‚ùå Erro ao alternar anti-detec√ß√£o: {e}")

    def execute_natural_break(self):
        """Executar uma pausa natural"""
        if not self.anti_detection['enabled'] or not self.anti_detection['natural_breaks']['enabled']:
            return

        breaks = self.anti_detection['natural_breaks']

        # Calcular dura√ß√£o da pausa
        pause_duration = self.get_random_delay(
            breaks['pause_duration_min'],
            breaks['pause_duration_max']
        )

        print(f"\n‚òï PAUSA NATURAL - Simulando comportamento humano...")
        print(f"   ‚Ä¢ Dura√ß√£o: {pause_duration:.1f} segundos")
        print(f"   ‚Ä¢ Motivo: {'Tempo' if breaks['mode'] == 'time' else 'Quantidade de pescas'}")

        # Soltar todos os bot√µes antes da pausa
        self.release_all_keys()

        # Executar a pausa
        start_time = time.time()
        while time.time() - start_time < pause_duration and self.running:
            if not self.running:  # Permitir interrup√ß√£o
                break
            time.sleep(0.5)

        # Atualizar contadores
        breaks['last_break_time'] = time.time()
        breaks['catches_since_break'] = 0

        print("   ‚úÖ Pausa natural conclu√≠da, retomando...")

    def check_micro_pause(self):
        """Micro pausas REMOVIDAS completamente para m√°xima performance"""
        pass  # Fun√ß√£o completamente removida

    def get_click_delay(self):
        """Obter delay variado para cliques"""
        if not self.anti_detection['enabled'] or not self.anti_detection['click_variation']['enabled']:
            return self.anti_detection['click_variation']['base_delay']

        return self.get_random_delay(
            self.anti_detection['click_variation']['min_delay'],
            self.anti_detection['click_variation']['max_delay']
        )

    def get_movement_duration(self, movement_type):
        """Dura√ß√µes fixas otimizadas para m√°xima efici√™ncia na pesca"""
        # Valores otimizados sem varia√ß√£o para melhor performance
        return 1.4 if movement_type == 'a' else 1.0

    def get_movement_pause(self):
        """Pausa m√≠nima entre movimentos A-D para m√°xima efici√™ncia"""
        return 0.01  # Pausa m√≠nima para melhor performance na pesca

    def is_in_inventory(self, detection):
        """Verificar se detec√ß√£o est√° no invent√°rio do jogador (x < 1242)"""
        if isinstance(detection, dict):
            # Formato com 'center'
            if 'center' in detection:
                return detection['center'][0] < 1242
            # Formato com 'x' diretamente
            elif 'x' in detection:
                return detection['x'] < 1242
        return False

    def is_in_chest(self, detection):
        """Verificar se detec√ß√£o est√° no ba√∫ (x > 1242)"""
        if isinstance(detection, dict):
            # Formato com 'center'
            if 'center' in detection:
                return detection['center'][0] > 1242
            # Formato com 'x' diretamente
            elif 'x' in detection:
                return detection['x'] > 1242
        return False

    def detect_color_in_region(self, region, target_color, tolerance=30):
        """
        Detectar se uma cor espec√≠fica est√° presente em uma regi√£o da tela - THREAD SAFE

        Args:
            region: (x, y, width, height) regi√£o para verificar
            target_color: (B, G, R) cor alvo em formato BGR
            tolerance: toler√¢ncia para a cor (0-255)

        Returns:
            bool: True se cor foi encontrada
        """
        try:
            import cv2
            import numpy as np
            import mss

            # THREAD SAFETY: Criar inst√¢ncia MSS espec√≠fica para esta chamada
            x, y, w, h = region
            with mss.mss() as sct:
                screenshot = sct.grab({
                    "top": y, "left": x,
                    "width": w, "height": h
                })

            # Converter para OpenCV
            img_array = np.array(screenshot)
            if img_array.shape[2] == 4:  # BGRA
                img_bgr = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
            else:
                img_bgr = img_array

            # Criar m√°scara para a cor alvo
            lower_bound = np.array([max(0, target_color[0] - tolerance),
                                  max(0, target_color[1] - tolerance),
                                  max(0, target_color[2] - tolerance)])

            upper_bound = np.array([min(255, target_color[0] + tolerance),
                                  min(255, target_color[1] + tolerance),
                                  min(255, target_color[2] + tolerance)])

            # Aplicar m√°scara
            mask = cv2.inRange(img_bgr, lower_bound, upper_bound)

            # Verificar se encontrou pixels da cor
            color_pixels = cv2.countNonZero(mask)
            total_pixels = w * h
            color_percentage = (color_pixels / total_pixels) * 100

            print(f"üé® Cor detectada: {color_percentage:.1f}% da regi√£o")

            return color_percentage > 1.0  # Se mais de 1% √© da cor alvo

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o de cor: {e}")
            return False

    def get_dominant_color(self, region, num_colors=3):
        """
        Obter cores dominantes em uma regi√£o da tela

        Args:
            region: (x, y, width, height) regi√£o para analisar
            num_colors: n√∫mero de cores dominantes para retornar

        Returns:
            list: Lista de cores dominantes em formato [(B,G,R), ...]
        """
        try:
            import cv2
            import numpy as np
            try:
                from sklearn.cluster import KMeans
            except ImportError:
                print("‚ö†Ô∏è sklearn n√£o instalado - k-means clustering desabilitado")
                return False

            # Capturar regi√£o
            x, y, w, h = region
            screenshot = self.sct.grab({
                "top": y, "left": x,
                "width": w, "height": h
            })

            # Converter para OpenCV
            img_array = np.array(screenshot)
            if img_array.shape[2] == 4:  # BGRA
                img_bgr = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
            else:
                img_bgr = img_array

            # Redimensionar para acelerar processamento
            img_small = cv2.resize(img_bgr, (50, 50))

            # Achatar imagem para K-means
            pixels = img_small.reshape((-1, 3))

            # K-means clustering para encontrar cores dominantes
            kmeans = KMeans(n_clusters=num_colors, random_state=42, n_init=10)
            kmeans.fit(pixels)

            # Obter cores dominantes
            dominant_colors = kmeans.cluster_centers_.astype(int)

            print(f"üé® Cores dominantes encontradas: {len(dominant_colors)}")
            for i, color in enumerate(dominant_colors):
                print(f"   Cor {i+1}: BGR({color[0]}, {color[1]}, {color[2]})")

            return [tuple(color) for color in dominant_colors]

        except Exception as e:
            print(f"‚ùå Erro ao obter cores dominantes: {e}")
            return []

    def temporarily_unequip_rod_for_detection(self, slot_number):
        """üé£ Temporariamente remove vara da m√£o para detec√ß√£o adequada"""
        try:
            print(f"üîÑ Removendo vara do slot {slot_number} da m√£o temporariamente...")

            # Pressionar tecla do slot para remover da m√£o
            pyautogui.press(str(slot_number))
            time.sleep(0.5)  # Aguardar vara sair da m√£o

            return True

        except Exception as e:
            print(f"‚ùå Erro ao remover vara da m√£o: {e}")
            return False

    def check_rod_bait_by_pixel_color(self, slot_x, slot_y, check_size=None):
        """
        üé® Detecta se h√° isca na vara verificando cores espec√≠ficas

        Cores de refer√™ncia:
        - COM ISCA: #e4e4ec (228, 228, 236) - cinza bem claro
        - SEM ISCA: #848484 (132, 132, 132) - cinza m√©dio
        - SEM ISCA: #545459 (84, 84, 89) - cinza escuro

        Args:
            slot_x, slot_y: Coordenadas do centro do slot da vara
            check_size: Tamanho da √°rea ao redor do ponto para verificar

        Returns:
            dict: {'has_bait': bool, 'color_detected': str, 'confidence': float}
        """
        try:
            # Carregar configura√ß√µes do config.json
            bait_config = self.config.get('bait_detection', {})

            if not bait_config.get('enabled', True):
                return {
                    'has_bait': None,
                    'color_detected': 'detec√ß√£o desabilitada',
                    'confidence': 0.0
                }

            # Cores de refer√™ncia em RGB do config (agora s√£o listas)
            has_bait_list = bait_config.get('colors', {}).get('has_bait', [])
            bait_colors = []

            # Extrair todas as cores "com isca"
            for bait_cfg in has_bait_list:
                if isinstance(bait_cfg, dict) and 'rgb' in bait_cfg:
                    bait_colors.append(tuple(bait_cfg['rgb']))

            # Fallback se n√£o houver cores configuradas
            if not bait_colors:
                bait_colors = [
                    (226, 226, 226),  # #e2e2e2 - COM isca (padr√£o)
                    (228, 228, 236),  # #e4e4ec - COM isca (alternativa)
                ]

            no_bait_colors_cfg = bait_config.get('colors', {}).get('no_bait', [])
            no_bait_colors = []

            # Extrair todas as cores "sem isca"
            for no_bait_cfg in no_bait_colors_cfg:
                if isinstance(no_bait_cfg, dict) and 'rgb' in no_bait_cfg:
                    no_bait_colors.append(tuple(no_bait_cfg['rgb']))

            if not no_bait_colors:  # Fallback se config estiver vazia
                no_bait_colors = [
                    (132, 132, 132),  # #848484 - SEM isca (cinza m√©dio)
                    (84, 84, 89),      # #545459 - SEM isca (cinza escuro)
                ]

            tolerance = bait_config.get('tolerance', 15)
            check_size = check_size or bait_config.get('check_region_size', 10)

            # Regi√£o espec√≠fica onde o indicador de isca aparece
            offset_cfg = bait_config.get('offset', {})
            offset_x = offset_cfg.get('x', 15)
            offset_y = offset_cfg.get('y', -15)

            # Capturar regi√£o espec√≠fica onde o indicador aparece
            screenshot = self.sct.grab({
                "top": slot_y + offset_y - check_size//2,
                "left": slot_x + offset_x - check_size//2,
                "width": check_size,
                "height": check_size
            })

            # Converter para numpy array
            img_array = np.array(screenshot)

            # Contadores para cada tipo de cor
            bait_pixels = 0
            no_bait_pixels = 0
            total_pixels = 0

            # Dicion√°rios para contar cores espec√≠ficas
            pixel_colors = {}
            detected_bait_colors = {}
            detected_no_bait_colors = {}

            # Verificar cada pixel na regi√£o
            for y in range(img_array.shape[0]):
                for x in range(img_array.shape[1]):
                    pixel = img_array[y, x]
                    # Converter BGRA para RGB
                    if len(pixel) == 4:
                        r, g, b = pixel[2], pixel[1], pixel[0]
                    else:
                        r, g, b = pixel[0], pixel[1], pixel[2]

                    total_pixels += 1

                    # Registrar cor do pixel
                    hex_color = f"#{r:02x}{g:02x}{b:02x}"
                    pixel_colors[hex_color] = pixel_colors.get(hex_color, 0) + 1

                    # Verificar se √© alguma cor de isca
                    is_bait_color = False
                    for bait_color in bait_colors:
                        if (abs(r - bait_color[0]) <= tolerance and
                            abs(g - bait_color[1]) <= tolerance and
                            abs(b - bait_color[2]) <= tolerance):
                            bait_pixels += 1
                            is_bait_color = True
                            bait_hex = f"#{bait_color[0]:02x}{bait_color[1]:02x}{bait_color[2]:02x}"
                            detected_bait_colors[bait_hex] = detected_bait_colors.get(bait_hex, 0) + 1
                            break

                    # Verificar se √© cor de sem isca (apenas se n√£o for cor de isca)
                    if not is_bait_color:
                        for no_bait_color in no_bait_colors:
                            if (abs(r - no_bait_color[0]) <= tolerance and
                                abs(g - no_bait_color[1]) <= tolerance and
                                abs(b - no_bait_color[2]) <= tolerance):
                                no_bait_pixels += 1
                                no_bait_hex = f"#{no_bait_color[0]:02x}{no_bait_color[1]:02x}{no_bait_color[2]:02x}"
                                detected_no_bait_colors[no_bait_hex] = detected_no_bait_colors.get(no_bait_hex, 0) + 1
                                break

            # Calcular confian√ßa baseada na propor√ß√£o de pixels detectados
            if total_pixels > 0:
                bait_confidence = bait_pixels / total_pixels
                no_bait_confidence = no_bait_pixels / total_pixels

                # Preparar informa√ß√µes detalhadas
                top_colors = sorted(pixel_colors.items(), key=lambda x: x[1], reverse=True)[:5]

                print(f"   üé® DETALHES DA REGI√ÉO {check_size}x{check_size}:")
                print(f"      üìä Total de pixels: {total_pixels}")
                print(f"      ‚úÖ Pixels com isca: {bait_pixels}")
                print(f"      ‚ùå Pixels sem isca: {no_bait_pixels}")
                print(f"      üìà Confian√ßa com isca: {bait_confidence:.2%}")
                print(f"      üìâ Confian√ßa sem isca: {no_bait_confidence:.2%}")

                if detected_bait_colors:
                    print(f"      üü¢ Cores COM ISCA detectadas:")
                    for color, count in detected_bait_colors.items():
                        print(f"         ‚Ä¢ {color}: {count} pixels")

                if detected_no_bait_colors:
                    print(f"      üî¥ Cores SEM ISCA detectadas:")
                    for color, count in detected_no_bait_colors.items():
                        print(f"         ‚Ä¢ {color}: {count} pixels")

                print(f"      üé® Top 5 cores na regi√£o:")
                for i, (color, count) in enumerate(top_colors, 1):
                    print(f"         {i}. {color} ({count} pixels)")

                # Decis√£o baseada em qual cor tem mais pixels
                if bait_pixels > no_bait_pixels:
                    detected_colors = ', '.join(detected_bait_colors.keys()) if detected_bait_colors else 'cores com isca'
                    return {
                        'has_bait': True,
                        'color_detected': detected_colors,
                        'confidence': bait_confidence,
                        'details': {
                            'bait_pixels': bait_pixels,
                            'no_bait_pixels': no_bait_pixels,
                            'total_pixels': total_pixels,
                            'detected_bait_colors': detected_bait_colors,
                            'detected_no_bait_colors': detected_no_bait_colors,
                            'top_colors': dict(top_colors)
                        }
                    }
                elif no_bait_pixels > 0:
                    detected_colors = ', '.join(detected_no_bait_colors.keys()) if detected_no_bait_colors else 'cores sem isca'
                    return {
                        'has_bait': False,
                        'color_detected': detected_colors,
                        'confidence': no_bait_confidence,
                        'details': {
                            'bait_pixels': bait_pixels,
                            'no_bait_pixels': no_bait_pixels,
                            'total_pixels': total_pixels,
                            'detected_bait_colors': detected_bait_colors,
                            'detected_no_bait_colors': detected_no_bait_colors,
                            'top_colors': dict(top_colors)
                        }
                    }

            # Se n√£o detectou cores espec√≠ficas, retornar incerto
            top_colors = sorted(pixel_colors.items(), key=lambda x: x[1], reverse=True)[:5]
            print(f"   üé® DETALHES DA REGI√ÉO {check_size}x{check_size}:")
            print(f"      üìä Total de pixels: {total_pixels}")
            print(f"      ‚ö†Ô∏è Nenhuma cor conhecida detectada")
            print(f"      üé® Top 5 cores na regi√£o:")
            for i, (color, count) in enumerate(top_colors, 1):
                print(f"         {i}. {color} ({count} pixels)")

            return {
                'has_bait': None,
                'color_detected': 'nenhuma cor espec√≠fica',
                'confidence': 0.0,
                'details': {
                    'bait_pixels': bait_pixels,
                    'no_bait_pixels': no_bait_pixels,
                    'total_pixels': total_pixels,
                    'detected_bait_colors': detected_bait_colors,
                    'detected_no_bait_colors': detected_no_bait_colors,
                    'top_colors': dict(top_colors)
                }
            }

        except Exception as e:
            print(f"‚ùå Erro ao verificar cor da isca: {e}")
            return {
                'has_bait': None,
                'color_detected': 'erro',
                'confidence': 0.0
            }

    def is_rod_empty_by_color(self, detection, check_equipped=True):
        """
        Verificar se vara est√° vazia usando detec√ß√£o de cor
        VARA COM ISCA = tem quadradinho branco
        VARA SEM ISCA = n√£o tem quadradinho branco

        MELHORADO: Remove vara da m√£o temporariamente se necess√°rio e REEQUIPA ap√≥s detec√ß√£o
        RESPEITA GAME_STATE: N√£o interfere com pesca, chest operations, feeding
        """
        # VERIFICA√á√ÉO CR√çTICA: N√£o interferir com opera√ß√µes em andamento
        if (self.game_state.get('fishing_active', False) or
            self.game_state.get('chest_open', False) or
            self.game_state.get('action_in_progress', False)):
            print("‚ö†Ô∏è Opera√ß√£o em andamento - usando detec√ß√£o simples sem reequipamento")
            check_equipped = False  # N√£o remover vara da m√£o se h√° opera√ß√£o ativa

        rod_was_equipped = False
        slot_number = None

        try:
            # Obter regi√£o da vara detectada
            if 'center' in detection:
                center_x, center_y = detection['center']
            else:
                center_x, center_y = detection['x'], detection['y']

            # Se vara estiver na m√£o, remover temporariamente para detec√ß√£o correta
            if check_equipped and hasattr(self, 'current_rod_slot'):
                slot_from_pos = self.get_inventory_slot_from_position((center_x, center_y))
                if slot_from_pos == self.current_rod_slot:
                    print(f"üéØ Vara do slot {slot_from_pos} est√° na m√£o, removendo temporariamente...")
                    rod_was_equipped = True
                    slot_number = slot_from_pos
                    self.temporarily_unequip_rod_for_detection(slot_from_pos)
                    time.sleep(0.3)  # Aguardar atualiza√ß√£o visual

            # Fazer detec√ß√£o normal (sem fundo azul)
            print(f"   ‚¨õ Detectando quadrado branco em posi√ß√£o normal")
            result = self.detect_white_square_normal(center_x, center_y)

            return result

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o por cor: {e}")
            return False  # Em caso de erro, assumir que tem isca

        finally:
            # CR√çTICO: Sempre reequipar a vara se ela estava na m√£o antes
            if rod_was_equipped and slot_number:
                # Verificar se ainda √© seguro reequipar (n√£o interfere com opera√ß√µes)
                if not (self.game_state.get('fishing_active', False) or
                       self.game_state.get('chest_open', False)):
                    print(f"üîÑ Reequipando vara no slot {slot_number}...")
                    pyautogui.press(str(slot_number))
                    time.sleep(0.3)  # Aguardar vara voltar para a m√£o
                    print(f"‚úÖ Vara do slot {slot_number} reequipada com sucesso")
                else:
                    print(f"‚ö†Ô∏è Pulando reequipamento - opera√ß√£o cr√≠tica em andamento")
                    # Atualizar state para refletir que vara n√£o est√° mais na m√£o
                    if hasattr(self, 'current_rod_slot') and self.current_rod_slot == slot_number:
                        print(f"üîÑ Atualizando current_rod_slot (vara removida)")
                        # Vara foi removida mas n√£o pode ser reequipada agora

    def detect_equipped_slot_blue(self, region):
        """Detectar se slot tem fundo azul (item equipado)"""
        try:
            # Analisar cores dominantes da regi√£o para encontrar azul
            dominant_colors = self.get_dominant_color(region, num_colors=5)

            if not dominant_colors:
                return False

            # Verificar se alguma das cores dominantes √© azul
            for color in dominant_colors:
                b, g, r = color

                # Crit√©rio para azul: componente azul > verde e vermelho
                if b > g + 20 and b > r + 20 and b > 100:
                    print(f"   üîµ Cor azul dominante detectada: BGR({b}, {g}, {r})")
                    return True

                # Tamb√©m testar cores t√≠picas de slot equipado (tons azul-acinzentados)
                if 80 <= b <= 200 and 60 <= g <= 150 and 30 <= r <= 100:
                    if b >= g and b >= r:  # Azul √© predominante
                        print(f"   üîµ Slot equipado detectado: BGR({b}, {g}, {r})")
                        return True

            print(f"   ‚¨õ Slot n√£o equipado - sem tons azuis dominantes")
            return False

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o do fundo azul: {e}")
            return False

    def detect_white_square_on_blue_background(self, center_x, center_y):
        """Detectar quadradinho branco em fundo azul (vara equipada)"""
        try:
            # Regi√£o menor e mais focada para evitar interfer√™ncia do azul
            region = (center_x - 10, center_y - 10, 20, 20)

            # Branco mais contrastante para destacar do azul
            white_colors = [
                (255, 255, 255),  # Branco puro - mais vis√≠vel no azul
                (245, 245, 245),  # Branco quase puro
                (235, 235, 235)   # Branco levemente off
            ]

            # Usar toler√¢ncia menor para evitar confundir com reflexos azuis
            for white_color in white_colors:
                if self.detect_color_in_region(region, white_color, tolerance=15):
                    print(f"   ‚¨ú Quadradinho branco detectado em fundo AZUL - Vara COM isca")
                    return False  # Tem isca

            print(f"   ‚ö´ Quadradinho branco N√ÉO detectado em fundo azul - Vara VAZIA")
            return True  # Sem isca

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o em fundo azul: {e}")
            return False

    def detect_white_square_normal(self, center_x, center_y):
        """Detectar quadradinho branco em fundo normal (vara n√£o equipada)"""
        try:
            # Regi√£o normal para detec√ß√£o
            region = (center_x - 15, center_y - 15, 30, 30)

            # COR BRANCA do quadradinho indicador (BGR format)
            white_colors = [
                (255, 255, 255),  # Branco puro
                (240, 240, 240),  # Branco levemente off
                (250, 250, 250),  # Branco quase puro
                (230, 230, 230)   # Branco acinzentado
            ]

            # Verificar se tem quadradinho branco (indica isca)
            for white_color in white_colors:
                if self.detect_color_in_region(region, white_color, tolerance=25):
                    print(f"   ‚¨ú Quadradinho branco detectado em fundo normal - Vara COM isca")
                    return False  # Tem isca

            print(f"   ‚ö´ Quadradinho branco N√ÉO detectado em fundo normal - Vara VAZIA")
            return True  # Sem isca

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o em fundo normal: {e}")
            return False

    def detect_fish_by_color(self, region=None):
        """
        Detectar peixes no invent√°rio usando cores caracter√≠sticas
        """
        try:
            # Regi√£o padr√£o do invent√°rio se n√£o especificada
            if region is None:
                region = (600, 400, 642, 400)  # Lado esquerdo da tela (invent√°rio)

            # Cores t√≠picas de peixes
            fish_colors = [
                (180, 160, 140),  # Salm√£o/rosa
                (120, 140, 160),  # Azul/cinza (outros peixes)
                (200, 180, 160),  # Bege/dourado
                (100, 120, 140)   # Cinza azulado
            ]

            fish_count = 0
            for fish_color in fish_colors:
                if self.detect_color_in_region(region, fish_color, tolerance=50):
                    fish_count += 1

            print(f"üêü Detec√ß√£o por cor: {fish_count} tipos de peixe encontrados")
            return fish_count > 0

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o de peixes por cor: {e}")
            return False

    def test_bait_color_detection(self):
        """üß™ Teste aprimorado de detec√ß√£o de isca por cor (#e4e4ec vs #848484/#545459)"""
        print("\nüß™ TESTE DE DETEC√á√ÉO DE ISCA POR COR")
        print("="*70)
        print("üìç Cores alvo:")
        print("   ‚Ä¢ COM ISCA: #e4e4ec (228, 228, 236) - cinza bem claro")
        print("   ‚Ä¢ SEM ISCA: #848484 (132, 132, 132) - cinza m√©dio")
        print("   ‚Ä¢ SEM ISCA: #545459 (84, 84, 89) - cinza escuro")
        print("="*70)

        try:
            # Abrir invent√°rio
            print("\nüì¶ Abrindo invent√°rio para teste...")
            pyautogui.press('tab')
            time.sleep(1)

            # Detectar todas as varas
            detections = self.detect_objects()
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            print(f"\nüîç Analisando varas encontradas...")
            results = []

            for detection in detections:
                if detection['class'] in rod_classes and self.is_in_inventory(detection):
                    center_x, center_y = detection['center']
                    rod_class = detection['class']

                    # Mapear para slot
                    slot = self.get_inventory_slot_from_position((center_x, center_y))

                    print(f"\nüé£ TESTANDO SLOT {slot}: {rod_class}")
                    print(f"   üìç Posi√ß√£o: ({center_x}, {center_y})")

                    # Usar nova fun√ß√£o de detec√ß√£o de cor
                    color_result = self.check_rod_bait_by_pixel_color(center_x, center_y)

                    print(f"   üé® Resultado da detec√ß√£o de cor:")
                    print(f"      ‚Ä¢ Tem isca? {color_result['has_bait']}")
                    print(f"      ‚Ä¢ Cor detectada: {color_result['color_detected']}")
                    print(f"      ‚Ä¢ Confian√ßa: {color_result['confidence']:.2%}")

                    results.append({
                        'slot': slot,
                        'class': rod_class,
                        'position': (center_x, center_y),
                        'has_bait': color_result['has_bait'],
                        'color': color_result['color_detected'],
                        'confidence': color_result['confidence']
                    })

            # Fechar invent√°rio
            self.close_inventory_with_delay("teste completo")

            # Resumo dos resultados
            print(f"\nüìä RESUMO DOS RESULTADOS:")
            print(f"   ‚Ä¢ Total de varas testadas: {len(results)}")

            with_bait = [r for r in results if r['has_bait'] == True]
            without_bait = [r for r in results if r['has_bait'] == False]
            uncertain = [r for r in results if r['has_bait'] is None]

            print(f"   ‚Ä¢ Varas COM isca: {len(with_bait)}")
            if with_bait:
                for r in with_bait:
                    print(f"      - Slot {r['slot']}: {r['color']} (Conf: {r['confidence']:.2%})")

            print(f"   ‚Ä¢ Varas SEM isca: {len(without_bait)}")
            if without_bait:
                for r in without_bait:
                    print(f"      - Slot {r['slot']}: {r['color']} (Conf: {r['confidence']:.2%})")

            print(f"   ‚Ä¢ Detec√ß√£o incerta: {len(uncertain)}")
            if uncertain:
                for r in uncertain:
                    print(f"      - Slot {r['slot']}: {r['color']}")

            print("\n‚úÖ TESTE CONCLU√çDO COM SUCESSO!")
            return results

        except Exception as e:
            print(f"‚ùå Erro no teste: {e}")
            # Garantir que invent√°rio seja fechado
            try:
                pyautogui.press('tab')
            except:
                pass
            return []

    def test_rod_color_detection(self):
        """üß™ Fun√ß√£o de teste para verificar detec√ß√£o do quadradinho branco das varas"""
        print("\nüß™ TESTE DE DETEC√á√ÉO DE COR - QUADRADINHO BRANCO DAS VARAS")
        print("="*70)

        try:
            # Abrir invent√°rio
            print("üì¶ Abrindo invent√°rio para teste...")
            pyautogui.press('tab')
            time.sleep(1)

            # Detectar todas as varas
            detections = self.detect_objects()
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            print(f"\nüîç Analisando varas encontradas...")
            test_results = []

            for i, detection in enumerate(detections):
                if detection['class'] in rod_classes and self.is_in_inventory(detection):
                    center = detection['center']
                    rod_class = detection['class']

                    print(f"\nüé£ TESTE {i+1}: {rod_class}")
                    print(f"   üìç Posi√ß√£o: {center}")

                    # Teste detalhado com debug
                    slot_region = (center[0] - 25, center[1] - 25, 50, 50)

                    # 1. Verificar se √© slot equipado (azul)
                    print(f"   üîµ Testando fundo azul...")
                    is_equipped = self.detect_equipped_slot_blue(slot_region)

                    # 2. Testar detec√ß√£o do quadradinho branco
                    print(f"   ‚¨ú Testando quadradinho branco...")
                    is_empty = self.is_rod_empty_by_color(detection)
                    has_white_square = not is_empty

                    # 3. An√°lise de cores da regi√£o
                    print(f"   üé® Analisando cores dominantes...")
                    small_region = (center[0] - 15, center[1] - 15, 30, 30)
                    dominant_colors = self.get_dominant_color(small_region, num_colors=5)

                    result = {
                        'rod_class': rod_class,
                        'position': center,
                        'is_equipped': is_equipped,
                        'has_white_square': has_white_square,
                        'is_empty': is_empty,
                        'dominant_colors': dominant_colors
                    }
                    test_results.append(result)

                    print(f"   üìã RESULTADO:")
                    print(f"      ‚Ä¢ Slot equipado (azul): {'SIM' if is_equipped else 'N√ÉO'}")
                    print(f"      ‚Ä¢ Quadradinho branco: {'SIM' if has_white_square else 'N√ÉO'}")
                    print(f"      ‚Ä¢ Vara vazia: {'SIM' if is_empty else 'N√ÉO'}")
                    print(f"      ‚Ä¢ Status: {'COM ISCA' if not is_empty else 'SEM ISCA'}")

                    if dominant_colors:
                        print(f"      ‚Ä¢ Cores encontradas: {len(dominant_colors)}")
                        for j, color in enumerate(dominant_colors[:3]):
                            b, g, r = color
                            print(f"        {j+1}. BGR({b:3d}, {g:3d}, {r:3d})")

            # Fechar invent√°rio
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # Resumo detalhado dos resultados
            print(f"\nüìä RESUMO DETALHADO:")
            print(f"   ‚Ä¢ Total de varas testadas: {len(test_results)}")

            equipped_count = sum(1 for r in test_results if r['is_equipped'])
            with_white = sum(1 for r in test_results if r['has_white_square'])
            empty_rods = sum(1 for r in test_results if r['is_empty'])

            print(f"   ‚Ä¢ Varas equipadas (fundo azul): {equipped_count}")
            print(f"   ‚Ä¢ Varas COM quadradinho branco: {with_white}")
            print(f"   ‚Ä¢ Varas SEM quadradinho branco: {len(test_results) - with_white}")
            print(f"   ‚Ä¢ Varas vazias detectadas: {empty_rods}")
            print(f"   ‚Ä¢ Varas com isca detectadas: {len(test_results) - empty_rods}")

            if len(test_results) > 0:
                print(f"\nüí° INTERPRETA√á√ÉO:")
                print(f"   ‚Ä¢ Varas com quadradinho branco = t√™m isca")
                print(f"   ‚Ä¢ Varas sem quadradinho branco = precisam de isca")
                print(f"   ‚Ä¢ Fundo azul = vara equipada na m√£o")
                print(f"\nüî¨ DIAGN√ìSTICO:")

                if equipped_count > 0:
                    print(f"   ‚úÖ Sistema detectou {equipped_count} vara(s) equipada(s)")
                else:
                    print(f"   ‚ö†Ô∏è Nenhuma vara equipada detectada - pode precisar ajustar cores azuis")

                if with_white > 0:
                    print(f"   ‚úÖ Sistema detectou {with_white} quadradinho(s) branco(s)")
                else:
                    print(f"   ‚ö†Ô∏è Nenhum quadradinho branco detectado - pode precisar ajustar toler√¢ncia")

                print(f"\nüõ†Ô∏è TROUBLESHOOTING:")
                print(f"   ‚Ä¢ Se n√£o detecta azul: cores do slot equipado podem ser diferentes")
                print(f"   ‚Ä¢ Se n√£o detecta branco: quadradinho pode estar em posi√ß√£o diferente")
                print(f"   ‚Ä¢ Use bot.get_dominant_color() para analisar cores espec√≠ficas")

            return test_results

        except Exception as e:
            print(f"‚ùå Erro no teste: {e}")
            # Garantir que invent√°rio seja fechado
            try:
                pyautogui.press('tab')
            except:
                pass
            return []

    def debug_slot_mapping(self):
        """üîß Debug do mapeamento de slots - mostra coordenadas reais"""
        print("\nüîß DEBUG DE MAPEAMENTO DE SLOTS")
        print("="*50)

        try:
            # Abrir invent√°rio
            print("üì¶ Abrindo invent√°rio...")
            pyautogui.press('tab')
            time.sleep(1)

            # Detectar todas as varas
            detections = self.detect_objects()
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            print(f"\nüé£ Varas detectadas no invent√°rio:")
            rod_detections = []

            for detection in detections:
                if detection['class'] in rod_classes and self.is_in_inventory(detection):
                    center = detection['center']
                    rod_class = detection['class']
                    calculated_slot = self.get_inventory_slot_from_position(center)

                    rod_detections.append({
                        'class': rod_class,
                        'center': center,
                        'calculated_slot': calculated_slot
                    })

                    print(f"   ‚Ä¢ {rod_class}")
                    print(f"     Posi√ß√£o: X={center[0]:.0f}, Y={center[1]:.0f}")
                    print(f"     Slot calculado: {calculated_slot}")
                    print()

            # Mostrar coordenadas te√≥ricas dos slots
            print(f"üéØ COORDENADAS TE√ìRICAS DOS SLOTS (corrigidas):")
            hotbar_y_min = 850
            hotbar_y_max = 920
            slot_width = 97
            hotbar_x_start = 897  # Corrigido para alinhar com slots reais

            for slot in range(1, 7):
                slot_x_min = hotbar_x_start + (slot - 1) * slot_width
                slot_x_max = slot_x_min + slot_width
                slot_x_center = (slot_x_min + slot_x_max) // 2
                slot_y_center = (hotbar_y_min + hotbar_y_max) // 2

                print(f"   Slot {slot}: X={slot_x_center} (range {slot_x_min}-{slot_x_max}), Y={slot_y_center}")

            # Fechar invent√°rio
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # Sugest√µes para corre√ß√£o
            if rod_detections:
                print(f"\nüí° AN√ÅLISE E SUGEST√ïES:")
                print(f"   Se voc√™ colocou varas nos slots 1,2,5,6 mas detectou outros slots:")
                print(f"   ‚Ä¢ Verifique se hotbar_x_start={hotbar_x_start} est√° correto")
                print(f"   ‚Ä¢ Verifique se slot_width={slot_width} est√° correto")
                print(f"   ‚Ä¢ Compare posi√ß√µes reais vs te√≥ricas acima")

                # Calcular coordenadas baseadas nas posi√ß√µes reais
                if len(rod_detections) >= 2:
                    rod_detections.sort(key=lambda x: x['center'][0])  # Ordenar por X
                    x_positions = [r['center'][0] for r in rod_detections]

                    if len(x_positions) >= 2:
                        avg_spacing = sum(x_positions[i+1] - x_positions[i] for i in range(len(x_positions)-1)) / (len(x_positions)-1)
                        suggested_start = x_positions[0] - (rod_detections[0]['calculated_slot'] - 1) * avg_spacing

                        print(f"\nüîß SUGEST√ïES DE CORRE√á√ÉO:")
                        print(f"   ‚Ä¢ Espa√ßamento m√©dio detectado: {avg_spacing:.0f} pixels")
                        print(f"   ‚Ä¢ hotbar_x_start sugerido: {suggested_start:.0f}")
                        print(f"   ‚Ä¢ slot_width sugerido: {avg_spacing:.0f}")

            return rod_detections

        except Exception as e:
            print(f"‚ùå Erro no debug: {e}")
            try:
                pyautogui.press('tab')
            except:
                pass
            return []

    def detect_equipped_rod(self):
        """üéØ Detectar qual vara est√° equipada na m√£o"""
        print("\nüéØ DETECTANDO VARA EQUIPADA...")

        try:
            # M√©todo 1: Usar detec√ß√£o de fundo azul
            print("üîµ M√©todo 1: Procurando slot com fundo azul...")

            # Abrir invent√°rio
            pyautogui.press('tab')
            time.sleep(1)

            # Detectar varas
            detections = self.detect_objects()
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            equipped_rod = None

            for detection in detections:
                if detection['class'] in rod_classes and self.is_in_inventory(detection):
                    center = detection['center']
                    slot = self.get_inventory_slot_from_position(center)

                    # Testar se tem fundo azul (equipado)
                    slot_region = (center[0] - 25, center[1] - 25, 50, 50)
                    is_equipped = self.detect_equipped_slot_blue(slot_region)

                    if is_equipped:
                        equipped_rod = {
                            'slot': slot,
                            'class': detection['class'],
                            'position': center
                        }
                        print(f"   ‚úÖ Vara equipada encontrada: Slot {slot} - {detection['class']}")
                        break

            # Fechar invent√°rio
            self.close_inventory_with_delay("Auto opera√ß√£o")

            if equipped_rod:
                # Atualizar sistema de varas
                self.rod_system['equipped_rod'] = equipped_rod['slot']

                # Determinar qual par est√° ativo
                for pair_idx, pair in enumerate(self.rod_system['pairs']):
                    if equipped_rod['slot'] in pair:
                        self.rod_system['current_pair'] = pair_idx
                        # Determinar se √© vara 1 ou 2 do par
                        self.rod_system['current_rod'] = 1 if equipped_rod['slot'] == pair[0] else 2
                        print(f"   üìä Sistema atualizado: Par {pair_idx}, Vara {self.rod_system['current_rod']}")
                        break

                print(f"\n‚úÖ VARA EQUIPADA DETECTADA:")
                print(f"   ‚Ä¢ Slot: {equipped_rod['slot']}")
                print(f"   ‚Ä¢ Tipo: {equipped_rod['class']}")
                print(f"   ‚Ä¢ Par ativo: {self.rod_system['current_pair']}")
                print(f"   ‚Ä¢ Vara do par: {self.rod_system['current_rod']}")

                return equipped_rod
            else:
                print("   ‚ùå Nenhuma vara equipada detectada")

                # M√©todo 2: Usar l√≥gica baseada no sistema atual
                print("\nüß† M√©todo 2: Usando l√≥gica do sistema...")
                current_pair = self.get_current_rod_pair()
                current_rod_in_pair = self.rod_system['current_rod']
                absolute_rod = current_pair[current_rod_in_pair - 1]

                print(f"   üìä Sistema indica:")
                print(f"   ‚Ä¢ Par atual: {current_pair}")
                print(f"   ‚Ä¢ Vara do par: {current_rod_in_pair}")
                print(f"   ‚Ä¢ Slot absoluto: {absolute_rod}")

                return {
                    'slot': absolute_rod,
                    'class': 'unknown (via l√≥gica)',
                    'position': None,
                    'method': 'logic'
                }

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o: {e}")
            try:
                pyautogui.press('tab')
            except:
                pass
            return None

    def safe_check_inventory_contents(self, check_type="fish"):
        """Verificar conte√∫do do invent√°rio de forma SEGURA - sem sobreposi√ß√£o"""
        # NUNCA verificar nos primeiros ciclos
        if self.ciclos_completados < 10:
            return False

        if self.game_state['fishing_active'] or self.game_state['action_in_progress']:
            print(f"‚ö†Ô∏è Pesca ativa - pulando verifica√ß√£o de {check_type}")
            return False

        # Cooldown entre verifica√ß√µes TAB
        if time.time() - self.game_state['last_tab_press'] < 1.0:
            return False

        try:
            print(f"üì¶ Verifica√ß√£o SEGURA: {check_type}")

            # Marcar a√ß√£o em progresso
            self.game_state['action_in_progress'] = True

            # Abrir invent√°rio
            pyautogui.press('tab')
            self.game_state['inventory_open'] = True
            self.game_state['last_tab_press'] = time.time()
            time.sleep(0.4)  # Tempo para estabilizar

            # Detectar objetos
            detections = self.detect_objects()
            result = False

            if check_type == "fish":
                fish_classes = ['anchova', 'aranque', 'salmao', 'sardinha', 'truta', 'smalltrout',
                               'tubarao', 'parca', 'file de peixe', 'salmao box', 'anchovy', 'salmon',
                               'scrap', 'sinalizador', 'cartao_azul', 'flare', 'bluecard',
                               'bullet', 'BONE', 'bone', 'fat', 'gut', 'peixecru', 'peixe_cru', 'rawfish']
                fish_count = 0
                for detection in detections:
                    if detection['class'] in fish_classes and self.is_in_inventory(detection):
                        fish_count += 1
                result = fish_count >= 5
                print(f"üêü Peixes no invent√°rio: {fish_count}")

            elif check_type == "baits":
                bait_classes = ['carne de urso', 'carne de lobo', 'worms', 'bear meat', 'wolf meat']
                result = False
                for detection in detections:
                    if detection['class'] in bait_classes and self.is_in_inventory(detection):
                        result = True
                        print(f"üé£ Isca encontrada: {detection['class']}")
                        break
                print(f"üé£ Iscas dispon√≠veis: {result}")

            # Fechar invent√°rio
            pyautogui.press('tab')
            self.game_state['inventory_open'] = False
            self.game_state['last_tab_press'] = time.time()
            time.sleep(0.3)

            return result

        except Exception as e:
            print(f"‚ùå Erro na verifica√ß√£o segura: {e}")
            # Garantir que invent√°rio seja fechado
            if self.game_state['inventory_open']:
                pyautogui.press('tab')
                self.game_state['inventory_open'] = False
            return False
        finally:
            self.game_state['action_in_progress'] = False

    def detect_objects_main_thread_only(self, monitor_region=None):
        """üéØ Detectar objetos com Template Matching - substitui√ß√£o do YOLO"""
        try:
            if not hasattr(self, 'available_templates') or not self.available_templates:
                return []

            # Usar fun√ß√£o template matching
            detections = self.template_detect_objects(monitor_region, confidence_threshold=0.5)

            # Converter para formato compat√≠vel com c√≥digo existente
            formatted_detections = []
            for detection in detections:
                # Converter formato do template matching para formato YOLO
                class_name = detection['class']

                # Verificar threshold da classe
                threshold = self.config.get('confidence_thresholds', {}).get(class_name, 0.5)

                if detection['confidence'] >= threshold:
                    x1, y1, x2, y2 = detection['box']

                    formatted_detections.append({
                        'class': class_name,
                        'confidence': detection['confidence'],
                        'bbox': (x1, y1, x2, y2),
                        'center': detection['center'],
                        'center_x': detection.get('center_x', detection['center'][0] if detection.get('center') else 0),
                        'center_y': detection.get('center_y', detection['center'][1] if detection.get('center') else 0),
                        'x': detection.get('x', x1),
                        'y': detection.get('y', y1)
                    })

            return formatted_detections

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o Template Matching: {e}")
            return []

    def detect_objects(self, monitor_region=None):
        """Detectar objetos com YOLO - redirecionar para main thread apenas"""
        detections = self.detect_objects_main_thread_only(monitor_region)

        # Aplicar normaliza√ß√£o de nomes de itens
        normalized_detections = self.normalize_detection_results(detections)

        return normalized_detections

    def save_default_config(self):
        """Salvar configura√ß√µes padr√£o no arquivo config.json"""
        try:
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            print("‚úÖ Arquivo config.json criado com configura√ß√µes padr√£o!")
        except Exception as e:
            print(f"‚ùå Erro ao criar config.json: {e}")

    def add_priority_task(self, priority, task_name, task_func, *args, **kwargs):
        """THREAD-SAFE: Adicionar tarefa com prioridade E preven√ß√£o de duplicatas"""

        # ‚ö° PREVEN√á√ÉO DE DUPLICATAS
        if not self.prevent_duplicate_priority_tasks(task_name):
            return False  # Tarefa j√° existe

        task = {
            'priority': priority,
            'name': task_name,
            'function': task_func,
            'args': args,
            'kwargs': kwargs,
            'timestamp': time.time()
        }
        with self._priority_lock:
            self.priority_queue.append(task)
            # Ordenar por prioridade (menor n√∫mero = maior prioridade)
            self.priority_queue.sort(key=lambda x: (x['priority'], x['timestamp']))

        return True

    def process_priority_tasks(self):
        """THREAD-SAFE: Processar tarefa de maior prioridade"""
        with self._priority_lock:
            if not self.priority_queue or not self.running:
                return False

            # Pegar tarefa de maior prioridade
            task = self.priority_queue.pop(0)

        try:
            print(f"üîÑ Executando tarefa: {task['name']} (Prioridade: {task['priority']})")
            task['function'](*task['args'], **task['kwargs'])
            return True
        except Exception as e:
            print(f"‚ùå Erro na tarefa {task['name']}: {e}")
            return False

    def get_current_rod_pair(self):
        """Obter dupla de vara atual"""
        current_pair = self.rod_system['current_pair']
        return self.rod_system['pairs'][current_pair]

    def switch_rod_pair(self):
        """Trocar dupla de varas ap√≥s atingir limite por vara"""
        print("\n" + "="*60)
        print("üîÑ INICIANDO TROCA DE DUPLA DE VARAS")
        print("="*60)

        # üéØ TRACKER: Status atual das varas antes da troca de dupla
        print("\nüìç MAPEAMENTO DE VARAS ANTES DA TROCA DE DUPLA:")
        rod_slots_before = self.get_current_rod_status()
        if not rod_slots_before:
            print("   ‚ö†Ô∏è Nenhuma vara detectada!")

        old_pair_index = self.rod_system['current_pair']
        old_pair = self.get_current_rod_pair()
        max_per_rod = self.config.get('pair_switch_limit', 30)

        print(f"üìä Estado Atual:")
        print(f"   ‚Ä¢ Par atual: {old_pair_index} ‚Üí Varas {old_pair}")
        print(f"   ‚Ä¢ Vara {old_pair[0]}: {self.rod_system['rod1_usage']} usos")
        print(f"   ‚Ä¢ Vara {old_pair[1]}: {self.rod_system['rod2_usage']} usos")
        print(f"   ‚Ä¢ Limite por vara: {max_per_rod}")

        # IMPORTANTE: S√≥ guarda peixes SE atingir limite configurado na UI
        print("üì¶ SEQU√äNCIA DE TROCA DE DUPLA:")
        print("   1. Verificar se precisa guardar peixes (loot_interval)")
        print("   2. Recarregar iscas nas varas")
        print("   3. Trocar para pr√≥xima dupla")

        # PASSO 1: APENAS recarregar se necess√°rio (SEM for√ßar armazenamento)
        print("\n‚û§ PASSO 1: VERIFICAR SE PRECISA GUARDAR PEIXES")
        if self.need_store_fish():
            print("   üêü Limite de peixes atingido, guardando...")
            self.store_fish_in_chest()
            time.sleep(2)
        else:
            loot_interval = self.auto_clean.get('interval', 10)
            fish_count = self.auto_clean.get('fish_count_since_last', 0)
            print(f"   ‚úì Ainda n√£o precisa guardar peixes ({fish_count}/{loot_interval})")

        # PASSO 2: PULAR RECARGA (evita TAB desnecess√°rio e cliques nas varas)
        print("\n‚û§ PASSO 2: RECARREGAR ISCAS")
        print("   ‚ö†Ô∏è RECARGA DESABILITADA durante troca de dupla")
        print("   Motivo: Evitar TAB desnecess√°rio e cliques nas varas")
        print("   A recarga ser√° feita quando realmente necess√°rio")

        # PASSO 3: Trocar para pr√≥xima dupla
        print("\n‚û§ PASSO 3: TROCAR PARA PR√ìXIMA DUPLA")
        old_pair_idx = self.rod_system['current_pair']
        new_pair_idx = (old_pair_idx + 1) % 3

        print(f"   ‚Ä¢ Par atual: {old_pair_idx} ‚Üí Novo par: {new_pair_idx}")
        print(f"   ‚Ä¢ Mapeamento: 0=(1,2), 1=(3,4), 2=(5,6)")

        self.rod_system['current_pair'] = new_pair_idx
        self.rod_system['current_rod'] = 1  # Sempre come√ßa com vara 1 da nova dupla
        self.rod_system['rod1_usage'] = 0   # Reset contador vara 1 (peixes)
        self.rod_system['rod2_usage'] = 0   # Reset contador vara 2 (peixes)
        self.rod_system['rod1_cycles'] = 0  # NOVO: Reset contador ciclos vara 1
        self.rod_system['rod2_cycles'] = 0  # NOVO: Reset contador ciclos vara 2

        # üö® RESETAR CONTADORES DE TIMEOUT PARA NOVA DUPLA
        self.rod_system['rod1_timeouts'] = 0
        self.rod_system['rod2_timeouts'] = 0
        print("üîÑ Contadores de timeout e ciclos resetados para nova dupla")

        new_pair = self.get_current_rod_pair()
        new_absolute = self.get_absolute_rod_number()

        print(f"   ‚Ä¢ Nova dupla: Varas {new_pair}")
        print(f"   ‚Ä¢ Vara inicial: {new_absolute}")
        print(f"   ‚Ä¢ current_rod = {self.rod_system['current_rod']}")
        print(f"   ‚Ä¢ current_pair = {self.rod_system['current_pair']}")

        # Pressionar tecla num√©rica para trocar vara no jogo
        print(f"\n‚å®Ô∏è PRESSIONANDO TECLA [{new_absolute}] para ativar nova dupla")
        pyautogui.press(str(new_absolute))
        
        # AGUARDAR 2 SEGUNDOS + 4 CLIQUES DEVAGAR (como solicitado para pesca)
        print("‚è∞ Aguardando 2 segundos ap√≥s troca de dupla...")
        time.sleep(2.0)
        
        # 4 cliques devagar para garantir que a pesca comece corretamente
        print("üêå Executando 4 cliques devagar ap√≥s troca de dupla (1s cada)...")
        for i in range(4):
            print(f"   üêå Clique devagar {i+1}/4")
            pyautogui.click(button='left')
            time.sleep(1.0)

        # üéØ TRACKER: Status das varas ap√≥s troca de dupla
        print("\nüìç MAPEAMENTO DE VARAS AP√ìS TROCA DE DUPLA:")
        time.sleep(1.0)  # Aguardar um pouco mais para detec√ß√µes atualizarem
        rod_slots_after = self.get_current_rod_status()
        if not rod_slots_after:
            print("   ‚ö†Ô∏è Nenhuma vara detectada ap√≥s troca de dupla!")

        print("="*60)
        print("‚úÖ TROCA DE DUPLA CONCLU√çDA!")
        print("="*60 + "\n")

    def get_absolute_rod_number(self):
        """Calcular n√∫mero absoluto da vara atual (1-6)"""
        current_pair = self.get_current_rod_pair()
        current_rod = self.rod_system['current_rod']

        # current_pair √© uma tupla como (1,2), (3,4) ou (5,6)
        # current_rod √© 1 ou 2 (posi√ß√£o dentro da dupla)
        absolute_rod = current_pair[current_rod - 1]
        return absolute_rod

    def switch_rod_in_pair(self):
        """Trocar vara dentro da dupla atual"""
        current_pair = self.get_current_rod_pair()
        old_rod = self.rod_system['current_rod']
        old_absolute = self.get_absolute_rod_number()

        # Alternar entre 1 e 2
        self.rod_system['current_rod'] = 2 if old_rod == 1 else 1
        new_rod = self.rod_system['current_rod']
        new_absolute = self.get_absolute_rod_number()

        print(f"üé£ Trocando vara na dupla {current_pair}: {old_rod} ‚Üí {new_rod} (Vara {old_absolute} ‚Üí Vara {new_absolute})")

        # CR√çTICO: Pressionar tecla num√©rica para trocar vara no jogo
        print(f"‚å®Ô∏è Pressionando tecla {new_absolute} para trocar vara")
        pyautogui.press(str(new_absolute))
        
        # AGUARDAR 2 SEGUNDOS + 4 CLIQUES DEVAGAR (como solicitado para pesca)
        print("‚è∞ Aguardando 2 segundos ap√≥s troca de vara...")
        time.sleep(2.0)
        
        # 4 cliques devagar para garantir que a pesca comece corretamente
        print("üêå Executando 4 cliques devagar ap√≥s troca (1s cada)...")
        for i in range(4):
            print(f"   üêå Clique devagar {i+1}/4")
            pyautogui.click(button='left')
            time.sleep(1.0)

    def check_rod_switch_needed(self):
        """Verificar se precisa trocar vara/dupla"""
        # Trocar dupla a cada 30 pescas
        if self.rod_system['catches_count'] >= self.rod_system['switch_threshold']:
            self.add_priority_task(3, "Trocar dupla de varas", self.switch_rod_pair)
            self.rod_system['catches_count'] = 0
            return True

        # Trocar dupla se atingiu 40 usos (20 por vara)
        total_usage = self.rod_system['rod1_usage'] + self.rod_system['rod2_usage']
        if total_usage >= self.rod_system['max_usage_per_pair']:
            self.add_priority_task(3, "Trocar dupla por uso m√°ximo (40)", self.switch_rod_pair)
            return True

        return False

    def check_license(self):
        """Verificar e validar licen√ßa"""
        print("\nüîê Verificando licen√ßa...")

        # Tentar carregar licen√ßa existente
        saved_key = self.license_manager.load_license()

        if saved_key:
            print("üîë Licen√ßa encontrada, validando...")
            valid, data = self.license_manager.validate(saved_key)

            if valid:
                print("‚úÖ Licen√ßa v√°lida!")
                self.licensed = True
                return
            else:
                print(f"‚ùå Licen√ßa inv√°lida: {data.get('message', 'Erro desconhecido')}")

        # Solicitar nova licen√ßa
        print("üîê Solicitando nova licen√ßa...")
        dialog = LicenseDialog(self)
        license_key = dialog.show()

        if license_key:
            valid, data = self.license_manager.validate(license_key)
            if valid:
                print("‚úÖ Licen√ßa ativada com sucesso!")
                self.licensed = True
            else:
                print("‚ùå Falha na valida√ß√£o da licen√ßa")
                exit(1)
        else:
            print("‚ùå Licenciamento cancelado")
            exit(1)

    def start(self):
        """üöÄ Iniciar bot - VERS√ÉO OTIMIZADA PARA VELOCIDADE"""
        if not self.licensed:
            print("‚ùå Bot n√£o licenciado!")
            return

        if not self.running:
            self.running = True
            self.paused = False
            self.start_time = time.time()

            # üöÄ INICIALIZA√á√ÉO SUPER R√ÅPIDA - Sistema minimalista
            print("\n‚ö° INICIANDO BOT DE PESCA (MODO R√ÅPIDO)...")
            print("="*50)
            
            # Capturar posi√ß√£o inicial (instant√¢neo)
            initial_mouse_pos = pyautogui.position()
            self.config['initial_camera_pos'] = {'x': initial_mouse_pos.x, 'y': initial_mouse_pos.y}
            
            print("üöÄ Bot INICIADO INSTANTANEAMENTE!")
            print("üí° Sistemas ser√£o carregados em background durante a pesca")
            
            # Reabilitar auto-focus ao iniciar o bot
            enable_auto_focus()
            print("‚úÖ Pronto para pescar!")

            # ‚ö° INICIALIZA√á√ÉO EM BACKGROUND (n√£o bloquear F9)
            threading.Thread(target=self.lazy_initialize_systems, daemon=True).start()
            
            # ‚ö° MAIN LOOP IMEDIATO
            threading.Thread(target=self.main_loop, daemon=True).start()

    def lazy_initialize_systems(self):
        """üîß Inicializa√ß√£o inteligente em background - n√£o bloqueia F9"""
        try:
            print("üîß [BACKGROUND] Carregando sistemas...")
            
            # Salvar config (r√°pido)
            try:
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
            except:
                pass
            
            # Iniciar sistemas de detec√ß√£o em background
            self.start_detection_systems()
            
            print("‚úÖ [BACKGROUND] Sistemas carregados! Bot totalmente operacional.")
            
        except Exception as e:
            print(f"‚ö†Ô∏è [BACKGROUND] Erro na inicializa√ß√£o: {e}")
            print("üí° Bot funcionar√° com funcionalidade reduzida")

    def start_detection_systems(self):
        """‚ö° Iniciar sistemas de detec√ß√£o - VERS√ÉO OTIMIZADA"""
        print("‚ö° [BACKGROUND] Iniciando detec√ß√£o otimizada...")

        # ‚ö° INICIALIZA√á√ÉO R√ÅPIDA: S√≥ iniciar se realmente necess√°rio
        if not hasattr(self, 'viewer_running') or not self.viewer_running:
            self.viewer_running = True
            print("üëÅÔ∏è [BACKGROUND] YOLO ativo")
            threading.Thread(target=self.yolo_background_loop, daemon=True).start()

        # ‚ö° SISTEMA CATCH essencial
        if not hasattr(self, 'catch_viewer_running') or not self.catch_viewer_running:
            self.catch_viewer_running = True
            print("üêü [BACKGROUND] CATCH detection ativo")
            threading.Thread(target=self.catch_background_loop, daemon=True).start()

        print("‚ö° [BACKGROUND] Sistemas iniciados!")

    def yolo_background_loop(self):
        """Loop YOLO em background - REALMENTE DETECTANDO"""
        print("ü§ñ [YOLO BACKGROUND] Sistema iniciado - detectando objetos em tempo real...")

        if not hasattr(self, 'yolo_model') or not self.yolo_model:
            print("‚ùå [YOLO BACKGROUND] YOLO removido - usando apenas Template Matching!")
            return

        while self.viewer_running:
            try:
                # Fazer detec√ß√µes YOLO a cada 0.5 segundos
                detections = self.detect_objects()

                # Log apenas detec√ß√µes importantes
                for detection in detections:
                    if detection['class'] in ['peixe capturado', 'vara', 'vara com isca', 'inventario aberto']:
                        print(f"ü§ñ [YOLO] {detection['class']} detectado! Conf: {detection['confidence']:.2f}")

                time.sleep(0.5)  # Detectar a cada 500ms

            except Exception as e:
                print(f"‚ùå [YOLO BACKGROUND] Erro: {e}")
                time.sleep(1)

        print("ü§ñ [YOLO BACKGROUND] Sistema parado")

    def check_catch_detection_safe(self):
        """Verificar detec√ß√£o de forma thread-safe"""
        with self.detection_lock:
            return self.last_catch_detection.get('detected', False), self.last_catch_detection.get('confidence', 0)

    def clear_catch_detection_safe(self):
        """Limpar detec√ß√£o de forma thread-safe"""
        with self.detection_lock:
            old_state = self.last_catch_detection.get('detected', False)
            self.last_catch_detection = {'detected': False, 'confidence': 0, 'time': 0}
            print(f"üßπ [DEBUG] Flag limpa: {old_state} ‚Üí False")

    def catch_background_loop(self):
        """Loop template matching em background - DETECTA TODOS OS TEMPLATES"""
        print("üêü [CATCH BACKGROUND] Sistema iniciado - detectando todos os templates...")

        import glob
        import cv2
        import numpy as np
        import mss

        # Carregar TODOS os templates
        templates_folder = "templates"
        if not os.path.exists(templates_folder):
            print("‚ùå [CATCH BACKGROUND] Pasta templates n√£o encontrada!")
            return

        # Carregar todos os arquivos .png
        template_files = glob.glob(os.path.join(templates_folder, "*.png"))
        if not template_files:
            print("‚ùå [CATCH BACKGROUND] Nenhum template encontrado!")
            return

        # Dicion√°rio para armazenar templates
        templates = {}

        # Carregar cada template - REFATORADO
        for template_path in template_files:
            template_name = os.path.basename(template_path)
            template = load_template_safe(template_path)

            if template is not None:
                templates[template_name] = {
                    'image': template,
                    'height': template.shape[0],
                    'width': template.shape[1],
                    'last_detection': 0,
                    'count': 0
                }
                print(f"‚úÖ [CATCH BACKGROUND] Template carregado: {template_name}")

        if not templates:
            print("‚ùå [CATCH BACKGROUND] Nenhum template v√°lido!")
            return

        print(f"üéØ [CATCH BACKGROUND] {len(templates)} templates carregados")

        # Configurar captura
        sct = mss.mss()
        monitors = sct.monitors
        primary_monitor = monitors[1]

        fish_region = {
            "top": 0,
            "left": 0,
            "width": primary_monitor['width'],
            "height": primary_monitor['height']
        }

        while self.catch_viewer_running:
            try:
                # Capturar tela
                screenshot = sct.grab(fish_region)
                screen_img = np.array(screenshot)

                if screen_img.shape[2] == 4:
                    screen_img = cv2.cvtColor(screen_img, cv2.COLOR_BGRA2BGR)

                current_time = time.time()

                # Testar CADA template
                for template_name, template_data in templates.items():
                    template_img = template_data['image']

                    # üîÑ PROCESSAMENTO SIMPLES UNIFICADO - Sem normaliza√ß√£o/CLAHE
                    screen_processed = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
                    template_processed = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)

                    # Template matching com imagens processadas
                    result = cv2.matchTemplate(screen_processed, template_processed, cv2.TM_CCOEFF_NORMED)
                    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                    # Threshold ALTO para evitar falsos positivos
                    # Template matching precisa ser MUITO preciso
                    threshold = 0.85  # Padr√£o alto

                    # Ajustes espec√≠ficos por template
                    if template_name == 'catch.png':
                        threshold = 0.80  # Mensagem "peixe capturado"
                    elif template_name == 'varaquebrada.png':
                        threshold = 0.85  # Vara quebrada
                    elif template_name in ['varacomisca.png', 'comiscavara.png', 'varasemisca.png', 'semiscavara.png', 'namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'VARANOBAUCI.png']:
                        threshold = 0.90  # Varas normais (precisa ser muito preciso)
                    elif template_name in ['eat.png', 'gut.png']:
                        threshold = 0.85  # Bot√µes de interface
                    elif template_name == 'shark.png':
                        threshold = 0.82  # Shark detectado
                    elif template_name in ['herring.png', 'salmon.png', 'salmonn.png', 'sardine.png', 'yellowperch.png', 'smalltrout.png', 'trout.png']:
                        threshold = 0.88  # √çcones de peixes
                    elif template_name in ['salmonbox.png', 'salmonnnbox.png', 'yellowperchbox.png', 'smalltroutbox.png', 'troutbox.png', 'wolfmeatbox.png', 'wormbox.png', 'grubbox.png']:
                        threshold = 0.88  # Caixas de peixes
                    elif template_name in ['file frito.png', 'truta.png', 'trout.png', 'wolfmeat.png', 'carneurso.png', 'worm.png', 'grub.png']:
                        threshold = 0.85  # Itens processados
                    else:
                        threshold = 0.90  # Outros (mais rigoroso)

                    # Verificar se detectou
                    if max_val > threshold:
                        # Evitar spam - s√≥ logar se passou 1 segundo desde √∫ltima detec√ß√£o
                        if current_time - template_data['last_detection'] > 1.0:
                            template_data['count'] += 1
                            template_data['last_detection'] = current_time

                            # Log apenas templates cr√≠ticos com mensagens claras
                            if template_name == 'catch.png':
                                print(f"üêü [BACKGROUND] PEIXE CAPTURADO DETECTADO! #{template_data['count']} (Conf: {max_val:.3f})")
                            elif template_name == 'varaquebrada.png':
                                print(f"üî¥ [BACKGROUND] VARA QUEBRADA DETECTADA! #{template_data['count']} (Conf: {max_val:.3f})")
                            elif template_name == 'shark.png':
                                print(f"ü¶à [BACKGROUND] SHARK DETECTADO! #{template_data['count']} (Conf: {max_val:.3f})")

                            # Atualizar flag especial para catch.png
                            if template_name == 'catch.png':
                                with self.detection_lock:
                                    self.last_catch_detection = {
                                        'detected': True,
                                        'confidence': max_val,
                                        'time': current_time
                                    }

                time.sleep(0.2)  # Verificar a cada 200ms

            except Exception as e:
                print(f"‚ùå [CATCH BACKGROUND] Erro: {e}")
                time.sleep(1)

        sct.close()
        print("üêü [CATCH BACKGROUND] Sistema parado")

    def pause_bot(self):
        """Pausar/despausar bot - F2"""
        print("\n" + "="*50)
        print("üéØ [HOTKEY] F2 PRESSIONADO!")
        print("‚úÖ HOTKEYS EST√ÉO FUNCIONANDO!")
        print("="*50)
        if self.running:
            self.paused = not self.paused
            status = "‚è∏Ô∏è PAUSADO" if self.paused else "‚ñ∂Ô∏è RETOMADO"
            print(f"[BOT] {status}")
            
            # Parar cliques e liberar controles quando pausar
            if self.paused:
                self.game_state['peixe_detectado_fase_lenta'] = True
                if self.game_state.get('right_mouse_down', False):
                    focus_game_window()  # Garantir foco
                    pyautogui.mouseUp(button='right')
                    self.game_state['right_mouse_down'] = False
                    print("üîÑ [PAUSE] Bot√£o direito liberado")
            else:
                self.game_state['peixe_detectado_fase_lenta'] = False
                
            safe_print(f"[STATE] running={self.running}, paused={self.paused}")
        else:
            print("[WARN] Bot n√£o est√° rodando, n√£o √© poss√≠vel pausar")

    def stop(self):
        """Parar bot - F1"""
        print("\n" + "="*50)
        print("[HOTKEY] F1 PRESSIONADO!")
        print("="*50)
        self.running = False
        self.paused = False
        
        # Parar cliques e liberar controles imediatamente
        self.game_state['peixe_detectado_fase_lenta'] = True
        if self.game_state.get('right_mouse_down', False):
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='right')
            self.game_state['right_mouse_down'] = False
            print("üîÑ [STOP] Bot√£o direito liberado")

        # Parar sistemas de detec√ß√£o em background
        self.stop_detection_systems()

        print("[BOT] üõë Bot parado")

    def stop_detection_systems(self):
        """Parar sistemas de detec√ß√£o em background"""
        print("üîß Parando sistemas de detec√ß√£o...")

        # Parar sistema YOLO
        if hasattr(self, 'viewer_running'):
            self.viewer_running = False
            print("üëÅÔ∏è Sistema YOLO parado")

        # Parar sistema CATCH
        if hasattr(self, 'catch_viewer_running'):
            self.catch_viewer_running = False
            print("üêü Sistema CATCH parado")

        print("‚úÖ Sistemas de detec√ß√£o parados!")
        safe_print(f"[STATE] running={self.running}, paused={self.paused}")

    def full_emergency_stop(self):
        """ESC - Parada de emerg√™ncia TOTAL - para TUDO imediatamente"""
        print("\n" + "="*60)
        print("üõë [ESC] PARADA DE EMERG√äNCIA TOTAL!")
        print("="*60)

        # For√ßar parada imediata
        self.running = False
        self.paused = True

        # üéØ LIMPAR SISTEMA DE COORDENA√á√ÉO EM EMERG√äNCIA
        self.emergency_clear_operations()

        # Parar TODAS as threads em execu√ß√£o
        self.stop_detection_systems()

        # SOLTAR TODAS as teclas e bot√µes do mouse
        try:
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('ctrl')
            pyautogui.keyUp('shift')
            pyautogui.keyUp('a')
            pyautogui.keyUp('d')
            pyautogui.keyUp('w')
            pyautogui.keyUp('s')
            pyautogui.keyUp('tab')
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='left')
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='right')
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='middle')
            print("üîì Todas as teclas e bot√µes do mouse foram soltos")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao soltar teclas: {e}")

        # Resetar estados do jogo
        self.game_state = {
            'inventory_open': False,
            'chest_open': False,
            'fishing_active': False,
            'right_mouse_down': False,
            'action_in_progress': False
        }

        print("‚úÖ PARADA DE EMERG√äNCIA CONCLU√çDA!")
        print("üí° Bot pausado - use F2 para retomar ou F1 para parar")

    def emergency_complete_stop(self):
        """ALT+TAB - Parada COMPLETA e DEFINITIVA - para tudo e reseta"""
        print("\n" + "="*70)
        print("üö® [ALT+TAB] PARADA COMPLETA E DEFINITIVA!")
        print("="*70)

        # IMPORTANTE: Desabilitar auto-focus para permitir sair do jogo
        disable_auto_focus()

        # Parar COMPLETAMENTE
        self.running = False
        self.paused = False  # N√£o pausado, PARADO

        # Limpar sistema de coordena√ß√£o
        self.emergency_clear_operations()

        # Parar todas as threads
        self.stop_detection_systems()

        # Liberar TUDO (SEM for√ßar foco no jogo)
        try:
            # N√ÉO chamar focus_game_window() aqui - deixar usu√°rio controlar foco
            # Liberar todas as teclas poss√≠veis
            all_keys = ['alt', 'ctrl', 'shift', 'a', 'd', 'w', 's', 'space', 'tab', 'enter', 'esc']
            for key in all_keys:
                pyautogui.keyUp(key)
            
            # Liberar todos os bot√µes do mouse
            pyautogui.mouseUp(button='left')
            pyautogui.mouseUp(button='right') 
            pyautogui.mouseUp(button='middle')
            
            print("üîì TUDO foi liberado - bot COMPLETAMENTE parado")
            print("üö´ Auto-focus DESABILITADO - voc√™ pode Alt+Tab livremente")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na libera√ß√£o: {e}")

        # Resetar TODOS os estados
        self.game_state = {
            'fishing_active': False,
            'right_mouse_down': False,
            'left_mouse_down': False,
            'peixe_detectado_fase_lenta': True,
            'action_in_progress': False,
            'inventory_open': False,
            'chest_open': False,
            'manual_inventory_open': False,
            'auto_clean_in_progress': False
        }

        print("‚úÖ BOT COMPLETAMENTE PARADO!")
        print("üí° Use F9 para reiniciar se desejar")

    def panic_exit(self):
        """HOME - Fechar programa completamente"""
        print("\n" + "="*60)
        print("üö® [HOME] ENCERRANDO PROGRAMA COMPLETAMENTE!")
        print("="*60)

        # Executar parada de emerg√™ncia primeiro
        self.full_emergency_stop()

        # Aguardar um momento
        time.sleep(0.5)

        # Fechar janelas
        if hasattr(self, 'ui') and self.ui:
            try:
                self.ui.main_window.destroy()
            except:
                pass

        print("\nüëã Tchau!")

        # For√ßar sa√≠da do programa
        import sys
        sys.exit(0)

    def test_mouse_movement(self):
        """F12 - Testar movimento do mouse"""
        print("\nüñ±Ô∏è TESTE DE MOVIMENTO DO MOUSE (F12)")
        print("="*50)

        try:
            current_pos = pyautogui.position()
            print(f"üìç Posi√ß√£o atual: {current_pos}")

            # Testar movimento b√°sico
            test_positions = [
                (current_pos.x + 50, current_pos.y),
                (current_pos.x, current_pos.y + 50),
                (current_pos.x - 50, current_pos.y),
                (current_pos.x, current_pos.y - 50),
                (current_pos.x, current_pos.y)  # Voltar ao original
            ]

            for i, (x, y) in enumerate(test_positions):
                print(f"üéØ Movimento {i+1}: ({x}, {y})")
                pyautogui.moveTo(x, y, duration=0.5)
                time.sleep(0.3)
                actual = pyautogui.position()
                print(f"   ‚úÖ Resultado: {actual}")

            print("‚úÖ Teste de movimento conclu√≠do!")

        except Exception as e:
            print(f"‚ùå Erro no teste: {e}")

    def clear_macro_cache(self):
        """DEL - Limpar TODOS os caches do bot (n√£o s√≥ macros)"""
        print("\nüóëÔ∏è LIMPANDO TODOS OS CACHES DO BOT (DEL)")
        print("="*70)

        try:
            # 1. Limpar arquivos de macro
            macro_files = ['recorded_macro.pkl', 'recorded_macro.txt', 'left_macro.pkl', 'right_macro.pkl']
            cleared_files = 0

            for filename in macro_files:
                if os.path.exists(filename):
                    os.remove(filename)
                    print(f"üóëÔ∏è Arquivo removido: {filename}")
                    cleared_files += 1

            # 2. Limpar cache de templates (TemplateManager)
            if hasattr(self, 'template_manager') and self.template_manager:
                self.template_manager.clear_cache()
                print("üßπ Cache de templates limpo")

            # 3. Limpar caches de detec√ß√£o
            self.clear_detection_cache()

            # 4. Limpar cache de tela e templates na mem√≥ria
            cache_attrs = ['_screen_gray_cache', '_template_cache', '_quick_screen_cache', '_quick_template_cache']
            cleared_memory = 0
            
            for attr in cache_attrs:
                if hasattr(self, attr):
                    cache_obj = getattr(self, attr)
                    if isinstance(cache_obj, dict):
                        cache_obj.clear()
                    delattr(self, attr)
                    cleared_memory += 1
                    print(f"üßπ Cache na mem√≥ria limpo: {attr}")

            # 5. Limpar cache de MSS/screenshots
            if hasattr(self, 'sct'):
                try:
                    self.sct.close()
                    del self.sct
                    self.sct = None
                    print("üì∏ Cache de screenshots MSS limpo")
                except:
                    pass

            # 6. Garbage collection for√ßado
            import gc
            collected = gc.collect()
            print(f"üßπ Garbage collection: {collected} objetos coletados")

            print(f"‚úÖ Cache limpo com sucesso!")
            print(f"   üìÅ {cleared_files} arquivos removidos")
            print(f"   üíæ {cleared_memory} caches de mem√≥ria limpos")
            print("üí° DICA: Se problemas persistirem, reinicie o bot (F1 + F9)")

        except Exception as e:
            print(f"‚ùå Erro ao limpar cache: {e}")
            import traceback
            traceback.print_exc()

        print("="*50)

        if hasattr(self, 'ui') and self.ui:
            try:
                self.ui.main_window.destroy()
            except:
                pass

        if hasattr(self, 'yolo_window') and self.yolo_window:
            try:
                self.yolo_window.destroy()
            except:
                pass

        print("\nüëã Tchau!")

        # For√ßar sa√≠da do programa
        import sys
        sys.exit(0)

    def emergency_stop(self):
        """Manter compatibilidade com c√≥digo antigo"""
        self.full_emergency_stop()

    def initialize_rod_on_start(self):
        """‚ö° Inicializa√ß√£o super r√°pida - Assumir que usu√°rio j√° tem vara equipada"""
        print("\n‚ö° INICIALIZA√á√ÉO R√ÅPIDA")
        print("="*30)
        
        # ‚ö° MODO R√ÅPIDO: Assumir que usu√°rio j√° preparou vara
        print("üé£ Assumindo que vara j√° est√° equipada na m√£o")
        print("üí° Bot detectar√° varas dinamicamente durante a pesca")
        print("‚úÖ Pronto para pescar IMEDIATAMENTE!")
        
        # Definir slot padr√£o para come√ßar
        self.current_rod_slot = 1

    def main_loop(self):
        """Loop principal do bot com sistema de prioridades"""
        # Inicializar vara apenas na primeira vez
        first_cycle = True

        while self.running:
            try:
                # Verificar pausa com responsividade m√°xima
                if self.paused:
                    safe_print("[LOOP] Bot pausado, aguardando...")
                    while self.paused and self.running:
                        time.sleep(0.1)  # Check every 100ms for better responsivity
                    if not self.running:  # Se parou durante pausa
                        break
                    safe_print("[LOOP] Bot retomado!")

                # Inicializar vara na primeira execu√ß√£o
                if first_cycle:
                    self.initialize_rod_on_start()
                    first_cycle = False

                # Processar tarefas priorit√°rias - SEMPRE (podem interromper pesca)
                if self.process_priority_tasks():
                    # Se uma tarefa foi processada, interromper pesca atual
                    if self.game_state.get('fishing_active', False):
                        print("üö® [PRIORIDADE] Interrompendo pesca para executar tarefa priorit√°ria!")
                        self.game_state['fishing_active'] = False
                        self.game_state['action_in_progress'] = False
                        # Liberar bot√£o direito se estiver pressionado
                        if self.game_state.get('right_mouse_down', False):
                            focus_game_window()  # Garantir foco
                            pyautogui.mouseUp(button='right')
                            self.game_state['right_mouse_down'] = False
                    continue

                print(f"\nüé£ Iniciando ciclo {self.ciclos_completados + 1}")

                # Verificar necessidades antes do ciclo
                self.check_system_needs()

                # üîÑ SISTEMA DE MANUTEN√á√ÉO CONT√çNUA (a cada 15 ciclos)
                if self.ciclos_completados % 15 == 0 and self.ciclos_completados > 0:
                    print("\nüîÑ MANUTEN√á√ÉO PERI√ìDICA ATIVADA...")
                    self.add_priority_task(2, "üîß Manuten√ß√£o Peri√≥dica", self.continuous_operation_manager)

                # üîç VERIFICA√á√ÉO PERI√ìDICA DE SLOTS VAZIOS (a cada 10 ciclos) - MANTIDA PARA COMPATIBILIDADE
                elif self.ciclos_completados % 10 == 0 and self.ciclos_completados > 0:
                    print("\nüîç Verifica√ß√£o peri√≥dica de slots...")
                    empty_slots, rods_without_bait = self.check_empty_slots_and_verify()

                    # Se muitos problemas, fazer verifica√ß√£o completa
                    if len(empty_slots) >= 2 or len(rods_without_bait) >= 2:
                        print("‚ö†Ô∏è Muitos problemas detectados, executando manuten√ß√£o cont√≠nua...")
                        self.continuous_operation_manager()

                # üé£ USAR DADOS DO CATCH VIEWER PARA TROCAS INTELIGENTES
                if hasattr(self, 'rod_status_tracking') and self.rod_status_tracking.get('available_with_bait'):
                    # Aplicar troca inteligente se necess√°rio
                    self.apply_intelligent_rod_switching()

                # üîÑ AVAN√áAR SISTEMA DE ANTIGUIDADE A CADA PEIXE
                if hasattr(self, 'rod_age_system'):
                    if self.advance_rod_age_system():
                        print("üîÑ Sistema rotacionado - usando nova dupla")

                # Verificar se √© hora de fazer pausa natural
                if self.check_natural_break():
                    self.execute_natural_break()

                # Micro pausas removidas para melhor performance

                # Executar ciclo de pesca com YOLO
                self.executar_ciclo_completo_yolo()

                # Pausa m√≠nima entre ciclos para m√°xima efici√™ncia
                time.sleep(0.5)  # Pausa reduzida para melhor performance

            except Exception as e:
                print(f"‚ö†Ô∏è Erro no loop principal: {e}")
                time.sleep(5)

    def check_system_needs(self):
        """Verificar todas as necessidades do sistema"""
        # NUNCA verificar nos primeiros 10 ciclos - evitar TAB completamente
        if self.ciclos_completados < 10:
            # Silencioso - n√£o printar nada
            return

        # üé£ VERIFICA√á√ÉO PERI√ìDICA DE VARAS QUEBRADAS (a cada 5 minutos)
        if time.time() - self.rod_system.get('last_rod_check', 0) > 300:  # 5 minutos
            # Apenas verificar se h√° varas quebradas, N√ÉO buscar automaticamente
            if len(self.rod_system.get('available_rods', [])) == 0:
                print("\n‚ö†Ô∏è Verifica√ß√£o peri√≥dica: TODAS as varas quebraram!")
                self.add_priority_task(1, "Buscar varas de reposi√ß√£o", self.search_rods_in_chest)

        # Verificar se precisa trocar vara/dupla
        self.check_rod_switch_needed()

        # üî¥ VERIFICAR VARAS QUEBRADAS primeiro (prioridade m√°xima) - COM TRACKING
        broken_rods = self.detect_broken_rods()
        if broken_rods:
            broken_slots = self.map_broken_rods_to_slots(broken_rods)
            if broken_slots:
                # üéØ FILTRAR varas quebradas j√° processadas
                new_broken_slots = self.filter_new_broken_rods(broken_slots)

                if new_broken_slots:
                    print(f"üî¥ NOVA(S) VARA(S) QUEBRADA(S) DETECTADA(S): {len(new_broken_slots)} slot(s)")

                    # NOVA L√ìGICA: Verificar se pode executar imediatamente ou aguardar
                    if self.game_state.get('fishing_active', False):
                        print("üö® [VARA QUEBRADA] Pesca ativa - agendando para ap√≥s terminar")
                        # Armazenar para execu√ß√£o posterior
                        self.game_state['pending_broken_rods'] = new_broken_slots
                    else:
                        print("‚úÖ [VARA QUEBRADA] Executando sistema de manuten√ß√£o cont√≠nua")
                        self.add_priority_task(1, "üîß Sistema de Manuten√ß√£o Cont√≠nua", self.continuous_operation_manager)
                else:
                    # Todas as varas quebradas detectadas j√° foram processadas
                    if len(broken_slots) > 0:
                        print(f"üîÑ [TRACKING] {len(broken_slots)} vara(s) quebrada(s) j√° processada(s) - ignorando")

        # Verificar se precisa recarregar vara
        if self.need_rod_reload():
            self.add_priority_task(3, "Recarregar vara", self.reload_rod)

        # Verificar se precisa abrir ba√∫ para iscas
        if self.need_baits_from_chest():
            self.add_priority_task(4, "Pegar iscas do ba√∫", self.get_baits_from_chest)

        # üß† SISTEMA DE FILA INTELIGENTE: Detectar opera√ß√µes simult√¢neas e otimizar
        need_feed = self.need_feeding()
        need_clean = self.need_auto_clean()
        need_store = self.need_store_fish()
        need_baits = self.need_baits_from_chest()

        # Contar quantas opera√ß√µes precisam do ba√∫
        chest_operations_needed = 0
        if need_feed: chest_operations_needed += 1
        if need_clean: chest_operations_needed += 1
        if need_store: chest_operations_needed += 1
        if need_baits: chest_operations_needed += 1

        if chest_operations_needed >= 2:
            print(f"üß† [FILA INTELIGENTE] {chest_operations_needed} opera√ß√µes de ba√∫ detectadas - otimizando!")

            # Adicionar √† fila inteligente em vez de priority tasks
            if need_feed and need_clean:
                self.add_to_smart_queue('combined', "Alimenta√ß√£o + Limpeza combinada",
                                      self.execute_feeding_and_cleaning_combined, priority=3)
            else:
                if need_feed:
                    self.add_to_smart_queue('chest', "Alimentar", self.execute_feeding, priority=4)
                if need_clean:
                    self.add_to_smart_queue('chest', "Limpeza autom√°tica", self.execute_auto_clean, priority=6)

            if need_store:
                self.add_to_smart_queue('chest', "Guardar peixes no ba√∫", self.store_fish_in_chest, priority=5)
            if need_baits:
                self.add_to_smart_queue('chest', "Pegar iscas do ba√∫", self.get_baits_from_chest, priority=4)

        else:
            # Poucas opera√ß√µes - usar sistema normal
            if need_feed:
                self.add_priority_task(5, "Alimentar", self.execute_feeding)
            if need_clean:
                self.add_priority_task(7, "Limpeza autom√°tica", self.execute_auto_clean)
            if need_store:
                self.add_priority_task(6, "Guardar peixes no ba√∫", self.store_fish_in_chest)
            if need_baits:
                self.add_priority_task(4, "Pegar iscas do ba√∫", self.get_baits_from_chest)

    def click_esquerdo(self, duration=0.02):
        """Clique esquerdo otimizado"""
        if not self.running:
            return
        pyautogui.mouseDown(button='left')
        time.sleep(duration)
        focus_game_window()  # Garantir foco
        pyautogui.mouseUp(button='left')

    def abrir_barril_esquerda(self):
        """Abertura do barril baseada EXATAMENTE no MyScript.ahk - movimentos sequenciais"""
        print("\n" + "="*50)
        print("ü™£ EXECUTANDO MACRO F5 - MyScript.ahk")
        print("="*50)

        print("ü™£ Executando abertura do barril da esquerda...")

        try:
            # Espera inicial (1188ms do script original)
            time.sleep(1.188)

            # Pressiona LAlt e mant√©m pressionado
            pyautogui.keyDown('alt')
            print("  ‚å®Ô∏è LAlt pressionado")

            # Espera antes dos movimentos (484ms do script original)
            time.sleep(0.484)

            # Sequ√™ncia EXATA de movimentos do MyScript.ahk
            # Click, 959, 540, 0 = mover para (959, 540) sem clicar
            move_sequence = [
                ((959, 540), 16), ((960, 539), 31), ((960, 540), 31), ((960, 539), 16),
                ((960, 540), 15), ((960, 539), 32), ((960, 540), 46), ((960, 539), 32),
                ((960, 540), 0), ((960, 539), 15), ((960, 540), 0), ((960, 539), 16),
                ((960, 540), 31), ((960, 539), 16), ((960, 540), 31), ((960, 539), 47),
                ((960, 540), 16), ((960, 539), 46), ((960, 540), 16), ((960, 539), 78),
                ((960, 540), 16), ((960, 539), 31), ((960, 540), 16), ((960, 539), 15),
                ((960, 540), 16), ((959, 539), 16), ((960, 540), 31), ((960, 539), 15),
                ((960, 540), 16), ((959, 539), 0), ((960, 539), 16), ((959, 540), 15),
                ((960, 540), 47), ((959, 539), 203), ((959, 540), 16), ((960, 540), 16),
                ((959, 539), 15), ((960, 539), 16), ((959, 540), 15), ((960, 539), 110),
                ((959, 539), 265)
            ]

            print("  üñ±Ô∏è Executando sequ√™ncia de movimentos do MyScript.ahk...")
            move_count = 0

            for (x, y), delay_ms in move_sequence:
                if not self.running:
                    break

                # Mover mouse SEM clicar (como no script AHK: Click, x, y, 0)
                pyautogui.moveTo(x, y)
                move_count += 1

                # Delay baseado no script original
                if delay_ms > 0:
                    time.sleep(delay_ms / 1000.0)

            print(f"  üñ±Ô∏è Executados {move_count} movimentos sequenciais")

            # Pressiona E (como no final do script)
            pyautogui.press('e')
            print("  ‚å®Ô∏è Tecla E pressionada")

            # Espera final (985ms do script original)
            time.sleep(0.985)

            # Solta LAlt
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')
            print("  ‚å®Ô∏è LAlt solto")

            print("‚úÖ Abertura do barril da esquerda conclu√≠da!")

        except Exception as e:
            print(f"‚ùå Erro na abertura do barril: {e}")
            # Garantir que LAlt seja solto mesmo em caso de erro
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
                print("  üîß LAlt for√ßadamente liberado por seguran√ßa")
            except:
                pass

    def executar_ciclo_completo(self):
        """Executar ciclo completo de pesca com timeout inteligente"""
        if not self.running:
            return
        print("\nüéÆ Iniciando CICLO DE PESCA...")

        inicio = time.time()
        ciclo_finalizado = False
        timeout_config = self.config.get('cycle_timeout', 60)

        def ciclo():
            nonlocal ciclo_finalizado
            self.executar_fase_rapida_com_tempo()
            if self.running:
                self.executar_fase_lenta_com_cliques()
            ciclo_finalizado = True

        thread_ciclo = threading.Thread(target=ciclo, daemon=True)
        thread_ciclo.start()

        # Aguardar conclus√£o do ciclo ou timeout
        while time.time() - inicio < timeout_config and not ciclo_finalizado:
            if not self.running:
                break
            time.sleep(0.5)

        if not ciclo_finalizado and self.running:
            print(f"‚è±Ô∏è Timeout de {timeout_config}s atingido! Reiniciando ciclo...")
            # Consideramos como linha quebrada - conta como tentativa
            self.ciclos_completados += 1
        else:
            print("üèÜ Ciclo de pesca finalizado com sucesso!")
            self.ciclos_completados += 1
            self.peixes_capturados += 1  # Peixe capturado com sucesso

            # LOG DETALHADO DE PEIXE CAPTURADO
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            self.log_fish_caught_success(timestamp)

            # Imprimir estat√≠sticas a cada 5 peixes
            if self.peixes_capturados % 5 == 0:
                self.print_fish_statistics()

            # Salvar estat√≠sticas a cada 10 peixes
            if self.peixes_capturados % 10 == 0:
                self.save_fish_statistics_to_file()

        # Verificar se precisa alimentar
        self.verificar_alimentacao_otimizada()

    def log_fish_caught_success(self, timestamp):
        """Log detalhado quando peixe √© capturado com sucesso"""
        try:
            # Determinar m√©todo de detec√ß√£o usado
            detection_method = "YOLO"  # Default
            if hasattr(self, '_last_detection_method'):
                detection_method = self._last_detection_method

            # Log entry detalhado
            log_entry = (
                f"[FISH CAUGHT] {timestamp} | "
                f"Peixe #{self.peixes_capturados} | "
                f"M√©todo: {detection_method} | "
                f"Ciclo: {self.ciclos_completados} | "
                f"Total: {self.peixes_capturados}"
            )

            # Escrever no arquivo de log geral
            with open("fishing_log.txt", "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")

            print(f"üìù [LOG] Peixe #{self.peixes_capturados} registrado no log ({detection_method})")

        except Exception as e:
            print(f"‚ùå Erro ao salvar log de peixe: {e}")

    def executar_ciclo_completo_yolo(self):
        """üéØ Executar ciclo completo de pesca com Template Matching - THREAD-SAFE VERSION"""
        if not self.running:
            return

        # VERIFICA√á√ÉO CR√çTICA: N√£o iniciar pesca se outras a√ß√µes est√£o em progresso
        if self.game_state.get('action_in_progress', False):
            action_type = "desconhecida"
            if self.game_state.get('feeding_active', False):
                action_type = "alimenta√ß√£o"
            elif self.game_state.get('cleaning_active', False):
                action_type = "limpeza"
            elif self.game_state.get('broken_rod_active', False):
                action_type = "vara quebrada"

            print(f"‚è∏Ô∏è [COORDENA√á√ÉO] Pesca bloqueada - {action_type} em progresso")
            return

        print("\nüéÆ Iniciando CICLO DE PESCA COM YOLO...")

        inicio = time.time()
        peixe_capturado = False
        timeout_config = self.config.get('cycle_timeout', 60)
        ciclo_finalizado = False

        # MARCAR PESCA COMO ATIVA - IMPEDE SOBREPOSI√á√ïES
        self.game_state['fishing_active'] = True
        self.game_state['action_in_progress'] = True

        # LIMPAR flag residual no in√≠cio de cada NOVO ciclo
        print("üßπ [DEBUG] Limpando detec√ß√µes residuais do ciclo anterior...")
        self.clear_catch_detection_safe()
        print("‚úÖ [DEBUG] Flag de detec√ß√£o limpa para novo ciclo")

        # NOVA ABORDAGEM: Executar TUDO na thread principal, sem threading paralelo
        try:
            # FASE 1: Executar pesca r√°pida
            print("üéØ Iniciando FASE R√ÅPIDA...")
            self.executar_fase_rapida_com_tempo()

            if not self.running:
                return

            # FASE 2: Executar pesca lenta
            print("üê¢ Iniciando FASE LENTA...")
            self.peixe_detectado_fase_lenta = False  # Reset flag
            self.executar_fase_lenta_com_cliques()

            # Verificar se peixe foi detectado DURANTE a fase lenta
            if getattr(self, 'peixe_detectado_fase_lenta', False):
                print("üéØ [MAIN] Peixe detectado durante fase lenta!")
                detected, confidence = self.check_catch_detection_safe()
                print(f"üéØ [MAIN] Processando detec√ß√£o com confian√ßa: {confidence:.3f}")
                print("‚è≥ Aguardando 3s para pegar o peixe...")
                
                # üõë PARAR TODOS OS CLIQUES IMEDIATAMENTE
                self.game_state['peixe_detectado_fase_lenta'] = True
                print("üõë [CLIQUES] Parando cliques - peixe detectado!")
                
                # Liberar bot√£o direito se estiver pressionado
                if self.game_state.get('right_mouse_down', False):
                    focus_game_window()  # Garantir foco
                    pyautogui.mouseUp(button='right')
                    self.game_state['right_mouse_down'] = False
                    print("üîÑ Bot√£o direito liberado")
                
                time.sleep(3)  # Aguardar coleta do peixe
                peixe_capturado = True
                self.clear_catch_detection_safe()  # Limpar flag

            # FASE 3: Monitorar por captura com YOLO (apenas se ainda n√£o capturou)
            if not peixe_capturado:
                print("üëÅÔ∏è Monitorando capturas com YOLO...")

                # N√ÉO limpar flag aqui - pode apagar detec√ß√µes do background!

                while time.time() - inicio < timeout_config and not peixe_capturado:
                    if not self.running:
                        break

                    try:
                        # PRIMEIRO: Verificar se o sistema em background j√° detectou (thread-safe)
                        detected, confidence = self.check_catch_detection_safe()
                        if detected:
                            print(f"üéØ [MAIN] Peixe detectado pelo sistema em background! Conf: {confidence:.3f}")
                            print("‚è≥ Aguardando 3s para pegar o peixe...")
                            
                            # üõë PARAR TODOS OS CLIQUES IMEDIATAMENTE
                            self.game_state['peixe_detectado_fase_lenta'] = True
                            print("üõë [CLIQUES] Parando cliques - peixe detectado!")
                            
                            # Liberar bot√£o direito se estiver pressionado
                            if self.game_state.get('right_mouse_down', False):
                                focus_game_window()  # Garantir foco
                                pyautogui.mouseUp(button='right')
                                self.game_state['right_mouse_down'] = False
                                print("üîÑ Bot√£o direito liberado")
                            
                            time.sleep(3)  # Aguardar coleta do peixe
                            peixe_capturado = True
                            self.clear_catch_detection_safe()  # Limpar flag
                            break

                        # FALLBACK: Fazer detec√ß√£o inline tamb√©m (caso background falhe)
                        template_path = "templates/catch.png"

                        # DEBUG: contador de tentativas
                        if not hasattr(self, '_detection_count'):
                            self._detection_count = 0
                            print(f"üîß DEBUG: Usando l√≥gica do CATCH VIEWER no fluxo principal")
                        self._detection_count += 1

                        # Log a cada 50 tentativas (reduzindo spam de logs)
                        if self._detection_count % 50 == 0:
                            elapsed = time.time() - inicio
                            remaining = timeout_config - elapsed
                            print(f"üîç Procurando peixe... {elapsed:.1f}s/{timeout_config}s (restam {remaining:.1f}s) - tentativa #{self._detection_count}")

                        # EXATA IMPLEMENTA√á√ÉO DO CATCH VIEWER
                        if os.path.exists(template_path):
                            # Carregar template - REFATORADO
                            template = load_template_safe(template_path)
                            if template is not None:
                                template_height, template_width = template.shape[:2]

                                # Capturar tela - REFATORADO
                                screen_img = capture_screen_safe(FULL_SCREEN_REGION)

                                # Template matching (IGUAL AO CATCH VIEWER)
                                result = cv2.matchTemplate(screen_img, template, cv2.TM_CCOEFF_NORMED)
                                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                                # Testar thresholds (MAIS RIGOROSO PARA EVITAR FALSOS POSITIVOS)
                                thresholds = [0.9, 0.8, 0.7, 0.65]  # Removido 0.6 e 0.5
                                best_match = None
                                best_threshold = 0
                                match_location = None

                                for threshold in thresholds:
                                    if max_val >= threshold:
                                        best_match = max_val
                                        best_threshold = threshold
                                        match_location = max_loc
                                        break

                                # Se detectou ACIMA DE 0.65 (MAIS RIGOROSO PARA EVITAR FALSOS POSITIVOS)
                                if best_match is not None and best_match > 0.65:
                                    print(f"üêü [MAIN FLOW] PEIXE CAPTURADO DETECTADO! Confian√ßa: {best_match:.3f}")
                                    print("‚è≥ Aguardando 3s para pegar o peixe...")
                                    
                                    # üõë PARAR TODOS OS CLIQUES IMEDIATAMENTE
                                    self.game_state['peixe_detectado_fase_lenta'] = True
                                    print("üõë [CLIQUES] Parando cliques - peixe detectado!")
                                    
                                    # Liberar bot√£o direito se estiver pressionado
                                    if self.game_state.get('right_mouse_down', False):
                                        focus_game_window()  # Garantir foco
                                        pyautogui.mouseUp(button='right')
                                        self.game_state['right_mouse_down'] = False
                                        print("üîÑ Bot√£o direito liberado")
                                    
                                    time.sleep(3)  # CR√çTICO: Esperar peixe ser coletado
                                    print(f"üéØ SAINDO DO LOOP DE DETEC√á√ÉO - PEIXE ENCONTRADO!")
                                    print(f"üîß DEBUG: Definindo peixe_capturado = True")
                                    peixe_capturado = True
                                    break

                    except Exception as e:
                        print(f"‚ö†Ô∏è Erro na detec√ß√£o inline: {e}")
                        import traceback
                        traceback.print_exc()

                    if not peixe_capturado:
                        # Verifica√ß√£o mais frequente para 'peixe capturado' - CR√çTICO para velocidade
                        time.sleep(0.2)  # Verificar a cada 0.2s (5x por segundo)

        except Exception as e:
            print(f"‚ùå Erro no ciclo de pesca: {e}")
        finally:
            # CR√çTICO: Sempre limpar estado
            self.game_state['fishing_active'] = False
            self.game_state['action_in_progress'] = False

            # üî¥ VERIFICAR VARAS QUEBRADAS PENDENTES ap√≥s pesca terminar
            if self.game_state.get('pending_broken_rods'):
                print("üö® [VARA QUEBRADA] Executando procedimento pendente ap√≥s pesca...")
                pending_broken_rods = self.game_state['pending_broken_rods']
                del self.game_state['pending_broken_rods']  # Limpar pend√™ncia

                # Aguardar um pouco para garantir que n√£o h√° inputs conflitantes
                time.sleep(0.5)

                # Executar procedimento de vara quebrada com PRIORIDADE M√ÅXIMA
                self.add_priority_task(1, "üîß [PENDENTE] Recuperar isca e descartar vara quebrada", lambda: self.replace_broken_rods(pending_broken_rods))
                print("‚úÖ [VARA QUEBRADA] Procedimento agendado para execu√ß√£o imediata")

        # Processar resultado
        print(f"üîß DEBUG: Verificando peixe_capturado = {peixe_capturado}")
        if peixe_capturado:
            print("üèÜ PEIXE CAPTURADO COM SUCESSO!")
            print("üîÑ Processando resultado da captura...")

            # üîç VERIFICAR VARA QUEBRADA AP√ìS PESCA CONCLU√çDA
            print("üîç Verificando se vara quebrou durante a pesca...")
            self.check_for_broken_rod_after_fishing()

            # üîÑ RESETAR CONTADORES DE TIMEOUT (PESCA BEM-SUCEDIDA)
            self.reset_timeout_counters()

            # üé£ NOVO: Atualizar uso da vara atual (pesca bem-sucedida)
            current_rod_number = self.get_absolute_rod_number()
            rod_status = self.update_rod_usage(current_rod_number, is_timeout=False)

            # Verificar se precisa recarregar vara
            if rod_status == 'needs_reload':
                print(f"üîß Vara {current_rod_number} precisa ser recarregada!")

                # Verificar se auto-reload est√° habilitado
                if self.config.get('rod_reload_system', {}).get('auto_reload_enabled', True):
                    print("üîÑ Auto-reload habilitado - iniciando recarga autom√°tica...")
                    reload_success = self.auto_reload_rod(current_rod_number)

                    if reload_success:
                        print(f"‚úÖ Vara {current_rod_number} recarregada com sucesso!")
                    else:
                        print(f"‚ùå Falha na recarga autom√°tica da vara {current_rod_number}")
                        print("‚ö†Ô∏è Pode ser necess√°ria interven√ß√£o manual")
                else:
                    print("‚ö†Ô∏è Auto-reload desabilitado - interven√ß√£o manual necess√°ria")

            elif rod_status == 'broken':
                print(f"üíî Vara {current_rod_number} quebrou! Precisa trocar!")
                print("‚ö†Ô∏è Implementa√ß√£o de troca autom√°tica em desenvolvimento")

            self.rod_system['catches_count'] += 1
            self.peixes_capturados += 1

            # Incrementar contador para pausas naturais
            if self.anti_detection['enabled'] and self.anti_detection['natural_breaks']['enabled']:
                self.anti_detection['natural_breaks']['catches_since_break'] += 1

            # Incrementar contador de pescas para alimenta√ß√£o
            if not hasattr(self.alimentacao, 'catches_since_feed'):
                self.alimentacao['catches_since_feed'] = 0
            self.alimentacao['catches_since_feed'] += 1
            print(f"üçΩÔ∏è Pescas desde √∫ltima alimenta√ß√£o: {self.alimentacao['catches_since_feed']}")

            # Incrementar contador para limpeza autom√°tica (captura real)
            self.increment_fish_count(is_real_catch=True)

            # Verificar se precisa fazer limpeza autom√°tica
            if self.need_auto_clean():
                print("üßπ [COORDENA√á√ÉO] Limpeza autom√°tica necess√°ria!")
                print(f"üìä Status: {self.auto_clean['fish_count_since_last']}/{self.auto_clean['interval']} peixes")
                
                # ‚úÖ OTIMIZA√á√ÉO: Removido delay desnecess√°rio de 3s
                print("üßπ [LIMPEZA] Iniciando limpeza autom√°tica imediatamente...")
                
                # EXECUTAR LIMPEZA IMEDIATAMENTE (n√£o aguardar troca de vara)
                print("üßπ [LIMPEZA] Executando limpeza autom√°tica AGORA...")
                try:
                    # Parar pesca completamente
                    self.game_state['fishing_active'] = False
                    self.game_state['peixe_detectado_fase_lenta'] = True  # Para parar A/D e cliques
                    
                    # Liberar controles
                    if self.game_state.get('right_mouse_down', False):
                        focus_game_window()  # Garantir foco
                        pyautogui.mouseUp(button='right')
                        self.game_state['right_mouse_down'] = False
                        print("üñ±Ô∏è Bot√£o direito liberado para limpeza")
                    
                    # Aguardar threads pararem
                    time.sleep(0.5)
                    
                    # Executar limpeza protegida
                    self.execute_auto_clean()
                    
                    # Resetar flags para continuar pescando
                    self.game_state['peixe_detectado_fase_lenta'] = False
                    self.game_state['fishing_active'] = True
                    
                    print("‚úÖ [LIMPEZA] Limpeza autom√°tica conclu√≠da! Continuando ciclo de pesca...")
                    
                    # ‚úÖ CORRE√á√ÉO: N√ÉO fazer return - permitir que fluxo continue
                    # O bot deve continuar com o ciclo normal de troca de varas
                    print("üé£ [LIMPEZA] Continuando fluxo normal - verificando se precisa trocar vara...")
                    
                except Exception as clean_error:
                    print(f"‚ùå [LIMPEZA] Erro durante limpeza autom√°tica: {clean_error}")
                    # Garantir que a pesca continue mesmo com erro
                    self.game_state['peixe_detectado_fase_lenta'] = False
                    self.game_state['fishing_active'] = True
                    
                    # ‚úÖ CORRE√á√ÉO: N√ÉO fazer return - continuar fluxo mesmo com erro
                    print("‚ùå [LIMPEZA] Erro na limpeza, mas continuando fluxo normal...")

            # Incrementar contador para armazenamento autom√°tico
            # Auto_store removido - funcionalidade unificada no auto_clean
            # Incremento j√° √© feito por increment_fish_count()

            # Incrementar contador da vara atual (peixe capturado = 1 uso + 1 ciclo)
            current_rod = self.rod_system['current_rod']
            if current_rod == 1:
                self.rod_system['rod1_usage'] += 1
                self.rod_system['rod1_cycles'] += 1
            else:
                self.rod_system['rod2_usage'] += 1
                self.rod_system['rod2_cycles'] += 1
            
            max_cycles_per_rod = self.rod_system['max_cycles_per_rod']
            print(f"üìä Ciclo registrado: Vara {current_rod}")
            print(f"   üêü Peixes: R1={self.rod_system['rod1_usage']}, R2={self.rod_system['rod2_usage']}")
            print(f"   üîÑ Ciclos: R1={self.rod_system['rod1_cycles']}/{max_cycles_per_rod}, R2={self.rod_system['rod2_cycles']}/{max_cycles_per_rod}")

            # Verificar se precisa trocar dupla de varas (1-2 ‚Üí 3-4 ‚Üí 5-6)
            # NOVA L√ìGICA: Trocar quando AMBAS as varas atingirem 20 CICLOS (peixes + timeouts)
            max_cycles_per_rod = self.rod_system['max_cycles_per_rod']
            rod1_cycles = self.rod_system['rod1_cycles']
            rod2_cycles = self.rod_system['rod2_cycles']

            # Trocar de par quando AMBAS as varas atingirem o limite de CICLOS
            if rod1_cycles >= max_cycles_per_rod and rod2_cycles >= max_cycles_per_rod:
                print(f"üîÑ TROCANDO DUPLA DE VARAS! Vara1: {rod1_cycles}/{max_cycles_per_rod} ciclos, Vara2: {rod2_cycles}/{max_cycles_per_rod} ciclos")
                self.switch_rod_pair()
                return  # Retorna ap√≥s trocar dupla

            # TAB ‚Üí Trocar vara ‚Üí TAB ‚Üí Continuar
            print("üîÑ INICIANDO SEQU√äNCIA DE TROCA DE VARA...")
            print(f"üîß DEBUG: Chamando perform_rod_switch_sequence()")
            try:
                self.perform_rod_switch_sequence()
                print("‚úÖ SEQU√äNCIA DE TROCA DE VARA CONCLU√çDA!")
            except Exception as switch_error:
                print(f"‚ùå ERRO na troca de vara: {switch_error}")
                import traceback
                traceback.print_exc()
            print("üé£ RETORNANDO PARA PR√ìXIMO CICLO DE PESCA...")
            
            # SISTEMA DE LIMPEZA AP√ìS TROCA DE VARA REMOVIDO
            # (Limpeza agora √© executada imediatamente quando necess√°ria)
                
            # GARANTIR limpeza antes do pr√≥ximo ciclo
            print("üßπ [DEBUG] Limpeza final antes do pr√≥ximo ciclo...")
            self.clear_catch_detection_safe()
            
            # ‚úÖ CORRE√á√ÉO: Retornar para que o loop principal continue
            print("üé£ Retornando para loop principal continuar ciclo...")
            # O bot√£o direito j√° est√° pressionado pela perform_rod_switch_sequence()
            # O loop principal detectar√° que pode continuar e iniciar√° novo ciclo automaticamente
            return True  # Indicar sucesso para o loop principal
        else:
            print(f"‚è±Ô∏è Timeout de {timeout_config}s - Linha quebrada!")

            # üîç VERIFICAR VARA QUEBRADA AP√ìS TIMEOUT
            print("üîç Verificando se vara quebrou durante timeout...")
            self.check_for_broken_rod_after_fishing()

            # üé£ NOVO: Atualizar uso da vara atual (timeout conta como uso)
            current_rod_number = self.get_absolute_rod_number()
            rod_status = self.update_rod_usage(current_rod_number, is_timeout=True)

            # Verificar se precisa recarregar vara ap√≥s timeout
            if rod_status == 'needs_reload':
                print(f"üîß Vara {current_rod_number} precisa ser recarregada ap√≥s timeout!")

                # Verificar se auto-reload est√° habilitado
                if self.config.get('rod_reload_system', {}).get('auto_reload_enabled', True):
                    print("üîÑ Auto-reload habilitado - iniciando recarga autom√°tica...")
                    reload_success = self.auto_reload_rod(current_rod_number)

                    if reload_success:
                        print(f"‚úÖ Vara {current_rod_number} recarregada com sucesso ap√≥s timeout!")
                    else:
                        print(f"‚ùå Falha na recarga autom√°tica da vara {current_rod_number} ap√≥s timeout")
                        print("‚ö†Ô∏è Pode ser necess√°ria interven√ß√£o manual")
                else:
                    print("‚ö†Ô∏è Auto-reload desabilitado - interven√ß√£o manual necess√°ria")

            elif rod_status == 'broken':
                print(f"üíî Vara {current_rod_number} quebrou ap√≥s timeout! Precisa trocar!")
                print("‚ö†Ô∏è Implementa√ß√£o de troca autom√°tica em desenvolvimento")

            # üö® SISTEMA INTELIGENTE DE TIMEOUT
            timeout_action = self.handle_timeout_intelligence()

            if timeout_action == "pair_switched":
                print("‚úÖ Mudan√ßa de dupla conclu√≠da - reiniciando ciclo")
                return  # Sair e come√ßar novo ciclo com nova dupla

            elif timeout_action == "rod_switched":
                print("‚úÖ Mudan√ßa de vara conclu√≠da - reiniciando ciclo")
                return  # Sair e come√ßar novo ciclo com nova vara

            else:  # "continue" - timeout isolado
                print("‚è≥ Aguardando 1.5s ap√≥s timeout...")
                time.sleep(1.5)  # CR√çTICO: Esperar mesmo ap√≥s timeout

                # Sequ√™ncia normal de troca de vara (altern√¢ncia regular)
                print("üîÑ INICIANDO SEQU√äNCIA DE TROCA DE VARA AP√ìS TIMEOUT...")
                try:
                    self.perform_rod_switch_sequence()
                    print("‚úÖ SEQU√äNCIA DE TROCA DE VARA CONCLU√çDA (TIMEOUT)!")
                except Exception as switch_error:
                    print(f"‚ùå ERRO na troca de vara ap√≥s timeout: {switch_error}")
                    import traceback
                    traceback.print_exc()

                # Incrementar contador da vara atual
                current_rod = self.rod_system['current_rod']
                if current_rod == 1:
                    self.rod_system['rod1_usage'] += 1
                else:
                    self.rod_system['rod2_usage'] += 1
                max_per_rod = self.config.get('pair_switch_limit', 30)
                print(f"üìä Uso registrado: Vara {current_rod} (R1:{self.rod_system['rod1_usage']}/{max_per_rod}, R2:{self.rod_system['rod2_usage']}/{max_per_rod})")

    def perform_rod_switch_sequence_OLD_BROKEN(self):
        """VERS√ÉO ANTIGA QUEBRADA - REDIRECIONA PARA VERS√ÉO CORRETA"""
        print("‚ùå [AVISO] Chamada para vers√£o antiga da fun√ß√£o!")
        print("üîß Redirecionando para vers√£o correta...")
        # Redirecionar para a vers√£o correta mais abaixo no c√≥digo
        return self.perform_rod_switch_sequence_CORRECT()

    def predict_objects_main_thread_only(self, monitor_region=None):
        """Prever objetos APENAS na main thread para evitar problemas de threading"""
        if not hasattr(self, 'yolo_model') or not self.yolo_model:
            return []

        # Verificar se estamos na thread principal
        if threading.current_thread() is not threading.main_thread():
            print("‚ö†Ô∏è Tentativa de usar YOLO fora da main thread - ignorando")
            return []

        try:
            import torch
            import mss

            # Usar contexto no_grad e lock para m√°xima seguran√ßa
            with torch.no_grad():
                with self.yolo_lock if hasattr(self, 'yolo_lock') and self.yolo_lock else threading.Lock():
                    # Garantir inst√¢ncia MSS thread-safe
                    if not hasattr(self, 'sct') or not self.sct:
                        self.sct = mss.mss()

                    # Capturar tela
                    if monitor_region is None:
                        monitor_region = {"top": 0, "left": 0, "width": 1920, "height": 1080}

                    screenshot = self.sct.grab(monitor_region)
                    img_array = np.array(screenshot)
                    img_rgb = cv2.cvtColor(img_array, cv2.COLOR_BGRA2RGB)

                    # Prever objetos
                    results = self.yolo_model(img_rgb, verbose=False)

                    detections = []
                    class_confidence = self.config.get('class_confidence', {})

                    for result in results:
                        boxes = result.boxes
                        if boxes is not None:
                            for box in boxes:
                                # Extrair informa√ß√µes
                                conf = float(box.conf[0])
                                cls_id = int(box.cls[0])
                                class_name = self.yolo_model.names[cls_id]

                                # Verificar confian√ßa por classe
                                required_conf = class_confidence.get(class_name, 0.5)

                                if conf >= required_conf:
                                    # Coordenadas (x1, y1, x2, y2)
                                    x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
                                    center_x = (x1 + x2) // 2
                                    center_y = (y1 + y2) // 2

                                    detections.append({
                                        'class': class_name,
                                        'confidence': conf,
                                        'bbox': (x1, y1, x2, y2),
                                        'center': (center_x + monitor_region['left'],
                                                 center_y + monitor_region['top'])
                                    })

                    return detections

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o YOLO (main thread): {e}")
            return []

    def detect_objects_thread_safe(self, monitor_region=None):
        """Detectar objetos com YOLO de forma thread-safe - REDIRECT para main thread apenas"""
        # Simplesmente redirecionar para o m√©todo main-thread-only
        return self.detect_objects_main_thread_only(monitor_region)

    def detect_fish_caught_fast(self):
        """Detec√ß√£o PURE TEMPLATE: APENAS Template Matching para 'peixe capturado'"""
        try:
            # DEBUG: Log GARANTIDO para verificar se a fun√ß√£o est√° sendo executada
            if not hasattr(self, '_debug_detection_count'):
                self._debug_detection_count = 0
                print(f"üö® [DEBUG] detect_fish_caught_fast() CHAMADA PELA PRIMEIRA VEZ!")

            self._debug_detection_count += 1

            # A cada 10 tentativas, mostrar que est√° funcionando (mais frequente)
            if self._debug_detection_count % 10 == 0:
                print(f"üîç [TEMPLATE] FUN√á√ÉO EXECUTANDO - tentativa #{self._debug_detection_count}")

            # APENAS TEMPLATE MATCHING - THRESHOLD > 0.5
            if os.path.exists("templates/catch.png"):
                if self._debug_detection_count == 1:
                    print(f"‚úÖ [DEBUG] Arquivo templates/catch.png ENCONTRADO!")

                template_found, template_conf, template_bbox = self.detect_fish_caught_template(threshold=0.5)

                if template_found:
                    print(f"üêü PEIXE CAPTURADO via TEMPLATE! Confian√ßa: {template_conf:.3f} (‚úÖ ACIMA DE 0.5)")
                    print(f"üéØ [TEMPLATE] Detec√ß√£o SUCESSO ap√≥s {self._debug_detection_count} tentativas")
                    self._last_detection_method = "TEMPLATE"  # Registrar m√©todo
                    return True, template_conf
                else:
                    # Log a cada 50 tentativas (mais frequente para debug)
                    if self._debug_detection_count % 50 == 0:
                        print(f"üîç [TEMPLATE] Tentativas {self._debug_detection_count}: sem detec√ß√£o > 0.5 (conf atual: {template_conf:.3f})")
            else:
                if self._debug_detection_count == 1:
                    print(f"‚ùå [DEBUG] Arquivo templates/catch.png N√ÉO ENCONTRADO!")

            # SEM FALLBACK - APENAS TEMPLATE MATCHING
            return False, 0.0

        except Exception as e:
            print(f"‚ö†Ô∏è Erro na detec√ß√£o template: {e}")
            return False, 0.0

    def load_template_image(self, template_path):
        """Carregar imagem template para matching"""
        try:
            if os.path.exists(template_path):
                template = cv2.imread(template_path, cv2.IMREAD_COLOR)
                if template is not None:
                    print(f"‚úÖ Template carregado: {template_path} - Tamanho: {template.shape}")
                    return template
                else:
                    print(f"‚ùå Erro ao carregar template: {template_path}")
                    return None
            else:
                print(f"‚ùå Template n√£o encontrado: {template_path}")
                return None
        except Exception as e:
            print(f"‚ùå Erro ao carregar template: {e}")
            # Auto-limpeza se erro for relacionado a cache
            if "cache" in str(e).lower() or "memory" in str(e).lower():
                self.auto_clear_cache_on_error("load_template_image")
            return None

    def find_template_on_screen(self, template, threshold=0.8, region=None):
        """üöÄ OTIMIZADO: Encontrar template na tela usando OpenCV Template Matching"""
        try:
            if template is None:
                return []

            # Capturar tela
            if region is None:
                region = {"top": 0, "left": 0, "width": 1920, "height": 1080}

            if not hasattr(self, 'sct') or not self.sct:
                import mss
                self.sct = mss.mss()

            screenshot = self.sct.grab(region)
            screen_img = np.array(screenshot)

            # Converter BGRA para BGR (OpenCV format)
            if screen_img.shape[2] == 4:
                screen_img = cv2.cvtColor(screen_img, cv2.COLOR_BGRA2BGR)

            # OTIMIZA√á√ÉO 1: Usar apenas um m√©todo mais r√°pido
            method = cv2.TM_CCOEFF_NORMED  # M√©todo mais eficiente
            matches = []

            # üîÑ PROCESSAMENTO SIMPLES - Convers√£o direta
            screen_processed = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
            template_processed = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

            # Executar template matching com imagens processadas
            result = cv2.matchTemplate(screen_processed, template_processed, method)

            # OTIMIZA√á√ÉO 2: Usar minMaxLoc para match r√°pido se threshold alto
            if threshold > 0.7:
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
                if max_val >= threshold:
                    # Obter dimens√µes do template
                    template_h, template_w = template.shape[:2]
                    x, y = max_loc

                    # Calcular centro e bounding box
                    center_x = x + template_w // 2
                    center_y = y + template_h // 2

                    match_data = {
                        'confidence': float(max_val),
                        'top_left': (x + region['left'], y + region['top']),
                        'center': (center_x + region['left'], center_y + region['top']),
                        'bbox': (x + region['left'], y + region['top'],
                                x + template_w + region['left'], y + template_h + region['top']),
                        'size': (template_w, template_h),
                        'method': method
                    }
                    matches.append(match_data)
            else:
                # Para threshold baixo, usar m√©todo tradicional mas limitado
                locations = np.where(result >= threshold)
                template_h, template_w = template.shape[:2]

                # OTIMIZA√á√ÉO 3: Limitar n√∫mero de matches processados
                max_matches = 10
                count = 0

                for pt in zip(*locations[::-1]):
                    if count >= max_matches:
                        break

                    x, y = pt
                    confidence = result[y, x]

                    # Calcular centro e bounding box
                    center_x = x + template_w // 2
                    center_y = y + template_h // 2

                    match_data = {
                        'confidence': float(confidence),
                        'top_left': (x + region['left'], y + region['top']),
                        'center': (center_x + region['left'], center_y + region['top']),
                        'bbox': (x + region['left'], y + region['top'],
                                x + template_w + region['left'], y + template_h + region['top']),
                        'size': (template_w, template_h),
                        'method': method
                    }
                    matches.append(match_data)
                    count += 1

            # Remover duplicatas pr√≥ximas e ordenar por confian√ßa
            if matches:
                matches = self.filter_duplicate_matches(matches)
                matches.sort(key=lambda x: x['confidence'], reverse=True)
                print(f"üéØ Template matching encontrou {len(matches)} matches")

                for i, match in enumerate(matches[:3]):  # Mostrar top 3
                    print(f"   Match {i+1}: conf={match['confidence']:.3f} centro={match['center']}")

            return matches

        except Exception as e:
            print(f"‚ùå Erro no template matching: {e}")
            # Auto-limpeza se erro for relacionado a cache ou mem√≥ria
            if any(keyword in str(e).lower() for keyword in ["template", "cache", "memory", "array", "shape", "none"]):
                self.auto_clear_cache_on_error("find_template_on_screen")
            return []

    def filter_duplicate_matches(self, matches, min_distance=30):
        """Filtrar matches duplicados que est√£o muito pr√≥ximos"""
        if not matches:
            return []

        filtered_matches = []

        for match in matches:
            is_duplicate = False
            center_x, center_y = match['center']

            for existing_match in filtered_matches:
                ex_x, ex_y = existing_match['center']
                distance = np.sqrt((center_x - ex_x)**2 + (center_y - ex_y)**2)

                if distance < min_distance:
                    # Se a confian√ßa √© maior, substituir
                    if match['confidence'] > existing_match['confidence']:
                        filtered_matches.remove(existing_match)
                        break
                    else:
                        is_duplicate = True
                        break

            if not is_duplicate:
                filtered_matches.append(match)

        return filtered_matches

    def click_template_match(self, template_path, threshold=0.8, region=None, click_offset=(0, 0)):
        """Encontrar template e clicar nele"""
        try:
            # Carregar template se for string (caminho)
            if isinstance(template_path, str):
                template = self.load_template_image(template_path)
            else:
                template = template_path

            if template is None:
                return False

            # Encontrar matches
            matches = self.find_template_on_screen(template, threshold, region)

            if matches:
                # Pegar o match com maior confian√ßa
                best_match = matches[0]
                click_x = best_match['center'][0] + click_offset[0]
                click_y = best_match['center'][1] + click_offset[1]

                print(f"üñ±Ô∏è Clicando no template em ({click_x}, {click_y}) - confian√ßa: {best_match['confidence']:.3f}")
                pyautogui.click(click_x, click_y)
                time.sleep(0.3)
                return True
            else:
                print(f"‚ùå Template n√£o encontrado na tela (threshold: {threshold})")
                return False

        except Exception as e:
            print(f"‚ùå Erro ao clicar no template: {e}")
            # Auto-limpeza se erro for relacionado a cache
            if "template" in str(e).lower() or "cache" in str(e).lower() or "memory" in str(e).lower():
                self.auto_clear_cache_on_error("click_template_match")
            return False

    def wait_for_template(self, template_path, timeout=10, threshold=0.8, region=None):
        """Aguardar template aparecer na tela"""
        try:
            print(f"‚è≥ Aguardando template aparecer (timeout: {timeout}s)...")

            # Carregar template
            if isinstance(template_path, str):
                template = self.load_template_image(template_path)
            else:
                template = template_path

            if template is None:
                return False

            start_time = time.time()

            while time.time() - start_time < timeout:
                matches = self.find_template_on_screen(template, threshold, region)

                if matches:
                    best_match = matches[0]
                    print(f"‚úÖ Template encontrado! Confian√ßa: {best_match['confidence']:.3f}")
                    return best_match

                time.sleep(0.5)  # Verificar a cada 500ms

            print(f"‚è∞ Timeout: Template n√£o apareceu em {timeout}s")
            return False

        except Exception as e:
            print(f"‚ùå Erro ao aguardar template: {e}")
            return False

    def detect_template_with_yolo_fallback(self, template_path, yolo_class_name, threshold=0.8, region=None):
        """Detectar usando template matching como prioridade, YOLO como fallback"""
        try:
            print(f"üîç Tentando template matching para: {template_path}")

            # Tentar template matching primeiro
            matches = []
            template = self.load_template_image(template_path)
            if template is not None:
                matches = self.find_template_on_screen(template, threshold, region)

            if matches:
                print(f"‚úÖ Template matching bem-sucedido: {len(matches)} matches")
                return 'template', matches
            else:
                print(f"‚ö†Ô∏è Template matching falhou, tentando YOLO...")

                # Fallback para YOLO
                yolo_detections = self.detect_objects_main_thread_only(region)

                yolo_matches = []
                for detection in yolo_detections:
                    if detection['class'].lower() == yolo_class_name.lower():
                        yolo_matches.append({
                            'confidence': detection['confidence'],
                            'center': detection['center'],
                            'bbox': detection['bbox'],
                            'method': 'yolo'
                        })

                if yolo_matches:
                    print(f"‚úÖ YOLO detection bem-sucedido: {len(yolo_matches)} matches")
                    return 'yolo', yolo_matches
                else:
                    print(f"‚ùå Ambos os m√©todos falharam")
                    return None, []

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o h√≠brida: {e}")
            return None, []

    # ================================
    # FUN√á√ïES ESPEC√çFICAS DE TEMPLATE MATCHING
    # ================================

    def find_image_on_screen(self, image_path, threshold=0.8):
        """Fun√ß√£o simplificada para encontrar uma imagem na tela"""
        try:
            print(f"üîç Procurando imagem: {image_path}")

            matches = []
            template = self.load_template_image(image_path)
            if template is not None:
                matches = self.find_template_on_screen(template, threshold)

            if matches:
                best_match = matches[0]
                print(f"‚úÖ Imagem encontrada! Posi√ß√£o: {best_match['center']} - Confian√ßa: {best_match['confidence']:.3f}")
                return best_match
            else:
                print(f"‚ùå Imagem n√£o encontrada (threshold: {threshold})")
                return None

        except Exception as e:
            print(f"‚ùå Erro ao procurar imagem: {e}")
            return None

    def click_image_if_found(self, image_path, threshold=0.8, offset=(0, 0)):
        """Clicar na imagem se ela for encontrada na tela"""
        try:
            match = self.find_image_on_screen(image_path, threshold)

            if match:
                click_x = match['center'][0] + offset[0]
                click_y = match['center'][1] + offset[1]

                print(f"üñ±Ô∏è Clicando em ({click_x}, {click_y})")
                pyautogui.click(click_x, click_y)
                time.sleep(0.5)
                return True

            return False

        except Exception as e:
            print(f"‚ùå Erro ao clicar na imagem: {e}")
            return False

    def wait_for_image_and_click(self, image_path, timeout=10, threshold=0.8, offset=(0, 0)):
        """Aguardar imagem aparecer e clicar nela"""
        try:
            print(f"‚è≥ Aguardando imagem aparecer: {image_path}")

            start_time = time.time()
            while time.time() - start_time < timeout:
                if self.click_image_if_found(image_path, threshold, offset):
                    return True
                time.sleep(1)

            print(f"‚è∞ Timeout: Imagem n√£o apareceu em {timeout}s")
            return False

        except Exception as e:
            print(f"‚ùå Erro ao aguardar e clicar: {e}")
            return False

    def check_image_exists(self, image_path, threshold=0.8, region=None):
        """Verificar se uma imagem existe na tela (retorna True/False)"""
        try:
            template = self.load_template_image(image_path)
            if template is None:
                return False

            matches = self.find_template_on_screen(template, threshold, region)
            return len(matches) > 0

        except Exception as e:
            print(f"‚ùå Erro ao verificar imagem: {e}")
            return False

    def save_screenshot_with_matches(self, image_path, threshold=0.8, output_path=None):
        """Salvar screenshot destacando onde o template foi encontrado"""
        try:
            if output_path is None:
                timestamp = time.strftime("%Y%m%d_%H%M%S")
                output_path = f"screenshot_matches_{timestamp}.png"

            # Carregar template
            template = self.load_template_image(image_path)
            if template is None:
                return False

            # Capturar tela
            if not hasattr(self, 'sct') or not self.sct:
                import mss
                self.sct = mss.mss()

            screenshot = self.sct.grab({"top": 0, "left": 0, "width": 1920, "height": 1080})
            screen_img = np.array(screenshot)

            if screen_img.shape[2] == 4:
                screen_img = cv2.cvtColor(screen_img, cv2.COLOR_BGRA2BGR)

            # Encontrar matches
            matches = self.find_template_on_screen(template, threshold)

            # Desenhar ret√¢ngulos nos matches
            for match in matches:
                x1, y1, x2, y2 = match['bbox']
                cv2.rectangle(screen_img, (x1, y1), (x2, y2), (0, 255, 0), 3)

                # Adicionar texto com confian√ßa
                text = f"Conf: {match['confidence']:.3f}"
                cv2.putText(screen_img, text, (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

            # Salvar imagem
            cv2.imwrite(output_path, screen_img)
            print(f"üì∏ Screenshot salvo: {output_path} com {len(matches)} matches destacados")
            return output_path

        except Exception as e:
            print(f"‚ùå Erro ao salvar screenshot: {e}")
            return False

    # ================================
    # EXEMPLO DE USO COM SUA IMAGEM
    # ================================

    def exemplo_uso_template_matching(self):
        """Exemplo de como usar template matching com sua imagem"""
        try:
            print("üéØ EXEMPLO DE TEMPLATE MATCHING")
            print("=" * 50)

            # Caminho para sua imagem (salve a imagem como 'minha_imagem.png' na pasta templates)
            template_path = "templates/minha_imagem.png"

            # 1. Verificar se a imagem existe na tela
            print("1Ô∏è‚É£ Verificando se imagem existe...")
            if self.check_image_exists(template_path, threshold=0.7):
                print("‚úÖ Imagem encontrada na tela!")

                # 2. Encontrar posi√ß√£o exata
                match = self.find_image_on_screen(template_path, threshold=0.7)
                if match:
                    print(f"üìç Posi√ß√£o: {match['center']}")
                    print(f"üéØ Confian√ßa: {match['confidence']:.3f}")

                # 3. Clicar na imagem (opcional)
                # self.click_image_if_found(template_path, threshold=0.7)

                # 4. Salvar screenshot com matches destacados
                self.save_screenshot_with_matches(template_path, threshold=0.7)

            else:
                print("‚ùå Imagem n√£o encontrada na tela")
                print("üí° Dicas:")
                print("   - Verifique se a imagem est√° na pasta 'templates/'")
                print("   - Tente diminuir o threshold (ex: 0.6)")
                print("   - Certifique-se que a imagem est√° vis√≠vel na tela")

        except Exception as e:
            print(f"‚ùå Erro no exemplo: {e}")

    def test_template_matching(self, image_name="minha_imagem.png", threshold=0.7):
        """Fun√ß√£o de teste para template matching - USE ESTA PARA TESTAR!"""
        try:
            print("\n" + "="*60)
            print("üéØ TESTE DE TEMPLATE MATCHING")
            print("="*60)

            template_path = f"templates/{image_name}"

            # Verificar se arquivo existe
            if not os.path.exists(template_path):
                print(f"‚ùå Arquivo n√£o encontrado: {template_path}")
                print("üí° Para usar:")
                print(f"   1. Salve sua imagem como '{image_name}' na pasta 'templates/'")
                print(f"   2. Execute: bot.test_template_matching('{image_name}')")
                return False

            print(f"‚úÖ Arquivo encontrado: {template_path}")
            print(f"üéØ Threshold configurado: {threshold}")
            print()

            # Teste 1: Verificar se existe
            print("1Ô∏è‚É£ Verificando se imagem existe na tela...")
            exists = self.check_image_exists(template_path, threshold)

            if exists:
                print("‚úÖ SUCESSO: Imagem encontrada na tela!")

                # Teste 2: Obter detalhes da detec√ß√£o
                print("\n2Ô∏è‚É£ Obtendo detalhes da detec√ß√£o...")
                match = self.find_image_on_screen(template_path, threshold)

                if match:
                    print(f"üìç Centro: {match['center']}")
                    print(f"üéØ Confian√ßa: {match['confidence']:.3f}")
                    print(f"üì¶ Bounding Box: {match['bbox']}")
                    print(f"üìè Tamanho: {match['size']}")

                # Teste 3: Salvar screenshot com match destacado
                print("\n3Ô∏è‚É£ Salvando screenshot com match destacado...")
                output_file = self.save_screenshot_with_matches(template_path, threshold)
                if output_file:
                    print(f"üì∏ Screenshot salvo: {output_file}")

                # Teste 4: Simular clique (opcional - descomente para ativar)
                print("\n4Ô∏è‚É£ Teste de clique (DESABILITADO por seguran√ßa)")
                print("   Para ativar: descomente a linha abaixo no c√≥digo")
                # self.click_image_if_found(template_path, threshold)

                return True

            else:
                print("‚ùå FALHA: Imagem n√£o encontrada na tela")
                print("\nüí° Dicas para resolver:")
                print(f"   ‚Ä¢ Tente threshold menor: bot.test_template_matching('{image_name}', 0.6)")
                print(f"   ‚Ä¢ Tente threshold menor: bot.test_template_matching('{image_name}', 0.5)")
                print("   ‚Ä¢ Certifique-se que a imagem est√° vis√≠vel na tela")
                print("   ‚Ä¢ Verifique se a resolu√ß√£o da tela √© 1920x1080")
                print("   ‚Ä¢ A imagem pode estar em posi√ß√£o/tamanho diferente")

                return False

        except Exception as e:
            print(f"‚ùå Erro no teste: {e}")
            return False
        finally:
            print("\n" + "="*60)

    def quick_template_test(self):
        """Teste r√°pido - assume que a imagem est√° salva como 'test.png'"""
        return self.test_template_matching("test.png", 0.7)

    def detect_fish_caught_template(self, threshold=0.5):
        """Detectar peixe capturado - L√ìGICA EXATA DO CATCH VIEWER QUE FUNCIONA"""
        try:
            template_path = "templates/catch.png"

            # Verificar se o arquivo existe
            if not os.path.exists(template_path):
                if not hasattr(self, '_template_warning_shown'):
                    print(f"‚ö†Ô∏è Arquivo catch.png n√£o encontrado em templates/")
                    self._template_warning_shown = True
                return False, 0.0, None

            # Carregar template (EXATA IMPLEMENTA√á√ÉO DO CATCH VIEWER)
            template = cv2.imread(template_path, cv2.IMREAD_COLOR)
            if template is None:
                print(f"‚ùå Erro ao carregar templates/catch.png!")
                return False, 0.0, None

            template_height, template_width = template.shape[:2]

            # Usar MSS diretamente (sem thread safety extra que estava causando problemas)
            import mss
            sct = mss.mss()
            monitors = sct.monitors
            primary_monitor = monitors[1]

            # EXATA regi√£o do CATCH VIEWER
            fish_region = {
                "top": 0,
                "left": 0,
                "width": primary_monitor['width'],
                "height": primary_monitor['height']
            }

            # EXATA captura do CATCH VIEWER
            screenshot = sct.grab(fish_region)
            screen_img = np.array(screenshot)

            # EXATA convers√£o do CATCH VIEWER
            if screen_img.shape[2] == 4:
                screen_img = cv2.cvtColor(screen_img, cv2.COLOR_BGRA2BGR)

            # EXATO template matching do CATCH VIEWER
            result = cv2.matchTemplate(screen_img, template, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

            # üéØ Usar threshold unificado com UI (em vez de hardcoded)
            unified_threshold = self.get_unified_template_threshold("catch.png")
            best_match = None
            best_threshold = 0
            match_location = None

            # Usar threshold da UI em vez de lista hardcoded
            if max_val >= unified_threshold:
                best_match = max_val
                best_threshold = unified_threshold
                match_location = max_loc

            # Usar threshold da UI como condi√ß√£o
            if best_match is not None and best_match >= unified_threshold:
                # Calcular bbox
                if match_location:
                    bbox = (match_location[0], match_location[1],
                           match_location[0] + template_width, match_location[1] + template_height)
                else:
                    bbox = None

                return True, best_match, bbox
            else:
                return False, max_val, None

            # Fechar MSS
            sct.close()

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o template de peixe: {e}")
            return False, 0.0, None

    def log_template_success(self, timestamp, confidence, position, threshold):
        """Log detalhado quando template matching funciona"""
        try:
            # Incrementar contador espec√≠fico de template
            if not hasattr(self, 'template_fish_count'):
                self.template_fish_count = 0
            if not hasattr(self, 'template_successes'):
                self.template_successes = []

            self.template_fish_count += 1

            # Dados do sucesso
            success_data = {
                'timestamp': timestamp,
                'confidence': confidence,
                'position': position,
                'threshold': threshold,
                'count': self.template_fish_count
            }

            self.template_successes.append(success_data)

            # LOG PARA ARQUIVO
            log_entry = (
                f"[TEMPLATE SUCCESS] {timestamp} | "
                f"Peixe #{self.template_fish_count} | "
                f"Confian√ßa: {confidence:.3f} | "
                f"Posi√ß√£o: {position} | "
                f"Threshold: {threshold} | "
                f"Total Template: {self.template_fish_count}"
            )

            # Escrever no arquivo de log
            with open("template_fish_log.txt", "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")

            # Log no console com destaque
            print(f"üìù [LOG] Template Peixe #{self.template_fish_count} salvo no log")

        except Exception as e:
            print(f"‚ùå Erro ao salvar log template: {e}")

    def get_fish_statistics(self):
        """Obter estat√≠sticas completas de peixes capturados"""
        try:
            stats = {
                'total_peixes': getattr(self, 'peixes_capturados', 0),
                'template_peixes': getattr(self, 'template_fish_count', 0),
                'yolo_peixes': 0,
                'template_rate': 0.0,
                'yolo_rate': 0.0,
                'uptime': 0,
                'peixes_por_hora': 0.0
            }

            # Calcular YOLO peixes (total - template)
            stats['yolo_peixes'] = stats['total_peixes'] - stats['template_peixes']

            # Calcular porcentagens
            if stats['total_peixes'] > 0:
                stats['template_rate'] = (stats['template_peixes'] / stats['total_peixes']) * 100
                stats['yolo_rate'] = (stats['yolo_peixes'] / stats['total_peixes']) * 100

            # Calcular uptime e peixes por hora
            if hasattr(self, 'start_time'):
                stats['uptime'] = time.time() - self.start_time
                if stats['uptime'] > 0:
                    stats['peixes_por_hora'] = (stats['total_peixes'] / stats['uptime']) * 3600

            return stats

        except Exception as e:
            print(f"‚ùå Erro ao calcular estat√≠sticas: {e}")
            return {}

    def print_fish_statistics(self):
        """Imprimir estat√≠sticas detalhadas no console"""
        try:
            stats = self.get_fish_statistics()

            print("\n" + "="*60)
            print("üêü ESTAT√çSTICAS DE PEIXES CAPTURADOS")
            print("="*60)
            print(f"üé£ Total de Peixes: {stats.get('total_peixes', 0)}")
            print(f"üéØ Via Template: {stats.get('template_peixes', 0)} ({stats.get('template_rate', 0):.1f}%)")
            print(f"ü§ñ Via YOLO: {stats.get('yolo_peixes', 0)} ({stats.get('yolo_rate', 0):.1f}%)")
            print(f"‚è∞ Tempo Ativo: {stats.get('uptime', 0):.0f}s ({stats.get('uptime', 0)/60:.1f}min)")
            print(f"üìä Peixes/Hora: {stats.get('peixes_por_hora', 0):.1f}")
            print("="*60)

            # Mostrar √∫ltimos sucessos do template
            if hasattr(self, 'template_successes') and self.template_successes:
                print("üéØ √öLTIMOS SUCESSOS DO TEMPLATE:")
                for success in self.template_successes[-5:]:  # √öltimos 5
                    print(f"   #{success['count']}: {success['timestamp']} | Conf: {success['confidence']:.3f}")
                print("="*60)

        except Exception as e:
            print(f"‚ùå Erro ao imprimir estat√≠sticas: {e}")

    def save_fish_statistics_to_file(self):
        """Salvar estat√≠sticas completas em arquivo"""
        try:
            stats = self.get_fish_statistics()
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

            # Arquivo de estat√≠sticas
            with open("fish_statistics.txt", "w", encoding="utf-8") as f:
                f.write("üêü ESTAT√çSTICAS DE PEIXES CAPTURADOS\n")
                f.write("="*50 + "\n")
                f.write(f"Relat√≥rio gerado em: {timestamp}\n\n")

                f.write("üìä RESUMO GERAL:\n")
                f.write(f"Total de Peixes: {stats.get('total_peixes', 0)}\n")
                f.write(f"Via Template: {stats.get('template_peixes', 0)} ({stats.get('template_rate', 0):.1f}%)\n")
                f.write(f"Via YOLO: {stats.get('yolo_peixes', 0)} ({stats.get('yolo_rate', 0):.1f}%)\n")
                f.write(f"Tempo Ativo: {stats.get('uptime', 0):.0f}s ({stats.get('uptime', 0)/60:.1f}min)\n")
                f.write(f"Peixes por Hora: {stats.get('peixes_por_hora', 0):.1f}\n\n")

                # Detalhes dos sucessos do template
                if hasattr(self, 'template_successes') and self.template_successes:
                    f.write("üéØ HIST√ìRICO TEMPLATE MATCHING:\n")
                    for success in self.template_successes:
                        f.write(f"Peixe #{success['count']}: {success['timestamp']} | ")
                        f.write(f"Confian√ßa: {success['confidence']:.3f} | ")
                        f.write(f"Posi√ß√£o: {success['position']}\n")

            print(f"üìä Estat√≠sticas salvas em: fish_statistics.txt")

        except Exception as e:
            print(f"‚ùå Erro ao salvar estat√≠sticas: {e}")

    def detect_fish_caught_hybrid(self, template_threshold=0.7, yolo_threshold=0.8):
        """Detectar peixe capturado - Template PRIMEIRO, YOLO como fallback"""
        try:
            # PRIORIDADE 1: Template matching (mais preciso)
            template_found, template_conf, template_bbox = self.detect_fish_caught_template(template_threshold)

            if template_found:
                print(f"‚úÖ Peixe detectado via TEMPLATE! Confian√ßa: {template_conf:.3f}")
                return True, template_conf

            # FALLBACK: YOLO detection
            print("üîÑ Template falhou, tentando YOLO...")
            yolo_found, yolo_conf = self.detect_fish_caught_fast()

            if yolo_found:
                print(f"‚úÖ Peixe detectado via YOLO! Confian√ßa: {yolo_conf:.3f}")
                return True, yolo_conf

            return False, 0.0

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o h√≠brida: {e}")
            return False, 0.0

    def wait_for_fish_caught_template(self, timeout=60, check_interval=0.2):
        """Aguardar peixe ser capturado usando template matching"""
        try:
            print(f"üé£ Aguardando peixe ser capturado (template) - timeout: {timeout}s")

            start_time = time.time()

            while time.time() - start_time < timeout:
                if not self.running:
                    break

                # Verificar se peixe foi capturado
                fish_caught, confidence, bbox = self.detect_fish_caught_template()

                if fish_caught:
                    print(f"üêü PEIXE CAPTURADO! Tempo: {time.time() - start_time:.1f}s | Confian√ßa: {confidence:.3f}")
                    return True, confidence

                time.sleep(check_interval)

            print(f"‚è∞ Timeout: Peixe n√£o capturado em {timeout}s")
            return False, 0.0

        except Exception as e:
            print(f"‚ùå Erro ao aguardar peixe: {e}")
            return False, 0.0

    def setup_catch_template(self):
        """Configurar e testar template de catch.png"""
        try:
            print("\n" + "="*50)
            print("üêü CONFIGURANDO DETEC√á√ÉO DE PEIXE CAPTURADO")
            print("="*50)

            template_path = "templates/catch.png"

            # Verificar se arquivo existe
            if not os.path.exists(template_path):
                print(f"‚ùå ERRO: Arquivo n√£o encontrado: {template_path}")
                print("\nüí° SOLU√á√ÉO:")
                print("1. Salve a imagem como 'catch.png' na pasta 'templates/'")
                print("2. Execute novamente: bot.setup_catch_template()")
                return False

            print(f"‚úÖ Arquivo encontrado: {template_path}")

            # Carregar e verificar template
            template = self.load_template_image(template_path)
            if template is None:
                print("‚ùå Erro ao carregar template")
                return False

            print(f"üìè Dimens√µes do template: {template.shape}")

            # Teste de detec√ß√£o
            print("\nüîç Testando detec√ß√£o atual...")

            # Testar com diferentes thresholds
            thresholds = [0.8, 0.7, 0.6, 0.5]

            for threshold in thresholds:
                print(f"\nüéØ Testando threshold {threshold}...")
                found, conf, bbox = self.detect_fish_caught_template(threshold)

                if found:
                    print(f"‚úÖ SUCESSO! Peixe detectado com threshold {threshold} | Confian√ßa: {conf:.3f}")

                    # Salvar screenshot do resultado
                    output_file = self.save_screenshot_with_matches(template_path, threshold)
                    if output_file:
                        print(f"üì∏ Screenshot salvo: {output_file}")

                    break
                else:
                    print(f"‚ùå N√£o detectado com threshold {threshold}")

            print("\n" + "="*50)
            print("‚úÖ Configura√ß√£o conclu√≠da!")
            print("üí° Para usar na pesca:")
            print("   fish_caught, conf = bot.detect_fish_caught_template()")
            print("="*50)

            return True

        except Exception as e:
            print(f"‚ùå Erro na configura√ß√£o: {e}")
            return False

    def perform_rod_switch_sequence_SLOTS_REAIS(self):
        """üé£ VERS√ÉO INTELIGENTE: Prioriza varas COM ISCA sempre"""
        print("\n" + "="*50)
        print("üîÑ TROCA DE VARA INTELIGENTE - APENAS VARAS COM ISCA")
        print("="*50)

        # DETECTAR VARAS E MAPEAR ISCA
        print("\nüìç DETECTANDO VARAS E MAPEANDO ISCAS...")
        rod_slots = self.get_current_rod_status()

        if not rod_slots:
            print("‚ùå Nenhuma vara detectada!")
            return None

        # Determinar vara atual
        current_slot = getattr(self, 'current_rod_slot', None)

        # Verificar se vara atual precisa recarga
        if current_slot and self.should_reload_current_rod(current_slot, rod_slots):
            print(f"üîß VARA ATUAL (slot {current_slot}) PRECISA DE RECARGA!")
            # Tentar recarregar primeiro
            if self.smart_reload_current_rod(current_slot):
                print(f"‚úÖ Vara {current_slot} recarregada com sucesso!")
                return current_slot
            else:
                print(f"‚ö†Ô∏è Falha ao recarregar vara {current_slot}, buscando alternativa...")

        # Encontrar pr√≥xima vara com isca
        if current_slot:
            # Tentar trocar no par primeiro
            next_slot = self.get_next_baited_rod_in_pair(current_slot, rod_slots)
        else:
            # Selecionar melhor vara com isca dispon√≠vel
            next_slot = self.get_best_rod_with_bait(rod_slots)

        # üõ°Ô∏è VALIDA√á√ÉO FINAL: Garantir que vara selecionada tem isca
        if next_slot:
            if not self.validate_rod_before_use(next_slot, rod_slots):
                print("üö® [VALIDA√á√ÉO] Vara selecionada rejeitada - buscando alternativa...")
                next_slot = self.get_best_rod_with_bait(rod_slots)

        if not next_slot:
            print("‚ùå CR√çTICO: Nenhuma vara com isca no par atual!")
            print("üîÑ EXECUTANDO REORGANIZA√á√ÉO DIN√ÇMICA DE PARES...")

            # Tentar reorganizar pares baseado nas varas realmente dispon√≠veis
            if self.reorganize_rod_pairs_dynamically():
                print("‚úÖ Pares reorganizados! Usando nova vara selecionada.")
                return self.current_rod_slot
            else:
                print("üîß Reorganiza√ß√£o falhou, tentando recarregar varas...")
                return self.handle_no_baited_rods(rod_slots)

        # Trocar para a vara selecionada
        print(f"\nüéÆ TROCANDO PARA VARA COM ISCA - SLOT {next_slot}")
        pyautogui.press(str(next_slot))
        self.current_rod_slot = next_slot  # Atualizar vara atual

        print(f"   ‚úÖ Vara no slot {next_slot} selecionada (com isca)!")
        return next_slot

    def smart_reload_current_rod(self, rod_slot):
        """üîß Recarregar vara atual com isca de forma otimizada"""
        print(f"üîß Tentando recarregar vara {rod_slot} com isca...")

        # N√£o recarregar automaticamente nos primeiros ciclos para evitar TAB no in√≠cio
        if self.ciclos_completados < 3:
            print("‚è∏Ô∏è Aguardando alguns ciclos antes de recarregar automaticamente...")
            return False

        try:
            # Abrir invent√°rio
            pyautogui.press('tab')
            time.sleep(0.3)

            # Detectar iscas dispon√≠veis usando sistema de prioridade configur√°vel
            detections = self.detect_objects()
            best_bait = self.get_best_available_bait(detections)

            if not best_bait:
                print("‚ùå Nenhuma isca dispon√≠vel no invent√°rio!")
                pyautogui.press('tab')  # Fechar invent√°rio
                return False

            print(f"ü•© Aplicando {best_bait['class']} na vara {rod_slot}...")

            # Clicar na isca (bot√£o direito)
            x, y = best_bait['center']
            pyautogui.moveTo(x, y, duration=0.1)
            pyautogui.rightClick()
            time.sleep(0.2)

            # Fechar invent√°rio
            pyautogui.press('tab')
            time.sleep(0.3)

            print(f"‚úÖ Vara {rod_slot} recarregada com {best_bait['class']}!")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao recarregar vara: {e}")
            pyautogui.press('tab')  # Garantir que invent√°rio est√° fechado
            return False

    def handle_no_baited_rods(self, rod_slots):
        """üö® Lidar com situa√ß√£o cr√≠tica: nenhuma vara com isca"""
        print("\nüö® SITUA√á√ÉO CR√çTICA: Nenhuma vara com isca dispon√≠vel!")

        # Tentar recarregar todas as varas vazias
        empty_rods = {slot: info for slot, info in rod_slots.items()
                     if not info.get('has_bait', False)}

        if empty_rods:
            print(f"üîß Tentando recarregar {len(empty_rods)} vara(s) vazia(s)...")
            for slot in empty_rods.keys():
                if self.smart_reload_current_rod(slot):
                    print(f"‚úÖ Vara {slot} recarregada! Usando esta vara.")
                    return slot

        # √öltimo recurso: buscar iscas no ba√∫
        print("üì¶ √öltima tentativa: buscando iscas no ba√∫...")
        if self.get_baits_from_chest():
            # Re-detectar varas ap√≥s pegar iscas
            rod_slots = self.get_current_rod_status()
            return self.get_best_rod_with_bait(rod_slots)

        print("‚ùå FALHA TOTAL: N√£o foi poss√≠vel encontrar/carregar vara com isca!")
        return None

    def perform_rod_switch_sequence_CORRECT(self):
        """VERS√ÉO ORIGINAL: Sistema de duplas fixas"""
        print("\n" + "="*50)
        print("üîÑ SEQU√äNCIA P√ìS-CAPTURA (DUPLAS)")
        print("="*50)

        # Primeiro tentar usar slots reais
        real_slot = self.perform_rod_switch_sequence_SLOTS_REAIS()
        if real_slot:
            return  # Sucesso com slots reais

        # Fallback para sistema de duplas
        print("\nüìç MAPEAMENTO DE VARAS (SISTEMA DUPLAS):")
        rod_slots = self.get_current_rod_status()
        if not rod_slots:
            print("   ‚ö†Ô∏è Nenhuma vara detectada pelo YOLO!")

        # Marcar como a√ß√£o em progresso
        self.game_state['action_in_progress'] = True

        try:
            # PASSO 1: Soltar bot√£o direito se estiver pressionado
            print("\n[1/4] Verificando bot√£o direito...")
            if self.game_state.get('right_mouse_down', False):
                print("   ‚Ä¢ Bot√£o direito estava pressionado, soltando...")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='right')
                self.game_state['right_mouse_down'] = False
                print("   ‚úì Bot√£o direito liberado")
            else:
                print("   ‚Ä¢ Bot√£o direito j√° estava solto")

            # PASSO 2: Determinar pr√≥xima vara
            print("\n[2/4] Calculando pr√≥xima vara...")
            current_rod = self.rod_system['current_rod']
            current_pair = self.rod_system['current_pair']

            print(f"   ‚Ä¢ Estado atual: Par={current_pair}, Vara={current_rod}")
            print(f"   ‚Ä¢ Mapeamento: Par 0=(1,2), Par 1=(3,4), Par 2=(5,6)")

            # Obter varas da dupla atual
            if current_pair == 0:
                vara1, vara2 = 1, 2
            elif current_pair == 1:
                vara1, vara2 = 3, 4
            else:  # current_pair == 2
                vara1, vara2 = 5, 6

            print(f"   ‚Ä¢ Dupla atual: Vara {vara1} e Vara {vara2}")

            # Alternar vara
            if current_rod == 1:
                next_vara = vara2
                self.rod_system['current_rod'] = 2
            else:
                next_vara = vara1
                self.rod_system['current_rod'] = 1

            print(f"   ‚Ä¢ Alternando: Vara {current_rod} ‚Üí Vara {self.rod_system['current_rod']}")
            print(f"   ‚Ä¢ Tecla a pressionar: [{next_vara}]")

            # PASSO 3: Pressionar tecla num√©rica
            print(f"\n[3/6] Pressionando tecla [{next_vara}]...")
            pyautogui.press(str(next_vara))
            print(f"   ‚úì Tecla {next_vara} pressionada")

            # PASSO 4: Esperar 1 segundo
            print("\n[4/6] Aguardando 1 segundo...")
            time.sleep(1.0)
            print("   ‚úì Aguardado")

            # PASSO 5: Segurar bot√£o direito do mouse
            print("\n[5/6] Segurando bot√£o direito...")
            pyautogui.mouseDown(button='right')
            self.game_state['right_mouse_down'] = True
            print("   ‚úì Bot√£o direito pressionado")

            # PASSO 6: Esperar mais 1 segundo
            print("\n[6/6] Aguardando mais 1 segundo...")
            time.sleep(1.0)
            print("   ‚úì Aguardado")

            print("\n‚úÖ SEQU√äNCIA CONCLU√çDA!")
            print("   Estado: Vara trocada, bot√£o direito segurando")
            print("   Pr√≥ximo: Iniciar cliques esquerdos para pescar")

            # üéØ TRACKER: Mostrar status das varas ap√≥s a troca
            print("\nüìç MAPEAMENTO DE VARAS AP√ìS A TROCA:")
            time.sleep(0.5)  # Aguardar detec√ß√µes atualizarem
            rod_slots_after = self.get_current_rod_status()
            if not rod_slots_after:
                print("   ‚ö†Ô∏è Nenhuma vara detectada ap√≥s troca!")

            print("="*50 + "\n")

        except Exception as e:
            print(f"‚ùå Erro na sequ√™ncia p√≥s-captura: {e}")
            # Garantir cleanup em caso de erro
            if self.game_state.get('right_mouse_down', False):
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='right')
                self.game_state['right_mouse_down'] = False
        finally:
            self.game_state['action_in_progress'] = False

    def perform_rod_switch_sequence(self):
        """Fun√ß√£o principal - redireciona para vers√£o correta"""
        return self.perform_rod_switch_sequence_CORRECT()

    def executar_fase_rapida_com_tempo(self):
        """Bot√£o direito por 1.6s + cliques r√°pidos otimizados at√© 7.65s"""
        if not self.running:
            return
        print("üéØ Iniciando FASE R√ÅPIDA...")
        inicio = time.time()

        # Verificar se bot√£o direito j√° est√° pressionado (da troca de vara)
        if not self.game_state['right_mouse_down']:
            pyautogui.mouseDown(button='right')
            self.game_state['right_mouse_down'] = True
            print("‚û°Ô∏è Bot√£o direito pressionado")
        else:
            print("‚û°Ô∏è Bot√£o direito j√° est√° pressionado (da troca de vara)")
        
        # ‚è∞ DELAY INICIAL: 2 segundos antes de qualquer clique (SOLICITADO)
        print("‚è∞ Aguardando 2 segundos antes dos cliques...")
        time.sleep(2.0)
        
        # üêå 4 CLIQUES DEVAGAR primeiro (SOLICITADO - 1s cada)
        print("üêå Executando 4 cliques devagar iniciais...")
        for i in range(4):
            if not self.running:
                return
            print(f"   üêå Clique devagar {i+1}/4")
            pyautogui.click(button='left')
            time.sleep(1.0)  # 1 segundo entre cada clique devagar
        
        # Aguardar at√© 1.6s do in√≠cio (se ainda n√£o passou)
        while time.time() - inicio < 1.6 and self.running:
            time.sleep(0.01)

        # Come√ßar cliques r√°pidos at√© 7.65s totais (com varia√ß√£o anti-detec√ß√£o)
        contador = 0
        print("‚ö° Iniciando cliques r√°pidos ap√≥s fase devagar...")
        while time.time() - inicio < 7.65 and self.running:
            while self.paused:
                time.sleep(0.1)

            # Aplicar tempo de rea√ß√£o antes do clique
            if contador == 0:  # Primeiro clique
                self.apply_reaction_time()

            self.click_esquerdo()
            contador += 1

            # Delay otimizado para m√°xima efici√™ncia na pesca
            time.sleep(0.15)  # ~6.7 cliques/s otimizado

            if contador % 10 == 0:
                print(f"   {contador} cliques r√°pidos")

        pyautogui.mouseUp(button='right')
        self.game_state['right_mouse_down'] = False
        print(f"‚úÖ Fase r√°pida finalizada com {contador} cliques")

    def executar_fase_lenta_com_cliques(self):
        """Alterna A/D enquanto clica continuamente - OTIMIZADO para pegar peixes - DURA TODO O TIMEOUT"""
        if not self.running:
            return
        
        # Obter timeout configurado (120s padr√£o, mas suporta personalizado)
        timeout_config = self.config.get('cycle_timeout', 120)
        print(f"üê¢ Iniciando FASE LENTA com cliques... (dura√ß√£o: {timeout_config}s)")
        
        # Marcar tempo de in√≠cio
        inicio_fase_lenta = time.time()

        def clicar_continuamente():
            while self.running and not self.paused:
                # Verificar se threads de clique devem ser pausadas (apenas durante vara quebrada)
                if getattr(self, '_pause_clicking_threads', False):
                    time.sleep(0.1)
                    continue
                
                # CR√çTICO: Parar cliques se peixe foi detectado
                if getattr(self, 'peixe_detectado_fase_lenta', False):
                    print("üõë [CLIQUES] Parando cliques - peixe detectado!")
                    break
                
                # NOVO: Parar cliques se limpeza √© necess√°ria
                if self.need_auto_clean():
                    print("üßπ [CLIQUES] Parando cliques - limpeza necess√°ria!")
                    self.game_state['peixe_detectado_fase_lenta'] = True  # Parar tudo
                    break
                
                # Verificar se ainda est√° dentro do timeout
                if time.time() - inicio_fase_lenta >= timeout_config:
                    break

                self.click_esquerdo()
                
                # Calcular delay baseado na configura√ß√£o de cliques por segundo
                clicks_per_second = self.config.get('clicks_per_second', 12)
                click_delay = 1.0 / clicks_per_second
                time.sleep(click_delay)  # Delay din√¢mico baseado na configura√ß√£o

        thread_cliques = threading.Thread(target=clicar_continuamente, daemon=True)
        thread_cliques.start()

        # Loop A-D cont√≠nuo at√© timeout (ao inv√©s de apenas 20 ciclos)
        ciclo_count = 0
        while time.time() - inicio_fase_lenta < timeout_config:
            if not self.running:
                break
            while self.paused:
                time.sleep(0.1)

            # CR√çTICO: Verificar se peixe j√° foi detectado antes de continuar movimentos
            if getattr(self, 'peixe_detectado_fase_lenta', False):
                print("üõë [A-D] Parando movimentos A/D - peixe j√° detectado!")
                break
            
            # NOVO: Verificar se limpeza √© necess√°ria antes de continuar movimentos
            if self.need_auto_clean():
                print("üßπ [A-D] Parando movimentos A/D - limpeza necess√°ria!")
                self.game_state['peixe_detectado_fase_lenta'] = True  # Parar tudo
                break

            # Verificar se peixe foi detectado DURANTE a fase lenta (thread-safe)
            detected, confidence = self.check_catch_detection_safe()
            if detected:
                print(f"üéØ [FASE LENTA] Peixe detectado durante A-D! Conf: {confidence:.3f}")
                print("üîÑ INTERROMPENDO fase lenta para processar captura...")
                # Retornar um valor especial para indicar detec√ß√£o
                self.peixe_detectado_fase_lenta = True
                break

            # Obter dura√ß√µes variadas para os movimentos
            a_duration = self.get_movement_duration('a')
            d_duration = self.get_movement_duration('d')
            pause_between = self.get_movement_pause()

            # Pressionar A (com dura√ß√£o variada)
            pyautogui.keyDown('a')

            # Sleep fracionado para verificar detec√ß√£o durante movimento
            a_intervals = int(a_duration * 10)  # Dividir em intervalos de 0.1s
            for _ in range(a_intervals):
                time.sleep(0.1)
                
                # Verificar timeout durante movimento A
                if time.time() - inicio_fase_lenta >= timeout_config:
                    pyautogui.keyUp('a')
                    return
                
                # NOVO: Verificar se limpeza necess√°ria durante movimento A
                if self.need_auto_clean():
                    pyautogui.keyUp('a')  # Soltar A imediatamente
                    print("üßπ [DURANTE A] Limpeza necess√°ria - parando movimento A!")
                    self.game_state['peixe_detectado_fase_lenta'] = True
                    return  # Sair da fun√ß√£o imediatamente
                    
                detected, confidence = self.check_catch_detection_safe()
                if detected:
                    pyautogui.keyUp('a')  # Soltar A imediatamente
                    print(f"üéØ [DURANTE A] Peixe detectado! Conf: {confidence:.3f}")
                    print("üîÑ INTERROMPENDO movimento A para processar captura...")
                    self.peixe_detectado_fase_lenta = True
                    return  # Sair da fun√ß√£o imediatamente

            pyautogui.keyUp('a')
            
            # Verificar timeout antes da pausa
            if time.time() - inicio_fase_lenta >= timeout_config:
                break
                
            time.sleep(pause_between)  # Pausa variada entre A-D

            # Verificar novamente antes do D
            detected, confidence = self.check_catch_detection_safe()
            if detected:
                print(f"üéØ [ENTRE A-D] Peixe detectado! Conf: {confidence:.3f}")
                print("üîÑ INTERROMPENDO antes do movimento D...")
                self.peixe_detectado_fase_lenta = True
                return
            
            # NOVO: Verificar se limpeza necess√°ria antes do movimento D
            if self.need_auto_clean():
                print("üßπ [ENTRE A-D] Limpeza necess√°ria - parando antes do movimento D!")
                self.game_state['peixe_detectado_fase_lenta'] = True
                return

            # Verificar timeout antes do D
            if time.time() - inicio_fase_lenta >= timeout_config:
                break

            # Pressionar D (com dura√ß√£o variada)
            pyautogui.keyDown('d')

            # Sleep fracionado para verificar detec√ß√£o durante movimento D
            d_intervals = int(d_duration * 10)  # Dividir em intervalos de 0.1s
            for _ in range(d_intervals):
                time.sleep(0.1)
                
                # Verificar timeout durante movimento D
                if time.time() - inicio_fase_lenta >= timeout_config:
                    pyautogui.keyUp('d')
                    return
                
                # NOVO: Verificar se limpeza necess√°ria durante movimento D
                if self.need_auto_clean():
                    pyautogui.keyUp('d')  # Soltar D imediatamente
                    print("üßπ [DURANTE D] Limpeza necess√°ria - parando movimento D!")
                    self.game_state['peixe_detectado_fase_lenta'] = True
                    return  # Sair da fun√ß√£o imediatamente
                    
                detected, confidence = self.check_catch_detection_safe()
                if detected:
                    pyautogui.keyUp('d')  # Soltar D imediatamente
                    print(f"üéØ [DURANTE D] Peixe detectado! Conf: {confidence:.3f}")
                    print("üîÑ INTERROMPENDO movimento D para processar captura...")
                    self.peixe_detectado_fase_lenta = True
                    return  # Sair da fun√ß√£o imediatamente

            pyautogui.keyUp('d')
            
            # Verificar timeout antes da pausa final
            if time.time() - inicio_fase_lenta >= timeout_config:
                break
                
            time.sleep(pause_between)  # Pausa variada ap√≥s D

            ciclo_count += 1
            if ciclo_count % 10 == 0:
                tempo_decorrido = int(time.time() - inicio_fase_lenta)
                print(f"   Sequ√™ncia A-D #{ciclo_count} | Tempo: {tempo_decorrido}s/{timeout_config}s")

        tempo_total = int(time.time() - inicio_fase_lenta)
        print(f"‚úÖ Fase lenta finalizada! Total: {tempo_total}s | Ciclos A-D: {ciclo_count}")
        
        # GARANTIR que thread de cliques termine tamb√©m
        if getattr(self, 'peixe_detectado_fase_lenta', False):
            print("üõë Aguardando thread de cliques finalizar...")
            # Aguardar um pouco para thread de cliques detectar a flag e parar
            time.sleep(0.2)
            print("‚úÖ Thread de cliques finalizado")

    def verificar_alimentacao_otimizada(self):
        """Verificar se precisa alimentar baseado em configura√ß√£o"""
        if not self.alimentacao.get('ativada', True):
            return

        # üîò SISTEMA DE TRIGGER EXCLUSIVO (APENAS UM ATIVO)
        trigger_mode = self.alimentacao.get('trigger_mode', 'catches')

        if trigger_mode == 'catches':
            # MODO: Trigger por pescas capturadas
            if self.should_feed_based_on_trigger('catches'):
                catches = self.alimentacao.get('catches_since_feed', 0)
                trigger = self.alimentacao['trigger_catches']
                print(f"üçñ [PESCAS] Alimenta√ß√£o ativada! {catches}/{trigger} pescas atingidas")
                self.executar_alimentacao()
                self.alimentacao['catches_since_feed'] = 0  # Reset contador
                return

        elif trigger_mode == 'time':
            # MODO: Trigger por tempo
            if self.should_feed_based_on_trigger('time'):
                minutes = self.alimentacao['trigger_minutes']
                print(f"üçñ [TEMPO] Alimenta√ß√£o ativada! {minutes} minutos atingidos")
                self.executar_alimentacao()
                self.alimentacao['last_feed_time'] = time.time()
                return

        # ‚ö†Ô∏è Sistema fallback removido - agora usa apenas o modo selecionado na interface
        # Se chegou aqui, significa que o trigger selecionado ainda n√£o foi atingido

    # REMOVIDO: verificar_alimentacao() e executar_alimentacao()
    # Sistema fallback antigo - agora usa apenas verificar_alimentacao_otimizada() com triggers configur√°veis

    def need_rod_reload(self):
        """Verificar se precisa recarregar vara - detec√ß√£o autom√°tica YOLO + Template"""
        print("üîç [AUTO-RELOAD] Verificando se precisa recarregar vara...")

        # SISTEMA 1: Detectar "vara" vazia na tela (YOLO)
        if self.yolo_model and self.sct:
            try:
                detections = self.detect_objects()
                for detection in detections:
                    if detection['class'] == 'vara':  # Vara vazia detectada pelo YOLO
                        print(f"üé£ [YOLO] VARA VAZIA detectada! Confian√ßa: {detection['confidence']:.2f}")
                        return True
            except Exception as e:
                print(f"‚ö†Ô∏è Erro na detec√ß√£o YOLO de vara: {e}")

        # SISTEMA 2: Template Matching para varas sem isca e quebradas (ambas conven√ß√µes)
        try:
            template_files = [
                'varasemisca.png', 'semiscavara.png', 'semiscanam.png', 'namaosemisca.png',  # Vara sem isca (todas equivalentes)
                'varacomisca.png', 'comiscavara.png', 'namaocomisca.png', 'comiscanamao.png', 'VARANOBAUCI.png',  # Vara com isca (todas equivalentes)
                'varaquebrada.png'                      # Vara quebrada
            ]
            templates_folder = "templates"

            for template_file in template_files:
                template_path = os.path.join(templates_folder, template_file)
                if os.path.exists(template_path):

                    # Capturar tela
                    screenshot = self.sct.grab(self.sct.monitors[1])
                    screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGBA2RGB)

                    # Carregar template
                    template = cv2.imread(template_path, cv2.IMREAD_COLOR)
                    if template is not None:
                        # Match template
                        result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)
                        _, max_val, _, _ = cv2.minMaxLoc(result)

                        # Usar threshold do template_confidence_manager (igual ao Catch Viewer)
                        template_key = template_file.replace('.png', '')
                        threshold = self.template_confidence_manager.get_template_confidence(template_key)

                        if max_val > threshold:
                            print(f"üé£ [TEMPLATE] {template_file} detectado! Confian√ßa: {max_val:.2f}")
                            return True

            print("‚úÖ [DETEC√á√ÉO] Nenhuma vara vazia detectada - sistema OK")

        except Exception as e:
            print(f"‚ö†Ô∏è Erro na detec√ß√£o de template vara vazia: {e}")

        # SISTEMA 3: Fallback por contador de usos (20 por vara)
        current_rod = self.rod_system['current_rod']
        if current_rod == 1:
            if self.rod_system['rod1_usage'] >= 20:
                print(f"üìä [CONTADOR] Rod {current_rod} atingiu 20 usos - precisa recarregar")
                return True
        else:
            if self.rod_system['rod2_usage'] >= 20:
                print(f"üìä [CONTADOR] Rod {current_rod} atingiu 20 usos - precisa recarregar")
                return True

        return False

    def need_baits_from_chest(self):
        """Verificar se precisa pegar iscas do ba√∫ - VERS√ÉO SEGURA"""
        has_baits = self.safe_check_inventory_contents("baits")
        return not has_baits  # Precisa pegar se N√ÉO tem iscas

    def need_feeding(self):
        """Verificar se precisa alimentar com triggers configur√°veis"""
        # Verificar se alimenta√ß√£o est√° ativada
        if not self.alimentacao.get('enabled', False):
            return False

        # Verificar se ambos slots est√£o esgotados
        if (self.alimentacao['slot1_uses'] >= self.alimentacao['max_uses_per_slot'] and
            self.alimentacao['slot2_uses'] >= self.alimentacao['max_uses_per_slot']):
            print("‚ö†Ô∏è Ambos slots de comida esgotados!")
            return False

        current_time = time.time()
        trigger_type = self.alimentacao.get('trigger_type', 'catches')

        if trigger_type == 'time':
            # Trigger por tempo (minutos)
            trigger_minutes = self.alimentacao['trigger_minutes']
            if trigger_minutes > 0:
                time_since_last = current_time - self.alimentacao['last_feed_time']
                if time_since_last >= (trigger_minutes * 60):
                    print(f"‚è∞ {trigger_minutes} minutos desde √∫ltima alimenta√ß√£o")
                    return True

        elif trigger_type == 'catches':
            # Trigger por pescas capturadas
            trigger_catches = self.alimentacao['trigger_catches']
            catches_since = self.alimentacao.get('catches_since_feed', 0)

            if trigger_catches > 0 and catches_since >= trigger_catches:
                print(f"üé£ {catches_since} pescas desde √∫ltima alimenta√ß√£o!")
                return True

        return False

    def map_rod_slots(self, detections):
        """Mapear detec√ß√µes de varas para slots 1-6 usando coordenadas fixas conhecidas"""

        # üéØ COORDENADAS DOS SLOTS - COORDENADAS REAIS
        SLOT_POSITIONS = {
            1: (709, 1005),   # Slot 1
            2: (805, 1005),   # Slot 2
            3: (899, 1005),   # Slot 3
            4: (992, 1005),   # Slot 4
            5: (1092, 1005),  # Slot 5
            6: (1188, 1005)   # Slot 6
        }

        # Filtrar apenas detec√ß√µes de varas
        rod_detections = []
        for detection in detections:
            class_name = self.yolo_model.names.get(detection['class'], 'unknown')
            if class_name in ['vara', 'vara com isca']:
                rod_detections.append({
                    'detection': detection,
                    'class_name': class_name,
                    'x': detection['x'],
                    'y': detection['y']
                })

        print(f"üîç MAPEAMENTO POR DIST√ÇNCIA - {len(rod_detections)} varas detectadas:")

        rod_slots = {}
        used_detections = set()  # Para evitar dupla atribui√ß√£o

        # Para cada slot, encontrar a vara mais pr√≥xima
        for slot, (slot_x, slot_y) in SLOT_POSITIONS.items():
            best_match = None
            best_distance = float('inf')
            best_index = -1

            for i, rod in enumerate(rod_detections):
                if i in used_detections:
                    continue  # J√° foi atribu√≠da a outro slot

                # Calcular dist√¢ncia euclidiana
                distance = ((rod['x'] - slot_x) ** 2 + (rod['y'] - slot_y) ** 2) ** 0.5

                if distance < best_distance and distance < 100:  # Toler√¢ncia de 100 pixels
                    best_distance = distance
                    best_match = rod
                    best_index = i

            if best_match:
                used_detections.add(best_index)
                rod_slots[slot] = {
                    'detection': best_match['detection'],
                    'class_name': best_match['class_name'],
                    'position': (best_match['x'], best_match['y']),
                    'has_bait': best_match['class_name'] == 'vara com isca',
                    'distance': best_distance,
                    'expected_pos': (slot_x, slot_y)
                }

                status = "üé£" if best_match['class_name'] == 'vara com isca' else "üéØ"
                print(f"üìç Slot {slot}: {best_match['class_name']} {status}")
                print(f"    Detectada: ({best_match['x']:.0f}, {best_match['y']:.0f})")
                print(f"    Esperada:  ({slot_x}, {slot_y})")
                print(f"    Dist√¢ncia: {best_distance:.1f} pixels")
            else:
                print(f"‚ùå Slot {slot}: Nenhuma vara encontrada perto de ({slot_x}, {slot_y})")

        # Mostrar varas n√£o mapeadas
        unmapped_rods = [rod for i, rod in enumerate(rod_detections) if i not in used_detections]
        if unmapped_rods:
            print(f"‚ö†Ô∏è {len(unmapped_rods)} varas n√£o mapeadas:")
            for rod in unmapped_rods:
                print(f"   - {rod['class_name']} em ({rod['x']:.0f}, {rod['y']:.0f})")

        return rod_slots

    def reorganize_rod_pairs_dynamically(self):
        """üîÑ Reorganizar pares baseado nas varas REALMENTE dispon√≠veis e com isca"""
        print("\nüîÑ REORGANIZA√á√ÉO DIN√ÇMICA DE PARES")
        print("="*50)

        # Detectar varas dispon√≠veis no momento
        rod_slots = self.get_current_rod_status()

        if not rod_slots:
            print("‚ùå Nenhuma vara detectada para reorganiza√ß√£o!")
            return False

        # Separar varas COM isca e SEM isca
        baited_rods = []
        empty_rods = []

        for slot, info in rod_slots.items():
            if info.get('has_bait', False):
                baited_rods.append(slot)
            else:
                empty_rods.append(slot)

        print(f"üìä INVENT√ÅRIO DE VARAS:")
        print(f"   ‚Ä¢ Varas COM isca: {sorted(baited_rods)} ({len(baited_rods)} varas)")
        print(f"   ‚Ä¢ Varas SEM isca: {sorted(empty_rods)} ({len(empty_rods)} varas)")

        # Priorizar varas com isca para formar pares
        available_for_pairs = sorted(baited_rods)

        # Adicionar varas vazias apenas se necess√°rio (como √∫ltima op√ß√£o)
        if len(available_for_pairs) < 2:
            print("‚ö†Ô∏è Poucas varas com isca, incluindo algumas vazias temporariamente...")
            available_for_pairs.extend(sorted(empty_rods))

        if len(available_for_pairs) < 2:
            print("‚ùå Varas insuficientes para formar pares!")
            return False

        # Formar novos pares dinamicamente
        new_pairs = []
        for i in range(0, len(available_for_pairs), 2):
            if i + 1 < len(available_for_pairs):
                pair = (available_for_pairs[i], available_for_pairs[i + 1])
                new_pairs.append(pair)
                print(f"   ‚úÖ Par {len(new_pairs)}: Slots {pair[0]} e {pair[1]}")

        # Atualizar sistema de varas
        old_pairs = self.rod_system['pairs']
        self.rod_system['pairs'] = new_pairs
        self.rod_system['current_pair'] = 0  # Resetar para primeiro par
        self.rod_system['current_rod'] = 1   # Come√ßar com primeira vara do par

        print(f"\nüîÑ PARES REORGANIZADOS:")
        print(f"   ‚Ä¢ Antigos: {old_pairs}")
        print(f"   ‚Ä¢ Novos:   {new_pairs}")
        print(f"   ‚Ä¢ Par ativo: {new_pairs[0] if new_pairs else 'Nenhum'}")

        # Selecionar melhor vara com isca do primeiro par
        if new_pairs:
            first_pair = new_pairs[0]

            # Verificar qual vara do par tem isca
            slot1, slot2 = first_pair
            slot1_has_bait = slot1 in baited_rods
            slot2_has_bait = slot2 in baited_rods

            if slot1_has_bait:
                selected_slot = slot1
                self.rod_system['current_rod'] = 1
            elif slot2_has_bait:
                selected_slot = slot2
                self.rod_system['current_rod'] = 2
            else:
                # Nenhuma tem isca, usar primeira mesmo assim
                selected_slot = slot1
                self.rod_system['current_rod'] = 1
                print(f"‚ö†Ô∏è Par {first_pair} n√£o tem varas com isca! Usando slot {selected_slot} temporariamente.")

            print(f"üé£ VARA SELECIONADA: Slot {selected_slot}")
            pyautogui.press(str(selected_slot))
            self.current_rod_slot = selected_slot

            return True

        return False

    def test_broken_rod_scenario(self):
        """üß™ TESTE: Simular cen√°rio de vara quebrada no par ativo"""
        print("\nüß™ SIMULA√á√ÉO: Vara 1 quebrou, analisando rea√ß√£o do sistema...")
        print("="*60)

        # Cen√°rio: Vara 1 quebrou e foi descartada
        # Situa√ß√£o atual: Slots 2, 3 (sem isca), 4 (com isca), 5, 6 dispon√≠veis

        simulated_rods = {
            2: {'has_bait': True, 'class_name': 'vara com isca'},   # Par original (1,2) - s√≥ sobrou 2
            3: {'has_bait': False, 'class_name': 'vara'},           # Sem isca
            4: {'has_bait': True, 'class_name': 'vara com isca'},   # Com isca
            5: {'has_bait': True, 'class_name': 'vara com isca'},   # Com isca
            6: {'has_bait': False, 'class_name': 'vara'}            # Sem isca
        }

        print("üìä SITUA√á√ÉO SIMULADA:")
        for slot, info in simulated_rods.items():
            status = "COM ISCA" if info['has_bait'] else "SEM ISCA"
            print(f"   ‚Ä¢ Slot {slot}: {status}")

        print("\nüîç TESTANDO REORGANIZA√á√ÉO...")

        # Simular reorganiza√ß√£o
        baited_rods = [slot for slot, info in simulated_rods.items() if info['has_bait']]
        empty_rods = [slot for slot, info in simulated_rods.items() if not info['has_bait']]

        print(f"   ‚Ä¢ Varas COM isca: {sorted(baited_rods)}")  # [2, 4, 5]
        print(f"   ‚Ä¢ Varas SEM isca: {sorted(empty_rods)}")   # [3, 6]

        # Formar novos pares priorizando varas com isca
        new_pairs = []
        available_for_pairs = sorted(baited_rods)  # [2, 4, 5]

        for i in range(0, len(available_for_pairs), 2):
            if i + 1 < len(available_for_pairs):
                pair = (available_for_pairs[i], available_for_pairs[i + 1])
                new_pairs.append(pair)

        print(f"\nüîÑ NOVOS PARES FORMADOS: {new_pairs}")  # [(2, 4), (5, ?)]
        print("‚úÖ RESULTADO: Bot usar√° slots 2 e 4 (ambas COM ISCA) ao inv√©s de 2 e 3!")
        print("üéØ SISTEMA EVITOU usar slot 3 (sem isca) automaticamente!")

        return True

    def normalize_item_name(self, item_name):
        """üîß Normalizar nomes de itens para padroniza√ß√£o entre YOLO e Template Matching"""

        # Dicion√°rio de normaliza√ß√£o - mapear varia√ß√µes para nome padr√£o
        normalization_map = {
            # Carne de urso - varia√ß√µes
            'carneurso': 'carne de urso',
            'carnedeurso': 'carne de urso',
            'bear meat': 'carne de urso',
            'bearmeat': 'carne de urso',

            # Carne de lobo - varia√ß√µes (EXPANDIDO)
            'carnedlobo': 'carne de lobo',
            'carnedelobo': 'carne de lobo',
            'wolf meat': 'carne de lobo',
            'wolfmeat': 'carne de lobo',
            'wolfmeatbox': 'carne de lobo',  # NOVO: Caixa de carne de lobo

            # Truta - varia√ß√µes (EXPANDIDO)
            'trout': 'truta',
            'troutt': 'truta',  # NOVO: Varia√ß√£o com duplo T

            # Small trout - varia√ß√µes (EXPANDIDO)
            'smalltrout': 'smalltrout',
            'small trout': 'smalltrout',
            'smalltrour': 'smalltrout',  # NOVO: Varia√ß√£o
            'smalltroutbox': 'smalltrout',  # NOVO: Caixa de smalltrout
            'amalltroutbox': 'smalltrout',  # NOVO: Varia√ß√£o mencionada

            # Worms - varia√ß√µes
            'worm': 'worms',
            'worms': 'worms',

            # Grub - varia√ß√µes (EXPANDIDO)
            'grub': 'grub',
            'grubs': 'grub',

            # Vara - varia√ß√µes
            'fishing rod': 'vara',
            'handmade fishing rod': 'vara',
            'vara de pesca': 'vara',
            'vara de pesca profissional': 'vara',

            # Vara com isca - varia√ß√µes
            'baited fishing rod': 'vara com isca',
            'vara com isca': 'vara com isca'
        }

        # Normalizar nome (converter para lowercase para compara√ß√£o)
        item_lower = item_name.lower().strip()

        # Procurar correspond√™ncia exata
        if item_lower in normalization_map:
            normalized = normalization_map[item_lower]
            if item_lower != normalized:
                print(f"üîß [NORMALIZA√á√ÉO] '{item_name}' ‚Üí '{normalized}'")
            return normalized

        # Se n√£o encontrou correspond√™ncia, retornar original
        return item_name

    def normalize_detection_results(self, detections):
        """üîß Normalizar lista de detec√ß√µes aplicando padroniza√ß√£o de nomes"""
        if not detections:
            return detections

        normalized_detections = []

        for detection in detections:
            # Criar c√≥pia da detec√ß√£o
            normalized_detection = detection.copy()

            # Normalizar nome da classe
            original_class = detection.get('class', '')
            normalized_class = self.normalize_item_name(original_class)
            normalized_detection['class'] = normalized_class

            # Adicionar campo com nome original para debug se necess√°rio
            if original_class != normalized_class:
                normalized_detection['original_class'] = original_class

            normalized_detections.append(normalized_detection)

        return normalized_detections

    def normalize_template_name(self, template_filename):
        """üîß Normalizar nomes de templates para nomes de classe padronizados"""

        # Remover extens√£o .png
        template_name = template_filename.replace('.png', '').lower()

        # Mapeamento de templates para nomes padronizados
        template_to_class_map = {
            # Carne de urso - varia√ß√µes de template
            'carneurso': 'carne de urso',
            'carnedeurso': 'carne de urso',
            'bearmeat': 'carne de urso',
            'bear_meat': 'carne de urso',

            # Carne de lobo - varia√ß√µes de template
            'wolfmeat': 'carne de lobo',
            'wolf_meat': 'carne de lobo',
            'carnedlobo': 'carne de lobo',
            'carnedelobo': 'carne de lobo',

            # Truta
            'trout': 'truta',
            'truta': 'truta',

            # Small trout
            'smalltrout': 'smalltrout',
            'small_trout': 'smalltrout',

            # Worms
            'worm': 'worms',
            'worms': 'worms',

            # Grub
            'grub': 'grub',
            'grubs': 'grub',

            # Vara quebrada
            'varaquebrada': 'vara quebrada',
            'vara_quebrada': 'vara quebrada',
            'broken_rod': 'vara quebrada',

            # Vara com isca
            'varacomisca': 'vara com isca',
            'vara_com_isca': 'vara com isca',
            'comiscavara': 'vara com isca',
            'namaocomisca': 'vara com isca',
            'comiscanamao': 'vara com isca',

            # Vara sem isca
            'varasemisca': 'vara',
            'vara_sem_isca': 'vara',
            'semiscavara': 'vara',
            'semiscanam': 'vara',
            'namaosemisca': 'vara'
        }

        # Procurar correspond√™ncia
        if template_name in template_to_class_map:
            normalized = template_to_class_map[template_name]
            if template_name != normalized.replace(' ', ''):
                print(f"üîß [TEMPLATE] '{template_filename}' ‚Üí '{normalized}'")
            return normalized

        # Se n√£o encontrou, usar o nome do template sem extens√£o
        return template_name

    def test_normalization_system(self):
        """üß™ TESTE: Verificar sistema de normaliza√ß√£o de nomes"""
        print("\nüß™ TESTE DO SISTEMA DE NORMALIZA√á√ÉO")
        print("="*50)

        # Testar varia√ß√µes de nomes de itens
        test_items = [
            'carneurso',
            'carnedeurso',
            'carne de urso',
            'bear meat',
            'wolfmeat',
            'carne de lobo',
            'trout',
            'smalltrout',
            'vara com isca',
            'fishing rod'
        ]

        print("üìã TESTANDO NORMALIZA√á√ÉO DE ITENS:")
        for item in test_items:
            normalized = self.normalize_item_name(item)
            if item.lower() != normalized.lower():
                print(f"   ‚úÖ '{item}' ‚Üí '{normalized}'")
            else:
                print(f"   ‚ûñ '{item}' (sem altera√ß√£o)")

        # Testar templates
        test_templates = [
            'carneurso.png',
            'carnedeurso.png',
            'wolfmeat.png',
            'varacomisca.png',
            'varasemisca.png',
            'varaquebrada.png'
        ]

        print(f"\nüìã TESTANDO NORMALIZA√á√ÉO DE TEMPLATES:")
        for template in test_templates:
            normalized = self.normalize_template_name(template)
            template_clean = template.replace('.png', '')
            if template_clean.lower() != normalized.lower():
                print(f"   ‚úÖ '{template}' ‚Üí '{normalized}'")
            else:
                print(f"   ‚ûñ '{template}' (sem altera√ß√£o)")

        print("\n‚úÖ TESTE DE NORMALIZA√á√ÉO CONCLU√çDO!")

        return True

    def decide_rod_action_when_empty(self, current_slot, rod_slots):
        """ü§î DECIS√ÉO INTELIGENTE: Recarregar vara atual OU reorganizar pares?"""
        print(f"\nü§î DECIS√ÉO: Vara {current_slot} sem isca - Analisando melhor estrat√©gia...")
        print("="*60)

        # Contar iscas dispon√≠veis no invent√°rio
        available_baits = self.count_available_baits()

        # Contar varas com isca dispon√≠veis
        baited_rods = [slot for slot, info in rod_slots.items()
                      if info.get('has_bait', False) and slot != current_slot]

        print(f"üìä SITUA√á√ÉO ATUAL:")
        print(f"   ‚Ä¢ Vara atual (slot {current_slot}): SEM ISCA")
        print(f"   ‚Ä¢ Iscas no invent√°rio: {available_baits['total']} total")
        print(f"   ‚Ä¢ Detalhes: {available_baits['details']}")
        print(f"   ‚Ä¢ Outras varas COM isca: {len(baited_rods)} varas {sorted(baited_rods)}")

        # CRIT√âRIO DE DECIS√ÉO:
        decision_points = 0
        reasons = []

        # +2 pontos: Tem iscas suficientes para recarga
        if available_baits['total'] > 0:
            decision_points += 2
            reasons.append(f"‚úÖ {available_baits['total']} isca(s) dispon√≠vel(is)")
        else:
            decision_points -= 3
            reasons.append("‚ùå Sem iscas no invent√°rio")

        # +1 ponto: Vara atual est√° em par ativo
        current_pair = None
        for pair in self.rod_system.get('pairs', []):
            if current_slot in pair:
                current_pair = pair
                break

        if current_pair:
            decision_points += 1
            reasons.append(f"‚úÖ Vara est√° no par ativo {current_pair}")

        # -2 pontos: Muitas varas com isca dispon√≠veis (melhor reorganizar)
        if len(baited_rods) >= 3:
            decision_points -= 2
            reasons.append(f"‚öñÔ∏è {len(baited_rods)} varas com isca (favorece reorganiza√ß√£o)")
        elif len(baited_rods) >= 1:
            decision_points -= 1
            reasons.append(f"‚öñÔ∏è {len(baited_rods)} vara(s) com isca dispon√≠vel(is)")

        # +1 ponto: √â uma isca de alta prioridade dispon√≠vel
        bait_config = self.config.get('bait_priority', {})
        high_priority_baits = [bait for bait, priority in bait_config.items() if priority <= 2]
        if any(bait in available_baits['details'] for bait in high_priority_baits):
            decision_points += 1
            reasons.append("‚úÖ Isca de alta prioridade dispon√≠vel")

        print(f"\nüßÆ AN√ÅLISE DE DECIS√ÉO:")
        for reason in reasons:
            print(f"   {reason}")
        print(f"   üìä Pontua√ß√£o final: {decision_points}")

        # TOMAR DECIS√ÉO
        if decision_points >= 1:
            decision = "RECARREGAR"
            action = "reload"
            print(f"\n‚úÖ DECIS√ÉO: {decision} vara atual (slot {current_slot})")
            print("   üí° Motivo: Condi√ß√µes favor√°veis para recarga")
        else:
            decision = "REORGANIZAR"
            action = "reorganize"
            print(f"\nüîÑ DECIS√ÉO: {decision} pares dinamicamente")
            print("   üí° Motivo: Melhor usar varas com isca j√° dispon√≠veis")

        return {
            'action': action,
            'decision': decision,
            'score': decision_points,
            'reasons': reasons,
            'available_baits': available_baits,
            'baited_rods_count': len(baited_rods)
        }

    def count_available_baits(self):
        """üîç Contar iscas dispon√≠veis no invent√°rio com detalhes"""
        try:
            detections = self.detect_objects()

            # Lista completa de iscas (incluindo as novas)
            bait_classes = [
                'carne de urso', 'carne de lobo',  # Carnes
                'truta', 'smalltrout',             # Peixes pequenos
                'grub', 'worms',                   # Vermes
                'wolfmeat', 'wolfmeatbox',         # Varia√ß√µes carne de lobo
                'trout', 'smalltroutbox',          # Varia√ß√µes peixes
            ]

            bait_count = {}
            total_baits = 0

            for detection in detections:
                if detection['center'][0] < 1242:  # Invent√°rio do jogador
                    if detection['class'] in bait_classes:
                        bait_type = detection['class']
                        bait_count[bait_type] = bait_count.get(bait_type, 0) + 1
                        total_baits += 1

            return {
                'total': total_baits,
                'details': bait_count
            }

        except Exception as e:
            print(f"‚ùå Erro ao contar iscas: {e}")
            return {'total': 0, 'details': {}}

    def get_best_available_bait(self, detections):
        """üéØ Encontrar a melhor isca dispon√≠vel baseada na prioridade configur√°vel"""
        try:
            # üéØ Usar sistema unificado de prioridade
            if not hasattr(self, 'bait_priority'):
                self.load_bait_priority_config()

            bait_mapping = self.get_bait_template_mapping()
            sorted_bait_names = self.get_sorted_bait_priority()

            print(f"   üéØ Buscando iscas na ordem: {sorted_bait_names}")

            # Encontrar todas as iscas dispon√≠veis no invent√°rio
            available_baits = []
            for detection in detections:
                if detection['center'][0] < 1242:  # Invent√°rio do jogador
                    # Verificar se a detec√ß√£o corresponde a alguma isca conhecida
                    detected_class = detection['class'].lower()

                    for bait_name in sorted_bait_names:
                        template_file = bait_mapping.get(bait_name, '')
                        template_base = template_file.replace('.png', '').lower()

                        # Verificar correspond√™ncia (pode usar v√°rios crit√©rios)
                        if (detected_class == template_base or
                            template_base in detected_class or
                            detected_class in template_base or
                            (bait_name == 'worm' and 'minhoca' in detected_class) or  # üêõ MINHOCA especial
                            (bait_name == 'grub' and ('isca' in detected_class or 'larva' in detected_class))):

                            priority = self.bait_priority.get(bait_name, 999)
                            available_baits.append({
                                'detection': detection,
                                'bait_type': bait_name,
                                'priority': priority,
                                'template': template_file
                            })
                            print(f"   ‚úÖ Isca encontrada: {bait_name} ({template_file}) - prioridade {priority}")
                            break

            if not available_baits:
                print("   ‚ùå Nenhuma isca dispon√≠vel encontrada")
                return None

            # Ordenar por prioridade (1 = maior prioridade)
            available_baits.sort(key=lambda x: x['priority'])

            best_bait = available_baits[0]
            print(f"üéØ Melhor isca selecionada: {best_bait['bait_type']} (prioridade: {best_bait['priority']})")

            return best_bait['detection']

        except Exception as e:
            print(f"‚ùå Erro ao selecionar melhor isca: {e}")
            return None

    def get_best_rod_with_bait(self, rod_slots):
        """üéØ Encontrar a melhor vara COM ISCA para usar - PRIORIDADE M√ÅXIMA"""
        if not rod_slots:
            return None

        # Filtrar apenas varas com isca
        baited_rods = {slot: info for slot, info in rod_slots.items()
                      if info.get('has_bait', False)}

        if not baited_rods:
            print("‚ö†Ô∏è ATEN√á√ÉO: Nenhuma vara com isca encontrada!")
            return None

        # Priorizar por slots (1-6) - usar sempre a primeira dispon√≠vel
        best_slot = min(baited_rods.keys())
        best_rod = baited_rods[best_slot]

        print(f"üé£ VARA COM ISCA SELECIONADA: Slot {best_slot}")
        print(f"   ‚Ä¢ Posi√ß√£o: ({best_rod['position'][0]:.0f}, {best_rod['position'][1]:.0f})")
        # Verificar se campo 'distance' existe antes de usar
        if 'distance' in best_rod:
            print(f"   ‚Ä¢ Dist√¢ncia da posi√ß√£o esperada: {best_rod['distance']:.1f}px")
        else:
            print(f"   ‚Ä¢ Confian√ßa: {best_rod.get('confidence', 0):.2f}")

        return best_slot

    def get_next_baited_rod_in_pair(self, current_slot, rod_slots):
        """üîÑ Trocar para pr√≥xima vara COM ISCA - Sistema Inteligente Adaptativo"""
        if not rod_slots:
            return None

        print(f"\nüîç BUSCA INTELIGENTE DE PR√ìXIMA VARA (atual: slot {current_slot})")

        # Usar pares din√¢micos atuais (n√£o fixos)
        current_pairs = self.rod_system.get('pairs', [(1,2), (3,4), (5,6)])
        current_pair = None

        # Encontrar em qual par est√° a vara atual
        for pair in current_pairs:
            if current_slot in pair:
                current_pair = pair
                break

        if current_pair:
            # Encontrar o outro slot do par
            other_slot = current_pair[1] if current_slot == current_pair[0] else current_pair[0]
            print(f"   üìç Par atual: {current_pair}, tentando slot {other_slot}")

            # Verificar se existe vara no outro slot
            if other_slot in rod_slots:
                if rod_slots[other_slot].get('has_bait', False):
                    print(f"‚úÖ TROCA NO PAR: Slot {current_slot} ‚Üí Slot {other_slot} (COM ISCA)")
                    return other_slot
                else:
                    print(f"‚ö†Ô∏è Slot {other_slot} existe mas SEM ISCA!")
            else:
                print(f"‚ùå Slot {other_slot} do par est√° VAZIO (vara quebrada/ausente)!")
        else:
            print(f"‚ö†Ô∏è Slot {current_slot} n√£o encontrado nos pares atuais: {current_pairs}")

        # üéØ BUSCA INTELIGENTE: Procurar QUALQUER vara com isca dispon√≠vel
        print("üîç BUSCA GERAL: Procurando qualquer vara COM ISCA...")

        available_baited_rods = []
        for slot, info in rod_slots.items():
            if slot != current_slot and info.get('has_bait', False):
                available_baited_rods.append(slot)

        if available_baited_rods:
            # Priorizar por ordem num√©rica (slot menor primeiro)
            best_slot = min(available_baited_rods)
            print(f"üéØ VARA COM ISCA ENCONTRADA: Slot {best_slot}")
            print(f"   üìä Op√ß√µes dispon√≠veis: {sorted(available_baited_rods)}")
            return best_slot

        print("‚ùå SITUA√á√ÉO CR√çTICA: Nenhuma vara com isca dispon√≠vel em lugar nenhum!")
        return None

    def should_reload_current_rod(self, current_slot, rod_slots):
        """üîß Verificar se a vara atual precisa ser recarregada com isca"""
        if not rod_slots or current_slot not in rod_slots:
            return True  # Se n√£o detectamos a vara, assumir que precisa recarga

        rod_info = rod_slots[current_slot]
        has_bait = rod_info.get('has_bait', False)

        if not has_bait:
            print(f"üîß RECARGA NECESS√ÅRIA: Vara no slot {current_slot} est√° sem isca!")
            return True

        print(f"‚úÖ Vara no slot {current_slot} tem isca, n√£o precisa recarregar")
        return False

    def detect_broken_rods(self, screenshot=None):
        """üöÄ OTIMIZADO: Detectar varas quebradas com √°rea de busca reduzida"""
        try:
            import cv2
            import numpy as np
            import os

            # Verificar se template existe
            template_path = "templates/varaquebrada.png"
            if not os.path.exists(template_path):
                print("‚ùå Template varaquebrada.png n√£o encontrado!")
                return []

            # REVERTIDO: Capturar tela inteira para detec√ß√£o completa de vara quebrada
            if screenshot is None:
                import mss
                with mss.mss() as sct:
                    monitor = {"top": 0, "left": 0, "width": 1920, "height": 1080}
                    screenshot = sct.grab(monitor)  # Tela inteira restaurada
                    img_array = np.array(screenshot)
                    # Converter BGRA para RGB
                    if img_array.shape[2] == 4:
                        screenshot = cv2.cvtColor(img_array, cv2.COLOR_BGRA2RGB)
                    else:
                        screenshot = img_array
            # Screenshot fornecido j√° √© processado como est√° (tela inteira)

            # Carregar template
            template = cv2.imread(template_path, cv2.IMREAD_COLOR)
            if template is None:
                print("‚ùå Erro ao carregar template varaquebrada.png")
                return []

            # üîÑ PROCESSAMENTO SIMPLES - Convers√£o direta
            screenshot_gray = cv2.cvtColor(screenshot, cv2.COLOR_RGB2GRAY)
            template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

            # OTIMIZA√á√ÉO 2: Template matching com m√©todo mais r√°pido
            result = cv2.matchTemplate(screenshot_gray, template_gray, cv2.TM_CCOEFF_NORMED)

            # OTIMIZA√á√ÉO 3: Usar threshold do template_confidence_manager (igual ao Catch Viewer)
            threshold = self.template_confidence_manager.get_template_confidence('varaquebrada')
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

            broken_rods = []
            template_h, template_w = template_gray.shape

            if max_val >= threshold:
                # Apenas o melhor match (mais r√°pido)
                x, y = max_loc
                confidence = max_val

                # Coordenadas j√° s√£o globais (tela inteira capturada)
                global_x = x
                global_y = y

                # Centro do match
                center_x = x + template_w // 2
                center_y = y + template_h // 2

                broken_rods.append({
                    'x': center_x,
                    'y': center_y,
                    'confidence': confidence,
                    'template_box': (x, y, x + template_w, y + template_h)
                })

                print(f"üî¥ VARA QUEBRADA detectada em ({center_x}, {center_y}) - Confian√ßa: {confidence:.3f}")

            # Mapear para slots conhecidos
            broken_slots = self.map_broken_rods_to_slots(broken_rods)

            return broken_rods

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o de vara quebrada: {e}")
            return []

    def detect_eat_button_position(self):
        """üçñ NOVO: Detectar posi√ß√£o din√¢mica do bot√£o 'eat' usando template matching"""
        try:
            import cv2
            import numpy as np
            import mss

            # Verificar se template eat.png existe
            template_path = "templates/eat.png"
            if not os.path.exists(template_path):
                print("‚ö†Ô∏è Template eat.png n√£o encontrado, usando posi√ß√£o fixa")
                return EAT_POSITION_DEFAULT  # Posi√ß√£o padr√£o

            print(f"üîç [DEBUG] Template eat.png encontrado: {template_path}")
            print(f"üîç [DEBUG] Iniciando detec√ß√£o com m√∫ltiplos thresholds...")

            # Capturar tela
            with mss.mss() as sct:
                # Regi√£o focada na √°rea onde o bot√£o costuma aparecer
                region = {"top": 300, "left": 900, "width": 400, "height": 300}
                screenshot = sct.grab(region)
                img_array = np.array(screenshot)

                if img_array.shape[2] == 4:
                    screen_img = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
                else:
                    screen_img = img_array

            # Carregar template
            template = cv2.imread(template_path, cv2.IMREAD_COLOR)
            if template is None:
                print("‚ö†Ô∏è Erro ao carregar eat.png, usando posi√ß√£o fixa")
                return [1083, 373]

            # Processamento simples
            screen_gray = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
            template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

            # Template matching
            result = cv2.matchTemplate(screen_gray, template_gray, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

            # Usar threshold do template_confidence_manager (igual ao Catch Viewer)
            threshold = self.template_confidence_manager.get_template_confidence('eat')

            if max_val >= threshold:
                template_h, template_w = template_gray.shape
                center_x = max_loc[0] + template_w // 2 + region["left"]
                center_y = max_loc[1] + template_h // 2 + region["top"]

                print(f"‚úÖ Bot√£o 'eat' detectado na regi√£o em ({center_x}, {center_y}) - Conf: {max_val:.3f}")
                return [center_x, center_y]
            else:
                print(f"‚ö†Ô∏è Bot√£o 'eat' n√£o encontrado na regi√£o (conf: {max_val:.3f}), tentando tela inteira...")

                # TENTAR TELA INTEIRA se n√£o encontrou na regi√£o
                with mss.mss() as sct:
                    full_region = {"top": 0, "left": 0, "width": 1920, "height": 1080}
                    screenshot = sct.grab(full_region)
                    img_array = np.array(screenshot)

                    if img_array.shape[2] == 4:
                        screen_img = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
                    else:
                        screen_img = img_array

                screen_gray = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
                result = cv2.matchTemplate(screen_gray, template_gray, cv2.TM_CCOEFF_NORMED)
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                # Usar threshold do template_confidence_manager (igual ao Catch Viewer)
                threshold = self.template_confidence_manager.get_template_confidence('eat')

                if max_val >= threshold:
                    template_h, template_w = template_gray.shape
                    center_x = max_loc[0] + template_w // 2
                    center_y = max_loc[1] + template_h // 2

                    print(f"‚úÖ Bot√£o 'eat' encontrado na tela inteira em ({center_x}, {center_y}) - Conf: {max_val:.3f}")
                    return [center_x, center_y]
                else:
                    print(f"‚ùå Bot√£o 'eat' N√ÉO encontrado com threshold 0.85 (conf m√°xima: {max_val:.3f})")
                    print("üîç [DEBUG] Retornando posi√ß√£o fixa [1083, 373]")
                    return [1083, 373]

        except Exception as e:
            print(f"‚ùå Erro ao detectar bot√£o eat: {e}, usando posi√ß√£o fixa")
            return [1083, 373]

    def detect_food_in_slot(self, slot_position):
        """üçñ NOVO: Verificar se h√° comida em um slot espec√≠fico"""
        try:
            import cv2
            import numpy as np
            import mss

            slot_x, slot_y = slot_position

            # Capturar pequena regi√£o ao redor do slot
            region_size = 40
            region = {
                "top": slot_y - region_size,
                "left": slot_x - region_size,
                "width": region_size * 2,
                "height": region_size * 2
            }

            with mss.mss() as sct:
                screenshot = sct.grab(region)
                img_array = np.array(screenshot)

                if img_array.shape[2] == 4:
                    screen_img = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
                else:
                    screen_img = img_array

            # Templates de comida para verificar - APENAS FIL√â FRITO
            food_templates = [
                'file frito.png',    # Fil√© frito (√öNICA comida v√°lida)
                'filefrito.png'      # Fil√© frito (varia√ß√£o)
            ]

            for template_name in food_templates:
                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path, cv2.IMREAD_COLOR)
                    if template is not None:
                        # Processamento simples
                        screen_gray = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
                        template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

                        # Template matching
                        result = cv2.matchTemplate(screen_gray, template_gray, cv2.TM_CCOEFF_NORMED)
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        if max_val >= 0.70:  # Threshold mais baixo para slot pequeno
                            food_type = template_name.replace('.png', '')
                            print(f"‚úÖ Comida detectada no slot ({slot_x}, {slot_y}): {food_type} (conf: {max_val:.3f})")
                            return True, food_type

            print(f"‚ùå Nenhuma comida detectada no slot ({slot_x}, {slot_y})")
            return False, None

        except Exception as e:
            print(f"‚ùå Erro ao verificar comida no slot: {e}")
            return False, None

    def detect_food_position(self):
        """Detectar posi√ß√£o de comida dispon√≠vel (para re-detec√ß√£o)"""
        try:
            import cv2
            import numpy as np
            import mss

            # Templates APENAS de comida (n√£o iscas) - CORRIGIDO
            food_templates = [
                ('filefrito.png', 0.75),
                ('file frito.png', 0.75)  # Varia√ß√£o do nome
            ]

            # Capturar tela
            with mss.mss() as sct:
                monitor = {"top": 0, "left": 0, "width": 1920, "height": 1080}
                screenshot = sct.grab(monitor)
                img_array = np.array(screenshot)

                if img_array.shape[2] == 4:
                    screen_img = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
                else:
                    screen_img = img_array

            # Procurar por comida
            for template_name, threshold in food_templates:
                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path, cv2.IMREAD_COLOR)
                    if template is not None:
                        screen_gray = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
                        template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

                        result = cv2.matchTemplate(screen_gray, template_gray, cv2.TM_CCOEFF_NORMED)
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        if max_val >= threshold:
                            template_h, template_w = template_gray.shape
                            center_x = max_loc[0] + template_w // 2
                            center_y = max_loc[1] + template_h // 2

                            return (center_x, center_y)

            return None  # Nenhuma comida encontrada

        except Exception as e:
            print(f"‚ùå Erro ao re-detectar comida: {e}")
            return None

    def find_and_click_food_automatically(self):
        """üîç NOVO: Buscar fil√© frito E bot√£o eat automaticamente (l√≥gica completa)"""
        try:
            import cv2
            import numpy as np
            import mss

            print("üîç Modo detec√ß√£o autom√°tica - buscando fil√© frito e bot√£o eat...")

            # PASSO 1: Detectar APENAS fil√© frito (CORRIGIDO - sem iscas!)
            food_templates = [
                ('filefrito.png', 0.75),       # Fil√© frito (nome principal)
                ('file frito.png', 0.75)       # Fil√© frito (varia√ß√£o)
                # wolfmeat e carneurso REMOVIDOS - s√£o ISCAS, n√£o comida!
            ]

            # Capturar tela inteira
            with mss.mss() as sct:
                monitor = {"top": 0, "left": 0, "width": 1920, "height": 1080}
                screenshot = sct.grab(monitor)
                img_array = np.array(screenshot)

                if img_array.shape[2] == 4:
                    screen_img = cv2.cvtColor(img_array, cv2.COLOR_BGRA2BGR)
                else:
                    screen_img = img_array

            # PASSO 1: Procurar por comida
            food_found = False
            food_position = None

            for template_name, threshold in food_templates:
                if food_found:
                    break

                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path, cv2.IMREAD_COLOR)
                    if template is not None:
                        # Processamento simples
                        screen_gray = cv2.cvtColor(screen_img, cv2.COLOR_BGR2GRAY)
                        template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)

                        # Template matching
                        result = cv2.matchTemplate(screen_gray, template_gray, cv2.TM_CCOEFF_NORMED)

                        # Encontrar melhor match
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        if max_val >= threshold:
                            template_h, template_w = template_gray.shape
                            center_x = max_loc[0] + template_w // 2
                            center_y = max_loc[1] + template_h // 2

                            food_type = template_name.replace('.png', '')
                            print(f"‚úÖ COMIDA ENCONTRADA: {food_type} em ({center_x}, {center_y}) - Conf: {max_val:.3f}")

                            food_found = True
                            food_position = (center_x, center_y)
                            break

            if not food_found:
                print("‚ùå Nenhuma comida encontrada automaticamente")
                return False

            # PASSO 2: Detectar bot√£o 'eat'
            print("üîç Procurando bot√£o 'eat' na tela...")
            eat_position = self.detect_eat_button_position()

            print(f"üîç [DEBUG] Posi√ß√£o retornada pela detect_eat_button_position: {eat_position}")
            print(f"üîç [DEBUG] Tipo da posi√ß√£o: {type(eat_position)}")

            if eat_position == [1083, 373]:  # Posi√ß√£o padr√£o = n√£o encontrou
                print("‚ö†Ô∏è Bot√£o 'eat' n√£o detectado dinamicamente, usando posi√ß√£o padr√£o")
                print("üîç [DEBUG] USANDO POSI√á√ÉO FIXA - detec√ß√£o falhou")
            else:
                print(f"‚úÖ BOT√ÉO 'EAT' ENCONTRADO DINAMICAMENTE em ({eat_position[0]}, {eat_position[1]})")
                print("üîç [DEBUG] USANDO POSI√á√ÉO DETECTADA - sucesso!")

            # PASSO 3: Executar sequ√™ncia de alimenta√ß√£o
            print("üçΩÔ∏è Executando sequ√™ncia de alimenta√ß√£o autom√°tica...")

            # 3. Obter quantidade de cliques configurada
            feed_count = self.alimentacao.get('feeds_per_session', 5)
            print(f"üî¢ Configurado para comer {feed_count} vezes")

            # 4. Loop principal: verificar eat button PRIMEIRO, depois comida
            for i in range(feed_count):
                print(f"\nüçΩÔ∏è === CICLO {i+1}/{feed_count} ===")

                # A. PRIMEIRO: Verificar se bot√£o 'eat' J√Å est√° vis√≠vel
                print(f"üîç [INTELIGENTE] Verificando se bot√£o eat j√° est√° vis√≠vel...")
                eat_position = self.detect_eat_button_position()
                eat_already_visible = eat_position != [1083, 373]  # Posi√ß√£o padr√£o = n√£o encontrou

                if eat_already_visible:
                    print(f"‚úÖ [OTIMIZADO] Bot√£o EAT j√° est√° vis√≠vel em {eat_position}! Clicando diretamente...")

                    # Clicar diretamente no bot√£o eat - COM FALLBACK
                    try:
                        if hasattr(self, 'optimized_click'):
                            self.optimized_click(eat_position[0], eat_position[1])
                        else:
                            print("‚ö†Ô∏è [FALLBACK] Usando pyautogui.click para eat direto")
                            pyautogui.click(eat_position[0], eat_position[1])
                    except Exception as e:
                        print(f"‚ùå Erro no clique direto do eat: {e}")
                        print("üîß [FALLBACK] Tentando com pyautogui.click...")
                        pyautogui.click(eat_position[0], eat_position[1])

                else:
                    print("üîç [NORMAL] Bot√£o eat n√£o est√° vis√≠vel, seguindo fluxo padr√£o...")

                    # B. Re-detectar COMIDA (apenas se eat n√£o estiver vis√≠vel)
                    if i == 0:
                        # Primeiro clique: usar comida j√° detectada
                        current_food_pos = food_position
                        print(f"üçñ Usando comida inicial detectada: {current_food_pos}")
                    else:
                        # Cliques seguintes: re-detectar comida
                        print(f"üîÑ Re-detectando comida (peixe {i} consumido)...")
                        current_food_pos = self.detect_food_position()
                        if not current_food_pos:
                            print(f"‚ùå N√£o h√° mais comida dispon√≠vel ap√≥s {i} cliques")
                            break
                        print(f"üçñ Nova comida encontrada: {current_food_pos}")

                    # C. Clicar na comida para selecion√°-la - COM FALLBACK
                    print(f"üëÜ Clicando na comida: {current_food_pos}")
                    try:
                        if hasattr(self, 'optimized_click'):
                            self.optimized_click(current_food_pos[0], current_food_pos[1])
                        else:
                            print("‚ö†Ô∏è [FALLBACK] Usando pyautogui.click para comida")
                            pyautogui.click(current_food_pos[0], current_food_pos[1])
                    except Exception as e:
                        print(f"‚ùå Erro no clique da comida: {e}")
                        print("üîß [FALLBACK] Tentando com pyautogui.click...")
                        pyautogui.click(current_food_pos[0], current_food_pos[1])

                    # D. Aguardar para UI estabilizar (primeira vez 3s, demais 2s)
                    wait_time = 3.0 if i == 0 else 2.0
                    print(f"‚è≥ Aguardando {wait_time}s para UI estabilizar...")
                    time.sleep(wait_time)

                    # E. Detectar posi√ß√£o do eat AP√ìS clicar na comida
                    print(f"üîç Detectando bot√£o eat para ciclo {i+1}...")
                    eat_position = self.detect_eat_button_position()
                    print(f"üëÑ Posi√ß√£o eat detectada: {eat_position}")

                    # F. Clicar no bot√£o eat - COM FALLBACK
                    print(f"üëÜ Clicando no eat: {eat_position}")
                    try:
                        if hasattr(self, 'optimized_click'):
                            self.optimized_click(eat_position[0], eat_position[1])
                        else:
                            print("‚ö†Ô∏è [FALLBACK] Usando pyautogui.click para eat")
                            pyautogui.click(eat_position[0], eat_position[1])
                    except Exception as e:
                        print(f"‚ùå Erro no clique do eat: {e}")
                        print("üîß [FALLBACK] Tentando com pyautogui.click...")
                        pyautogui.click(eat_position[0], eat_position[1])

                # G. Aguardar entre cliques (exceto √∫ltimo)
                if i < feed_count - 1:
                    print("‚è≥ Aguardando 1.5s antes do pr√≥ximo ciclo...")
                    time.sleep(1.5)

            print("‚úÖ Alimenta√ß√£o autom√°tica conclu√≠da com sucesso!")

            # CORRE√á√ÉO: Aguardar 1 segundo ap√≥s √∫ltima comida antes de sair
            print("‚è≥ Aguardando 1s ap√≥s √∫ltima comida...")
            time.sleep(1.0)

            return True

        except Exception as e:
            print(f"‚ùå Erro na alimenta√ß√£o autom√°tica: {e}")
            return False

    def simple_image_preprocessing(self, image):
        """
        üîÑ PROCESSAMENTO SIMPLES - REMOVIDO normaliza√ß√£o e CLAHE
        Apenas convers√£o para escala de cinza
        """
        try:
            # Converter para escala de cinza se necess√°rio
            if len(image.shape) == 3:
                if image.shape[2] == 4:  # BGRA
                    gray = cv2.cvtColor(image, cv2.COLOR_BGRA2GRAY)
                elif image.shape[2] == 3:  # BGR ou RGB
                    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
                else:
                    gray = image
            else:
                gray = image.copy()

            return gray

        except Exception as e:
            print(f"‚ö†Ô∏è Erro no processamento simples: {e}")
            # Fallback
            if len(image.shape) == 3:
                return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            else:
                return image

    def map_broken_rods_to_slots(self, broken_rods):
        """Mapear varas quebradas para slots conhecidos"""
        SLOT_POSITIONS = {
            1: (709, 1005),   # Slot 1
            2: (805, 1005),   # Slot 2
            3: (899, 1005),   # Slot 3
            4: (992, 1005),   # Slot 4
            5: (1092, 1005),  # Slot 5
            6: (1188, 1005)   # Slot 6
        }

        broken_slots = {}

        for broken in broken_rods:
            best_slot = None
            best_distance = float('inf')

            # Encontrar slot mais pr√≥ximo
            for slot, (slot_x, slot_y) in SLOT_POSITIONS.items():
                distance = ((broken['x'] - slot_x) ** 2 + (broken['y'] - slot_y) ** 2) ** 0.5

                if distance < best_distance and distance < 150:  # Toler√¢ncia maior para template
                    best_distance = distance
                    best_slot = slot

            if best_slot:
                broken_slots[best_slot] = {
                    'position': (broken['x'], broken['y']),
                    'confidence': broken['confidence'],
                    'distance': best_distance
                }
                print(f"üí• SLOT {best_slot}: VARA QUEBRADA! Dist√¢ncia: {best_distance:.1f}px")

        return broken_slots

    def filter_new_broken_rods(self, broken_slots):
        """üéØ SISTEMA DE TRACKING: Filtrar varas quebradas j√° processadas"""
        import time

        # Inicializar sistema de tracking se n√£o existir
        if not hasattr(self, 'processed_broken_rods'):
            self.processed_broken_rods = {}
            print("üîß [TRACKING] Sistema de tracking de varas quebradas inicializado")

        current_time = time.time()
        new_broken_slots = {}

        # Limpar varas processadas antigas (ap√≥s 5 minutos para evitar memory leak)
        expired_keys = []
        for key, data in self.processed_broken_rods.items():
            if current_time - data['timestamp'] > 300:  # 5 minutos
                expired_keys.append(key)

        for key in expired_keys:
            del self.processed_broken_rods[key]
            print(f"üßπ [TRACKING] Removido tracking expirado: Slot {key}")

        # Verificar cada vara quebrada detectada
        for slot, broken_info in broken_slots.items():
            broken_x, broken_y = broken_info['position']

            # Criar chave √∫nica baseada na posi√ß√£o (com toler√¢ncia)
            position_key = f"slot_{slot}_{int(broken_x//20)*20}_{int(broken_y//20)*20}"

            # Verificar se j√° foi processada recentemente (√∫ltimos 2 minutos)
            if position_key in self.processed_broken_rods:
                time_since_processed = current_time - self.processed_broken_rods[position_key]['timestamp']

                if time_since_processed < 120:  # 2 minutos de cooldown
                    print(f"‚è≠Ô∏è [TRACKING] Slot {slot} j√° processado h√° {time_since_processed:.1f}s - ignorando")
                    continue
                else:
                    print(f"üîÑ [TRACKING] Slot {slot} processado h√° {time_since_processed:.1f}s - reprocessando")

            # Nova vara quebrada - adicionar √† lista
            new_broken_slots[slot] = broken_info

            # Marcar como processada
            self.processed_broken_rods[position_key] = {
                'slot': slot,
                'position': (broken_x, broken_y),
                'timestamp': current_time,
                'confidence': broken_info['confidence']
            }

            print(f"üÜï [TRACKING] Nova vara quebrada registrada: Slot {slot} em ({broken_x:.0f}, {broken_y:.0f})")

        return new_broken_slots

    def validate_rod_before_use(self, selected_slot, rod_slots):
        """üõ°Ô∏è VALIDA√á√ÉO FINAL: Garantir que vara selecionada tem isca"""
        if not selected_slot or not rod_slots:
            print("‚ùå [VALIDA√á√ÉO] Slot ou dados de varas inv√°lidos")
            return False

        if selected_slot not in rod_slots:
            print(f"‚ùå [VALIDA√á√ÉO] Slot {selected_slot} n√£o encontrado nos dados")
            return False

        rod_info = rod_slots[selected_slot]
        has_bait = rod_info.get('has_bait', False)

        if not has_bait:
            print(f"üö® [VALIDA√á√ÉO] CR√çTICO: Tentativa de usar vara SEM ISCA no slot {selected_slot}!")
            print(f"   ‚Ä¢ Classe: {rod_info.get('class_name', 'N/A')}")
            print(f"   ‚Ä¢ Posi√ß√£o: {rod_info.get('position', 'N/A')}")
            print(f"   ‚Ä¢ Confian√ßa: {rod_info.get('confidence', 0):.2f}")
            print("üîß Buscando vara alternativa com isca...")

            # Buscar vara alternativa com isca
            alternative = self.get_best_rod_with_bait(rod_slots)
            if alternative:
                print(f"‚úÖ [VALIDA√á√ÉO] Vara alternativa encontrada: Slot {alternative}")
                return False  # Retorna False para indicar que deve usar a alternativa
            else:
                print("‚ùå [VALIDA√á√ÉO] Nenhuma vara com isca dispon√≠vel!")
                return False

        print(f"‚úÖ [VALIDA√á√ÉO] Vara no slot {selected_slot} tem isca - OK para usar")
        return True

    def auto_discard_broken_rods(self, broken_slots):
        """üîß SISTEMA CONFIGUR√ÅVEL: Manejo autom√°tico de varas quebradas (descarte ou armazenamento)"""
        if not broken_slots:
            return True

        # ‚ö° VERIFICAR CONFIGURA√á√ÉO DO USU√ÅRIO
        broken_rod_action = self.config.get('broken_rod_action', 'discard')
        action_name = "DESCARTE" if broken_rod_action == 'discard' else "ARMAZENAMENTO"
        
        print(f"\nüîß {action_name} AUTOM√ÅTICO: {len(broken_slots)} vara(s) quebrada(s) detectada(s)")
        print(f"‚öôÔ∏è MODO CONFIGURADO: {broken_rod_action}")

        try:
            if broken_rod_action == 'discard':
                # üóëÔ∏è MODO DESCARTE (comportamento original)
                # üéØ VERIFICAR: S√≥ abrir invent√°rio se ba√∫ n√£o estiver aberto
                chest_is_open = self.game_state.get('chest_open', False)
                
                if chest_is_open:
                    print("üì¶ BA√ö j√° est√° aberto (durante limpeza) - pulando TAB")
                elif not self.game_state.get('inventory_open', False):
                    print("üì¶ Abrindo invent√°rio para descarte...")
                    pyautogui.press('tab')
                    time.sleep(1)
                    self.game_state['inventory_open'] = True

                discarded_count = 0
                for slot, broken_info in broken_slots.items():
                    broken_x, broken_y = broken_info['position']

                    print(f"üóëÔ∏è Descartando vara quebrada do slot {slot}...")

                    # Mover para posi√ß√£o da vara quebrada
                    pyautogui.moveTo(broken_x, broken_y, duration=0.2)
                    time.sleep(0.1)

                    # Shift + Right Click para descartar rapidamente
                    with pyautogui.hold('shift'):
                        pyautogui.click(broken_x, broken_y, button='right')

                    time.sleep(0.5)
            
                    discarded_count += 1
                    print(f"‚úÖ Vara quebrada do slot {slot} descartada")

                print(f"‚úÖ {discarded_count} vara(s) quebrada(s) descartada(s) com sucesso")

                # üéØ L√ìGICA INTELIGENTE: S√≥ fechar se n√£o estiver em limpeza
                if chest_is_open:
                    print("üì¶ Mantendo ba√∫ aberto (limpeza em progresso)")
                elif self.game_state.get('inventory_open', False):
                    print("üì¶ Fechando invent√°rio...")
                    pyautogui.press('tab')
                    self.game_state['inventory_open'] = False
            
            else:  # save
                # üì¶ MODO ARMAZENAMENTO (nova funcionalidade)
                print("üì¶ Modo armazenamento ativo - varas quebradas ser√£o tratadas durante manuten√ß√£o")
                print("üí° Sistema aguardar√° limpeza/alimenta√ß√£o para processar varas quebradas")

            return True

        except Exception as e:
            print(f"‚ùå Erro no descarte autom√°tico: {e}")
            return False

    def auto_refill_empty_slots(self):
        """üîÑ SISTEMA DE REPOSI√á√ÉO: Preenche slots vazios com varas do ba√∫ automaticamente"""
        print("\nüîÑ REPOSI√á√ÉO AUTOM√ÅTICA: Verificando slots vazios...")

        try:
            # USAR ROD_STATUS_TRACKING PARA DETEC√á√ÉO PRECISA (em vez de YOLO)
            if not hasattr(self, 'rod_status_tracking'):
                print("‚ùå Rod status tracking n√£o inicializado")
                return False

            # Verificar slots que est√£o REALMENTE vazios (sem NENHUMA vara)
            truly_empty_slots = []
            
            # Verificar cada slot individualmente
            for slot in range(1, 7):
                has_any_rod = False
                
                # Verificar se slot tem alguma vara (com ou sem isca)
                if 'slots' in self.rod_status_tracking:
                    slot_info = self.rod_status_tracking['slots'].get(slot)
                    if slot_info:
                        status = slot_info.get('status', '').upper()
                        # Se tem qualquer status de vara, slot est√° ocupado
                        if status in ['COM ISCA', 'SEM ISCA', 'QUEBRADA']:
                            has_any_rod = True
                
                # Verificar nas listas de tracking
                if not has_any_rod:
                    # Verificar se est√° em alguma lista de varas
                    if (slot in self.rod_status_tracking.get('available_with_bait', []) or
                        slot in self.rod_status_tracking.get('available_without_bait', []) or
                        slot in self.rod_status_tracking.get('broken_rods', [])):
                        has_any_rod = True
                
                # Se n√£o tem nenhuma vara, slot est√° realmente vazio
                if not has_any_rod:
                    truly_empty_slots.append(slot)
            
            # Log dos slots realmente vazios
            if not truly_empty_slots:
                print("‚úÖ Todos os slots 1-6 t√™m varas (com/sem isca ou quebradas)")
                return True
                
            print(f"üìä Slots REALMENTE vazios (sem nenhuma vara): {truly_empty_slots}")
            empty_slots = truly_empty_slots

            print(f"üìä Slots vazios encontrados: {empty_slots}")

            # Buscar varas no ba√∫
            if self.search_rods_in_chest():
                print("‚úÖ Reposi√ß√£o conclu√≠da com sucesso")

                # Ap√≥s reposi√ß√£o, verificar quais varas precisam de isca
                self.auto_reload_rods_without_bait()
                return True
            else:
                print("‚ö†Ô∏è N√£o foi poss√≠vel repor varas do ba√∫")
                return False

        except Exception as e:
            print(f"‚ùå Erro na reposi√ß√£o autom√°tica: {e}")
            return False

    def auto_reload_rods_without_bait(self):
        """üé£ SISTEMA DE RECARGA: Automaticamente adiciona isca √†s varas sem isca"""
        print("\nüé£ RECARGA AUTOM√ÅTICA: Verificando varas sem isca...")

        try:
            # Detectar objetos
            detections = self.detect_objects()

            # Encontrar varas sem isca nos slots 1-6
            rods_without_bait = []
            bait_items = []

            for detection in detections:
                x_pos = detection['center'][0]

                if x_pos < 1242:  # Invent√°rio (lado esquerdo)
                    # Verificar se √© vara sem isca
                    if 'vara' in detection['class'].lower() and 'isca' not in detection['class'].lower():
                        slot = self.get_inventory_slot_from_position(detection['center'])
                        if slot and 1 <= slot <= 6:
                            rods_without_bait.append({
                                'slot': slot,
                                'position': detection['center'],
                                'class': detection['class']
                            })

                    # Verificar se √© isca dispon√≠vel
                    elif detection['class'] in ['carne de urso', 'carne de lobo', 'grub', 'worm']:
                        bait_items.append({
                            'position': detection['center'],
                            'class': detection['class']
                        })

            if not rods_without_bait:
                print("‚úÖ Todas as varas nos slots 1-6 j√° t√™m isca")
                return True

            if not bait_items:
                print("‚ö†Ô∏è Nenhuma isca dispon√≠vel no invent√°rio")
                return False

            print(f"üìä Varas sem isca: {len(rods_without_bait)}")
            print(f"üìä Iscas dispon√≠veis: {len(bait_items)}")

            # Abrir invent√°rio se n√£o estiver aberto
            if not self.game_state.get('inventory_open', False):
                print("üì¶ Abrindo invent√°rio para recarga...")
                pyautogui.press('tab')
                time.sleep(1)
                self.game_state['inventory_open'] = True

            # Recarregar cada vara sem isca
            reloaded_count = 0
            for rod in rods_without_bait:
                if reloaded_count >= len(bait_items):
                    print("‚ö†Ô∏è Sem mais iscas dispon√≠veis")
                    break

                bait = bait_items[reloaded_count]
                rod_x, rod_y = rod['position']
                bait_x, bait_y = bait['position']

                print(f"üé£ Recarregando vara no slot {rod['slot']} com {bait['class']}...")

                # Drag & Drop: isca -> vara
                pyautogui.moveTo(bait_x, bait_y, duration=0.2)
                pyautogui.mouseDown()
                time.sleep(0.1)

                pyautogui.moveTo(rod_x, rod_y, duration=0.3)
                pyautogui.mouseUp()
                time.sleep(0.5)

                reloaded_count += 1
                print(f"‚úÖ Vara no slot {rod['slot']} recarregada")

            print(f"‚úÖ {reloaded_count} vara(s) recarregada(s) com sucesso")

            # Fechar invent√°rio
            if self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                self.game_state['inventory_open'] = False

            return True

        except Exception as e:
            print(f"‚ùå Erro na recarga autom√°tica: {e}")
            return False

    def auto_recover_baits_from_chest(self):
        """üçñ SISTEMA DE RECUPERA√á√ÉO: Busca iscas no ba√∫ quando necess√°rio"""
        print("\nüçñ RECUPERA√á√ÉO DE ISCA: Buscando iscas no ba√∫...")

        try:
            # Abrir ba√∫ se n√£o estiver aberto
            if not self.game_state.get('chest_open', False):
                print("üì¶ Abrindo ba√∫ para buscar iscas...")
                self.open_chest_with_macro()
                time.sleep(1.5)

            # Detectar objetos
            detections = self.detect_objects()

            # Classes de isca que queremos buscar
            bait_classes = ['carne de urso', 'carne de lobo', 'grub', 'worm', 'minhoca']

            baits_in_chest = []
            baits_in_inventory = 0

            for detection in detections:
                if detection['class'] in bait_classes:
                    x_pos = detection['center'][0]

                    if x_pos > 1242:  # Est√° no BA√ö (lado direito)
                        baits_in_chest.append(detection)
                        print(f"   üì¶ Isca no BA√ö: {detection['class']} em x={x_pos}")
                    elif x_pos < 1242:  # Est√° no invent√°rio (lado esquerdo)
                        baits_in_inventory += 1

            print(f"üìä Status atual:")
            print(f"   ‚Ä¢ Iscas no invent√°rio: {baits_in_inventory}")
            print(f"   ‚Ä¢ Iscas dispon√≠veis no ba√∫: {len(baits_in_chest)}")

            # Transferir iscas se necess√°rio
            transferred = 0
            max_transfer = min(len(baits_in_chest), 10)  # M√°ximo 10 iscas

            if max_transfer > 0 and baits_in_inventory < 5:  # S√≥ transferir se pouca isca no invent√°rio
                print(f"\nüì• Transferindo {max_transfer} isca(s) do ba√∫...")

                for i in range(max_transfer):
                    bait = baits_in_chest[i]
                    x, y = bait['center']

                    print(f"   [{i+1}/{max_transfer}] Transferindo {bait['class']} em ({x}, {y})...")

                    # Clicar com shift para transferir r√°pido
                    pyautogui.moveTo(x, y, duration=0.2)
                    time.sleep(0.1)

                    with pyautogui.hold('shift'):
                        pyautogui.click(x, y)

                    transferred += 1
                    time.sleep(0.3)

                print(f"‚úÖ {transferred} isca(s) transferida(s) com sucesso!")
            else:
                print("‚ÑπÔ∏è Iscas suficientes no invent√°rio")

            # Fechar ba√∫
            self.close_inventory_with_delay("Recupera√ß√£o de iscas")
            self.game_state['chest_open'] = False

            return transferred > 0

        except Exception as e:
            print(f"‚ùå Erro na recupera√ß√£o de iscas: {e}")
            # Garantir que ba√∫ seja fechado
            if self.game_state.get('chest_open', False):
                pyautogui.press('tab')
                self.game_state['chest_open'] = False
            return False

    def continuous_operation_manager(self):
        """üîÑ GERENCIADOR DE OPERA√á√ÉO CONT√çNUA: Sistema completo de manuten√ß√£o autom√°tica"""
        print("\nüîÑ SISTEMA DE MANUTEN√á√ÉO CONT√çNUA ATIVO")

        try:
            # 1. Detectar e descartar varas quebradas
            broken_rods = self.detect_broken_rods()
            if broken_rods:
                broken_slots = self.map_broken_rods_to_slots(broken_rods)
                new_broken_slots = self.filter_new_broken_rods(broken_slots)

                if new_broken_slots:
                    print("üóëÔ∏è FASE 1: Descartando varas quebradas...")
                    self.auto_discard_broken_rods(new_broken_slots)

            # 2. Verificar e repor varas nos slots vazios
            print("üîÑ FASE 2: Verificando necessidade de reposi√ß√£o...")
            self.auto_refill_empty_slots()

            # 3. Verificar se precisa buscar iscas
            detections = self.detect_objects()
            bait_count = sum(1 for d in detections if d['class'] in ['carne de urso', 'carne de lobo', 'grub', 'worm'] and d['center'][0] < 1242)

            if bait_count < 3:  # Pouca isca no invent√°rio
                print("üçñ FASE 3: Recuperando iscas do ba√∫...")
                self.auto_recover_baits_from_chest()

            # 4. Recarregar varas sem isca
            print("üé£ FASE 4: Verificando varas sem isca...")
            self.auto_reload_rods_without_bait()

            print("‚úÖ MANUTEN√á√ÉO CONT√çNUA CONCLU√çDA")
            return True

        except Exception as e:
            print(f"‚ùå Erro no gerenciador de opera√ß√£o cont√≠nua: {e}")
            return False

    def process_rod_detections_with_tracking(self, detections, rod_classes):
        """üéØ SISTEMA AVAN√áADO: Processar detec√ß√µes de varas com tracking e enumera√ß√£o"""
        import time

        # Inicializar sistema de tracking de varas se n√£o existir
        if not hasattr(self, 'rod_detection_tracking'):
            self.rod_detection_tracking = {
                'slot_states': {},      # Estado de cada slot
                'last_update': {},      # Timestamp da √∫ltima atualiza√ß√£o
                'detection_count': {}   # Contador de detec√ß√µes por slot
            }
            print("üîß [ROD TRACKING] Sistema de tracking de varas inicializado")

        SLOT_POSITIONS = {
            1: (709, 1005),   # Slot 1
            2: (805, 1005),   # Slot 2
            3: (899, 1005),   # Slot 3
            4: (992, 1005),   # Slot 4
            5: (1092, 1005),  # Slot 5
            6: (1188, 1005)   # Slot 6
        }

        current_time = time.time()
        available_slots = []
        empty_slots = []
        baited_slots = []
        rod_states = {}

        # Processar cada detec√ß√£o de vara
        for detection in detections:
            if detection['class'] in rod_classes:
                # Verificar se est√° no invent√°rio do jogador (x < 1242)
                if detection['center'][0] < 1242:
                    detection_x, detection_y = detection['center']

                    # Encontrar slot mais pr√≥ximo
                    best_slot = None
                    best_distance = float('inf')

                    for slot, (slot_x, slot_y) in SLOT_POSITIONS.items():
                        distance = ((detection_x - slot_x) ** 2 + (detection_y - slot_y) ** 2) ** 0.5
                        if distance < best_distance and distance < 100:  # Toler√¢ncia
                            best_distance = distance
                            best_slot = slot

                    if best_slot:
                        # Determinar estado da vara
                        has_bait = self.determine_rod_bait_state(detection)
                        class_name = detection['class']
                        confidence = detection.get('confidence', 0)

                        # üéØ TRACKING: Verificar mudan√ßas de estado
                        slot_key = f"slot_{best_slot}"
                        old_state = self.rod_detection_tracking['slot_states'].get(slot_key, {})

                        new_state = {
                            'slot': best_slot,
                            'position': (detection_x, detection_y),
                            'class': class_name,
                            'has_bait': has_bait,
                            'confidence': confidence,
                            'distance_from_slot': best_distance,
                            'timestamp': current_time
                        }

                        # Verificar se houve mudan√ßa significativa
                        state_changed = self.rod_state_changed(old_state, new_state)

                        if state_changed:
                            print(f"üîÑ [ROD TRACKING] Slot {best_slot}: {class_name} ({'COM' if has_bait else 'SEM'} isca) - Conf: {confidence:.2f}")
                            self.rod_detection_tracking['detection_count'][slot_key] = self.rod_detection_tracking['detection_count'].get(slot_key, 0) + 1

                        # Atualizar tracking
                        self.rod_detection_tracking['slot_states'][slot_key] = new_state
                        self.rod_detection_tracking['last_update'][slot_key] = current_time

                        # Adicionar aos resultados
                        available_slots.append(best_slot)
                        rod_states[best_slot] = new_state

                        if has_bait:
                            baited_slots.append(best_slot)
                        else:
                            empty_slots.append(best_slot)

        # Limpar estados antigos (mais de 2 minutos)
        expired_slots = []
        for slot_key, timestamp in self.rod_detection_tracking['last_update'].items():
            if current_time - timestamp > 120:  # 2 minutos
                expired_slots.append(slot_key)

        for slot_key in expired_slots:
            if slot_key in self.rod_detection_tracking['slot_states']:
                del self.rod_detection_tracking['slot_states'][slot_key]
            if slot_key in self.rod_detection_tracking['last_update']:
                del self.rod_detection_tracking['last_update'][slot_key]
            if slot_key in self.rod_detection_tracking['detection_count']:
                del self.rod_detection_tracking['detection_count'][slot_key]
            print(f"üßπ [ROD TRACKING] Estado expirado removido: {slot_key}")

        return {
            'available_slots': available_slots,
            'empty_slots': empty_slots,
            'baited_slots': baited_slots,
            'rod_states': rod_states,
            'tracking_stats': {
                'total_detections': sum(self.rod_detection_tracking['detection_count'].values()),
                'tracked_slots': len(self.rod_detection_tracking['slot_states'])
            }
        }

    def determine_rod_bait_state(self, detection):
        """üé£ SISTEMA ROBUSTO: Determinar se a vara tem isca com m√∫ltiplos m√©todos"""
        class_name = detection['class'].lower()

        # M√âTODO 1: Detec√ß√£o por classe YOLO (mais confi√°vel)
        if any(keyword in class_name for keyword in ['com isca', 'with bait', 'baited']):
            print(f"   ‚úÖ [YOLO] Vara COM isca detectada: {class_name}")
            return True

        if any(keyword in class_name for keyword in ['sem isca', 'empty', 'no bait']):
            print(f"   ‚ùå [YOLO] Vara SEM isca detectada: {class_name}")
            return False

        # M√âTODO 2: Usar nova detec√ß√£o de cor aprimorada
        try:
            center_x, center_y = detection['center']

            # Usar a nova fun√ß√£o de detec√ß√£o de cor espec√≠fica
            color_result = self.check_rod_bait_by_pixel_color(center_x, center_y)

            if color_result['has_bait'] is not None:
                status = "COM" if color_result['has_bait'] else "SEM"
                print(f"   üé® [COR] Vara {status} isca - {color_result['color_detected']} (Conf: {color_result['confidence']:.2%})")
                return color_result['has_bait']
            else:
                # Se n√£o detectou cores espec√≠ficas, tentar m√©todo antigo
                color_result_old = self.is_rod_empty(detection)
                if color_result_old is not None:
                    has_bait = not color_result_old  # is_rod_empty retorna True se vazia
                    status = "COM" if has_bait else "SEM"
                    print(f"   üé® [COR-OLD] Vara {status} isca detectada por m√©todo antigo")
                    return has_bait

        except Exception as e:
            print(f"   ‚ö†Ô∏è [COR] Erro na detec√ß√£o por cor: {e}")

        # M√âTODO 3: Fallback baseado na confian√ßa da detec√ß√£o
        confidence = detection.get('confidence', 0)
        if confidence > 0.85:
            # Alta confian√ßa - assumir que √© uma vara gen√©rica COM isca
            print(f"   ü§ñ [FALLBACK] Alta confian√ßa ({confidence:.2f}) - assumindo COM isca")
            return True
        else:
            # Baixa confian√ßa - assumir SEM isca para ser conservador
            print(f"   ‚ö†Ô∏è [FALLBACK] Baixa confian√ßa ({confidence:.2f}) - assumindo SEM isca")
            return False

    def rod_state_changed(self, old_state, new_state):
        """üîÑ Verificar se houve mudan√ßa significativa no estado da vara"""
        if not old_state:
            return True  # Primeira detec√ß√£o

        # Verificar mudan√ßas importantes
        if old_state.get('has_bait') != new_state.get('has_bait'):
            return True  # Mudan√ßa no estado da isca

        if old_state.get('class') != new_state.get('class'):
            return True  # Mudan√ßa na classe detectada

        # Mudan√ßa na posi√ß√£o (toler√¢ncia de 20 pixels)
        old_pos = old_state.get('position', (0, 0))
        new_pos = new_state.get('position', (0, 0))
        distance = ((old_pos[0] - new_pos[0]) ** 2 + (old_pos[1] - new_pos[1]) ** 2) ** 0.5
        if distance > 20:
            return True

        return False

    def replace_broken_rods(self, broken_slots):
        """üî¥ PROCEDIMENTO ESPEC√çFICO: Recuperar isca e descartar vara quebrada"""
        print("\nüî¥ INICIANDO PROCEDIMENTO PARA VARA QUEBRADA")
        print("="*60)
        print("üö® PAUSANDO TODOS OS INPUTS DE TECLADO E MOUSE...")

        # CR√çTICO: Marcar a√ß√£o em progresso para bloquear TUDO
        self.game_state['action_in_progress'] = True
        self.game_state['broken_rod_active'] = True
        self.game_state['fishing_active'] = False  # Garantir que pesca est√° parada

        # üö® PAUSAR THREADS DE CLIQUE temporariamente durante procedimento
        self._pause_clicking_threads = True

        # LIBERAR QUALQUER BOT√ÉO QUE POSSA ESTAR PRESSIONADO
        try:
            if self.game_state.get('right_mouse_down', False):
                print("üö® Liberando bot√£o direito do mouse...")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='right')
                self.game_state['right_mouse_down'] = False

            if self.game_state.get('left_mouse_down', False):
                print("üö® Liberando bot√£o esquerdo do mouse...")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                self.game_state['left_mouse_down'] = False

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao liberar bot√µes: {e}")

        # Aguardar para garantir que todos os inputs pararam
        print("‚è≥ Aguardando 1s para garantir pausa completa...")
        time.sleep(1.0)

        try:
            for slot, broken_info in broken_slots.items():
                print(f"\nüí• Processando vara quebrada no SLOT {slot}:")
                print(f"   Posi√ß√£o: {broken_info['position']}")
                print(f"   Confian√ßa: {broken_info['confidence']:.3f}")

                self.handle_broken_rod_specific_procedure(broken_info['position'])

            print("‚úÖ Procedimento de vara quebrada conclu√≠do!")

        except Exception as e:
            print(f"‚ùå Erro no procedimento de vara quebrada: {e}")
            # Garantir que o invent√°rio seja fechado
            try:
                pyautogui.press('tab')
            except:
                pass
        finally:
            # CR√çTICO: Sempre limpar estado ao finalizar
            self.game_state['action_in_progress'] = False
            self.game_state['broken_rod_active'] = False
            self._pause_clicking_threads = False  # Liberar threads de clique
            print("üî¥ Estado de vara quebrada finalizado")

    def handle_broken_rod_specific_procedure(self, broken_rod_position):
        """üéØ PROCEDIMENTO ESPEC√çFICO CORRIGIDO para vara quebrada - SEQU√äNCIA EXATA"""
        print("\nüî¥ EXECUTANDO SEQU√äNCIA CORRETA PARA VARA QUEBRADA:")
        print("üìã Sequ√™ncia: TAB ‚Üí Clique vara ‚Üí Move isca ‚Üí Click direito ‚Üí Volta vara ‚Üí Arrasta ‚Üí Descarta")

        try:
            broken_x, broken_y = broken_rod_position

            # üö® CR√çTICO: Garantir que TODOS os bot√µes do mouse est√£o soltos antes de come√ßar
            print("   [0/9] üö® LIBERANDO TODOS OS BOT√ïES DO MOUSE...")
            try:
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')   # Garantir bot√£o esquerdo solto
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='right')  # Garantir bot√£o direito solto
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='middle') # Garantir bot√£o do meio solto
                time.sleep(0.3)  # Pequena pausa ap√≥s liberar bot√µes
            except Exception as e:
                print(f"   ‚ö†Ô∏è Erro ao liberar bot√µes: {e}")

            # Passo 1: Verificar configura√ß√£o e decidir se abre invent√°rio ou ba√∫
            broken_rod_action = self.config.get('broken_rod_action', 'discard')
            inventory_was_open = self.game_state.get('inventory_open', False)
            chest_is_open = self.game_state.get('chest_open', False)
            
            # üéØ L√ìGICA CORRIGIDA: TAB APENAS PARA FECHAR BA√ö
            if broken_rod_action == 'save':
                # MODO GUARDAR: Deve abrir o ba√∫
                if not chest_is_open:
                    print("   [1/9] üì¶ Configurado para GUARDAR - abrindo BA√ö...")
                    # Abrir ba√∫ para guardar vara quebrada
                    if self.open_chest():
                        chest_is_open = True
                        print("   ‚úÖ BA√ö aberto com sucesso")
                    else:
                        print("   ‚ùå Erro ao abrir ba√∫ - pulando procedimento")
                        return
                else:
                    print("   [1/9] üì¶ BA√ö j√° estava aberto - OK para guardar")
            else:
                # MODO DESCARTAR: N√ÉO abrir invent√°rio - trabalhar direto
                print("   [1/9] üì¶ Configurado para DESCARTAR - trabalhando sem abrir invent√°rio")
                if chest_is_open:
                    print("   üí° BA√ö est√° aberto - ser√° usado para trabalhar")
                # N√ÉO usar TAB para abrir invent√°rio

            # Passo 2: Mover mouse para vara quebrada PRIMEIRO (SEM CLIQUES)
            print(f"   [2/9] Movendo mouse para vara quebrada em ({broken_x:.0f}, {broken_y:.0f})...")
            pyautogui.moveTo(broken_x, broken_y, duration=1.0)  # Movimento mais lento
            time.sleep(1.0)  # Aguardar mouse chegar na posi√ß√£o

            # Passo 3: Clicar na vara quebrada para DETEC√á√ÉO/SELE√á√ÉO
            print(f"   [3/9] CLICANDO na vara quebrada para detectar...")
            pyautogui.click(broken_x, broken_y)  # Clique esquerdo para detectar
            time.sleep(1.5)  # Aguardar processamento do clique

            # Passo 4: Mover mouse para POSI√á√ÉO DA ISCA (721,359) - SEM CLIQUES
            print("   [4/9] Movendo para POSI√á√ÉO DA ISCA (721,359)...")
            pyautogui.moveTo(721, 359, duration=1.0)  # Movimento mais lento para evitar cliques
            time.sleep(1.0)  # Aguardar mouse chegar na posi√ß√£o da isca

            # Passo 5: Clicar bot√£o DIREITO para REMOVER ISCA
            print("   [5/9] REMOVENDO ISCA (clique direito)...")
            try:
                pyautogui.rightClick()  # Remove a isca da vara quebrada
                print("   ‚úì Clique direito executado com sucesso")
                time.sleep(1.5)  # Aguardar processamento da remo√ß√£o da isca
                print("   ‚úì Aguardando processamento da remo√ß√£o...")
            except Exception as e:
                print(f"   ‚ùå Erro no clique direito: {e}")
                raise

            # Passo 6: Voltar para vara quebrada (SEM CLIQUES)
            print(f"   [6/9] Retornando para vara quebrada...")
            pyautogui.moveTo(broken_x, broken_y, duration=1.0)  # Movimento mais lento
            time.sleep(1.0)  # Aguardar mouse chegar na vara quebrada

            # Passo 7: INICIAR ARRASTO - Segurar bot√£o esquerdo
            print("   [7/9] Segurando bot√£o esquerdo na vara quebrada...")
            pyautogui.mouseDown(button='left')
            time.sleep(0.5)  # Pequeno delay ap√≥s segurar o bot√£o

            # ‚ö° VERIFICAR CONFIGURA√á√ÉO DO USU√ÅRIO
            broken_rod_action = self.config.get('broken_rod_action', 'discard')
            
            if broken_rod_action == 'discard':
                # üóëÔ∏è MODO DESCARTE (comportamento original)
                print("   [8/9] ARRASTANDO para lixo (1553,497)...")
                pyautogui.moveTo(1553, 497, duration=2.0)  # Arrasto mais lento para maior precis√£o
                time.sleep(0.5)  # Aguardar chegada no lixo

                print("   [9/9] DESCARTANDO vara quebrada (soltar bot√£o)...")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                time.sleep(1.5)  # Aguardar processamento do descarte
            
            else:  # save
                # üì¶ MODO ARMAZENAMENTO (nova funcionalidade)
                print("   [8/9] üì¶ GUARDANDO vara quebrada no ba√∫ (clique direito)...")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')  # Soltar primeiro
                time.sleep(0.3)
                pyautogui.click(broken_x, broken_y, button='right')  # Clique direito para guardar
                time.sleep(1.5)  # Aguardar transfer√™ncia
                
                print("   [9/9] ‚úÖ Vara quebrada guardada no ba√∫!")

            # üéØ L√ìGICA CORRIGIDA: TAB APENAS PARA FECHAR BA√ö
            if broken_rod_action == 'save':
                # MODO GUARDAR: Fechar ba√∫ se foi aberto por esta fun√ß√£o
                if chest_is_open and not self.game_state.get('cleaning_active', False):
                    print("   [FINAL] üì¶ Fechando ba√∫ ap√≥s guardar vara (TAB)...")
                    pyautogui.press('tab')
                    self.game_state['chest_open'] = False
                    time.sleep(1.0)
                else:
                    print("   [FINAL] üì¶ Mantendo ba√∫ aberto (limpeza em progresso)")
            else:
                # MODO DESCARTAR: N√£o usar TAB - deixar como estava
                if chest_is_open:
                    print("   [FINAL] üì¶ BA√ö estava aberto - usando TAB para fechar...")
                    pyautogui.press('tab')
                    self.game_state['chest_open'] = False
                    time.sleep(1.0)
                else:
                    print("   [FINAL] ‚úÖ Conclu√≠do sem abrir/fechar nada")

            action_verb = "descartada no lixo" if broken_rod_action == 'discard' else "guardada no ba√∫"
            print("   ‚úÖ SEQU√äNCIA CORRETA CONCLU√çDA:")
            print("      ‚úì Mouse movido antes de clicar")
            print("      ‚úì Delays adequados ap√≥s cada a√ß√£o")
            print("      ‚úì Vara quebrada detectada e selecionada")
            print("      ‚úì Isca removida da vara")
            print(f"      ‚úì Vara quebrada {action_verb}")
            print("      ‚úì Invent√°rio fechado")
            print("üéØ Processo de vara quebrada FINALIZADO com sucesso!")

        except Exception as e:
            print(f"   ‚ùå Erro na sequ√™ncia espec√≠fica: {e}")
            # Garantir que bot√£o esquerdo n√£o ficou pressionado
            try:
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                time.sleep(0.5)

                # Fechar invent√°rio apenas se necess√°rio
                if self.game_state.get('inventory_open', False) and not inventory_was_open:
                    print("   [ERRO] Fechando invent√°rio ap√≥s erro...")
                    pyautogui.press('tab')
                    self.game_state['inventory_open'] = False
            except:
                pass

    def check_for_broken_rod_after_fishing(self):
        """üîç Verificar vara quebrada ap√≥s pesca conclu√≠da ou timeout"""
        print("\nüîç VERIFICANDO VARA QUEBRADA P√ìS-PESCA...")

        # Aguardar um momento para que a vara quebrada apare√ßa
        time.sleep(0.5)

        # Detectar varas quebradas
        broken_rods = self.detect_broken_rods()

        if broken_rods:
            print(f"üî¥ VARA QUEBRADA DETECTADA ap√≥s pesca! ({len(broken_rods)} encontrada(s))")

            # Mapear para slots
            broken_slots = self.map_broken_rods_to_slots(broken_rods)

            if broken_slots:
                print("üîß Executando procedimento de recupera√ß√£o de isca...")
                self.replace_broken_rods(broken_slots)

                # üî¥ ATUALIZAR TRACKING - REMOVER SLOT DA VARA QUEBRADA
                if hasattr(self, 'rod_status_tracking'):
                    for slot in broken_slots:
                        # Remover de todas as listas
                        if slot in self.rod_status_tracking.get('available_with_bait', []):
                            self.rod_status_tracking['available_with_bait'].remove(slot)
                        if slot in self.rod_status_tracking.get('available_without_bait', []):
                            self.rod_status_tracking['available_without_bait'].remove(slot)
                        # Adicionar aos slots vazios
                        if 'empty_slots' not in self.rod_status_tracking:
                            self.rod_status_tracking['empty_slots'] = []
                        if slot not in self.rod_status_tracking['empty_slots']:
                            self.rod_status_tracking['empty_slots'].append(slot)
                        # Remover do tracking de slots
                        if slot in self.rod_status_tracking.get('slots', {}):
                            del self.rod_status_tracking['slots'][slot]

                    print(f"üìä Slots atualizados - Vazios: {self.rod_status_tracking.get('empty_slots', [])}")

                # Re-detectar varas dispon√≠veis ap√≥s descartar quebrada
                self.detect_available_rods()

                # üîÑ VERIFICAR SE PRECISA REABASTECER VARAS
                self.check_and_refill_rods()

                # üîÑ REORGANIZAR PARES ap√≥s vara quebrada
                print("üîÑ Reorganizando pares ap√≥s vara quebrada...")
                self.reorganize_rod_pairs_dynamically()

                return True
            else:
                print("‚ö†Ô∏è Vara quebrada detectada mas n√£o foi poss√≠vel mapear para slot")
        else:
            print("‚úÖ Nenhuma vara quebrada detectada")

        return False

    def check_and_refill_rods(self):
        """üé£ Verificar quantas varas faltam e reabastecer do ba√∫ se necess√°rio"""
        if not hasattr(self, 'rod_status_tracking'):
            self.rod_status_tracking = {
                'slots': {},
                'empty_slots': [],
                'available_with_bait': [],
                'available_without_bait': [],
                'broken_rods': []
            }

        # Contar slots vazios
        total_slots = 6
        used_slots = len(self.rod_status_tracking.get('slots', {}))
        empty_slots = self.rod_status_tracking.get('empty_slots', [])
        missing_rods = total_slots - used_slots

        print(f"\nüìä AN√ÅLISE DE INVENT√ÅRIO DE VARAS:")
        print(f"   ‚Ä¢ Slots totais: {total_slots}")
        print(f"   ‚Ä¢ Varas ativas: {used_slots}")
        print(f"   ‚Ä¢ Slots vazios: {empty_slots}")
        print(f"   ‚Ä¢ Varas faltando: {missing_rods}")

        # Se faltam muitas varas, buscar no ba√∫
        if missing_rods >= 3:
            print(f"‚ö†Ô∏è Faltam {missing_rods} varas! Iniciando busca no ba√∫...")
            self.smart_chest_rod_search(missing_rods)
        elif missing_rods >= 1:
            print(f"üîç Faltam {missing_rods} vara(s). Considerando busca no ba√∫...")
            # Verificar se tem poucas varas com isca
            with_bait = len(self.rod_status_tracking.get('available_with_bait', []))
            if with_bait <= 2:
                print("‚ö†Ô∏è Poucas varas com isca dispon√≠veis. Buscando no ba√∫...")
                self.smart_chest_rod_search(missing_rods)

    def smart_chest_rod_search(self, needed_rods):
        """üéØ Busca inteligente de varas no ba√∫ com prioriza√ß√£o"""
        print(f"\nüè™ INICIANDO BUSCA INTELIGENTE NO BA√ö - Precisamos de {needed_rods} vara(s)")

        try:
            # Abrir ba√∫
            print("üì¶ Abrindo ba√∫...")
            if not self.open_chest_safely():
                print("‚ùå Falha ao abrir ba√∫")
                return False

            time.sleep(1.5)

            # Detectar itens no ba√∫
            print("üîç Analisando conte√∫do do ba√∫...")
            chest_items = self.analyze_chest_contents()

            # Categorizar varas encontradas
            rods_with_bait = []
            rods_without_bait = []
            bait_items = []

            for item in chest_items:
                item_name = item.get('name', '').lower()

                # Varas com isca
                if 'varacomisca' in item_name or 'comiscavara' in item_name or 'namaocomisca' in item_name or 'comiscanamao' in item_name:
                    rods_with_bait.append(item)
                # Varas sem isca
                elif 'varasemisca' in item_name or 'semiscavara' in item_name or 'semiscanam' in item_name or 'namaosemisca' in item_name or 'vara' in item_name:
                    rods_without_bait.append(item)
                # Iscas dispon√≠veis
                elif any(bait in item_name for bait in ['worm', 'grub', 'wolfmeat', 'bearmeat']):
                    bait_items.append(item)

            print(f"üìä An√°lise do ba√∫:")
            print(f"   ‚Ä¢ Varas com isca: {len(rods_with_bait)}")
            print(f"   ‚Ä¢ Varas sem isca: {len(rods_without_bait)}")
            print(f"   ‚Ä¢ Iscas dispon√≠veis: {len(bait_items)}")

            # üéØ L√ìGICA DE DECIS√ÉO INTELIGENTE

            # 1. Priorizar varas com isca
            if rods_with_bait:
                print("‚úÖ Pegando varas COM ISCA (prioridade m√°xima)...")
                rods_taken = 0
                for rod in rods_with_bait[:needed_rods]:
                    if self.take_item_from_chest(rod):
                        rods_taken += 1
                        print(f"   ‚úÖ Vara com isca {rods_taken}/{needed_rods} pega")
                        if rods_taken >= needed_rods:
                            break

                needed_rods -= rods_taken

            # 2. Se ainda precisa de varas e tem iscas dispon√≠veis
            if needed_rods > 0 and rods_without_bait and bait_items:
                print("üîÑ Pegando varas SEM ISCA + iscas para recarregar...")

                # Pegar varas sem isca
                rods_taken = 0
                rods_to_reload = []
                for rod in rods_without_bait[:needed_rods]:
                    if self.take_item_from_chest(rod):
                        rods_taken += 1
                        rods_to_reload.append(rod)
                        print(f"   ‚úÖ Vara sem isca {rods_taken}/{needed_rods} pega")
                        if rods_taken >= needed_rods:
                            break

                # Pegar iscas necess√°rias
                if rods_to_reload:
                    print("üé£ Pegando iscas para recarregar as varas...")
                    baits_needed = min(len(rods_to_reload) * 10, len(bait_items))  # 10 iscas por vara
                    for bait in bait_items[:baits_needed]:
                        self.take_item_from_chest(bait)

                    # Fechar ba√∫ e recarregar varas
                    print("üì¶ Fechando ba√∫ para recarregar varas...")
                    pyautogui.press('tab')
                    time.sleep(0.5)

                    # Recarregar as varas pegas
                    print("üîß Recarregando varas com as iscas...")
                    self.reload_newly_acquired_rods(rods_to_reload)

                    return True

            # 3. Se n√£o tem iscas mas tem varas sem isca (√∫ltimo recurso)
            elif needed_rods > 0 and rods_without_bait:
                print("‚ö†Ô∏è Sem iscas no ba√∫! Pegando varas vazias mesmo...")
                rods_taken = 0
                for rod in rods_without_bait[:needed_rods]:
                    if self.take_item_from_chest(rod):
                        rods_taken += 1
                        print(f"   ‚ö†Ô∏è Vara sem isca {rods_taken}/{needed_rods} pega (sem isca dispon√≠vel)")
                        if rods_taken >= needed_rods:
                            break

            # 4. Se n√£o tem nada √∫til no ba√∫
            elif not rods_with_bait and not rods_without_bait:
                print("‚ùå CR√çTICO: Nenhuma vara dispon√≠vel no ba√∫!")
                print("üî¥ Bot n√£o pode continuar sem varas!")
                self.running = False
                return False

            # Fechar ba√∫
            print("üì¶ Fechando ba√∫...")
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # Atualizar slots e reorganizar
            print("üîÑ Atualizando invent√°rio de varas...")
            self.detect_available_rods()
            self.reorganize_rod_pairs_dynamically()

            return True

        except Exception as e:
            print(f"‚ùå Erro na busca inteligente no ba√∫: {e}")
            # Tentar fechar ba√∫ em caso de erro
            pyautogui.press('tab')
            return False

    def analyze_chest_contents(self):
        """Analisar conte√∫do do ba√∫ usando detec√ß√£o"""
        items = []
        try:
            # Usar YOLO ou template matching para detectar itens
            detections = self.detect_objects() if self.yolo_model else []

            for detection in detections:
                # Verificar se est√° na √°rea do ba√∫ (direita da tela) - REFATORADO
                if detection.get('x', 0) > INVENTORY_CHEST_DIVIDER_X:  # √Årea do ba√∫
                    items.append({
                        'name': detection.get('class_name', 'unknown'),
                        'x': detection.get('x'),
                        'y': detection.get('y'),
                        'confidence': detection.get('confidence', 0)
                    })

            # Adicionar detec√ß√£o por template matching se necess√°rio
            if not items:
                print("   üîç Usando template matching para an√°lise...")
                # Implementa√ß√£o de template matching aqui

            return items

        except Exception as e:
            print(f"   ‚ùå Erro ao analisar ba√∫: {e}")
            return []

    def take_item_from_chest(self, item):
        """Pegar item espec√≠fico do ba√∫"""
        try:
            x = item.get('x', 0)
            y = item.get('y', 0)

            if x and y:
                print(f"   üéØ Pegando item em ({x}, {y})...")

                # Shift+Click para transferir
                pyautogui.keyDown('shift')
                time.sleep(0.1)
                pyautogui.click(x, y)
                time.sleep(0.1)
                pyautogui.keyUp('shift')

                return True
            return False

        except Exception as e:
            print(f"   ‚ùå Erro ao pegar item: {e}")
            return False

    def reload_newly_acquired_rods(self, rods):
        """Recarregar varas rec√©m adquiridas do ba√∫"""
        print("\nüîß RECARREGANDO VARAS NOVAS...")

        for i, rod in enumerate(rods, 1):
            print(f"   ‚Ä¢ Recarregando vara {i}/{len(rods)}...")

            # Encontrar slot vazio para colocar a vara
            empty_slot = self.find_empty_rod_slot()
            if empty_slot:
                # Equipar vara no slot
                pyautogui.press(str(empty_slot))
                time.sleep(0.5)

                # Recarregar com isca
                if self.auto_reload_rod(empty_slot):
                    print(f"   ‚úÖ Vara no slot {empty_slot} recarregada!")
                else:
                    print(f"   ‚ùå Falha ao recarregar vara no slot {empty_slot}")

    def find_empty_rod_slot(self):
        """Encontrar pr√≥ximo slot vazio para vara"""
        if hasattr(self, 'rod_status_tracking'):
            empty_slots = self.rod_status_tracking.get('empty_slots', [])
            if empty_slots:
                return empty_slots[0]

        # Verificar todos os slots
        for slot in range(1, 7):
            # Verificar se slot est√° vazio
            focus_game_window()  # Garantir foco antes de pressionar tecla
            pyautogui.press(str(slot))
            time.sleep(0.3)

            # Detectar se tem vara no slot
            if not self.detect_rod_in_current_slot():
                return slot

        return None

    def detect_rod_in_current_slot(self):
        """Detectar se h√° vara no slot atual"""
        # Implementa√ß√£o simplificada - pode ser melhorada
        return False  # Por enquanto retorna False para teste

    def detect_inventory_open(self):
        """Detectar se o invent√°rio est√° aberto usando inventory.png"""
        try:
            import cv2
            import numpy as np
            import mss
            import os

            # Verificar se template inventory.png existe
            inventory_template_path = "templates/inventory.png"
            if not os.path.exists(inventory_template_path):
                # Fallback para m√©todo anterior se n√£o tiver template
                return self.detect_inventory_fallback()

            # Capturar tela completa
            with mss.mss() as sct:
                screenshot = sct.grab(sct.monitors[1])
                screen = np.array(screenshot)
                screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)

            # Carregar template do invent√°rio
            inventory_template = cv2.imread(inventory_template_path)
            if inventory_template is None:
                return self.detect_inventory_fallback()

            # Template matching
            result = cv2.matchTemplate(screen_bgr, inventory_template, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

            # Threshold alto para garantir que √© realmente o invent√°rio
            threshold = 0.8
            is_open = max_val > threshold

            if is_open:
                print(f"[INVENTORY] Detectado aberto - Conf: {max_val:.3f}")

            return is_open

        except Exception as e:
            print(f"[INVENTORY] Erro na detec√ß√£o: {e}")
            return self.detect_inventory_fallback()

    def detect_inventory_fallback(self):
        """M√©todo alternativo de detec√ß√£o de invent√°rio"""
        try:
            import cv2
            import numpy as np
            import mss

            with mss.mss() as sct:
                # Capturar regi√£o da linha divis√≥ria (x=1233)
                region = {
                    'top': 200,
                    'left': 1200,
                    'width': 100,
                    'height': 600
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)

            # Procurar por linha vertical (divis√≥ria do invent√°rio)
            gray = cv2.cvtColor(screen[:,:,:3], cv2.COLOR_BGR2GRAY)
            edges = cv2.Canny(gray, 100, 200)

            # Contar bordas verticais
            vertical_lines = 0
            for x in range(edges.shape[1]):
                column = edges[:, x]
                if np.sum(column > 0) > 50:  # Se coluna tem muitas bordas
                    vertical_lines += 1

            return vertical_lines > 5  # Se tem v√°rias linhas verticais

        except Exception as e:
            return False

    def close_inventory_with_delay(self, context="Opera√ß√£o"):
        """Fechar invent√°rio com delay adequado para pesca"""
        print(f"üì¶ Fechando invent√°rio ap√≥s {context}...")
        pyautogui.press('tab')

        # üé£ DELAY OTIMIZADO: Reduzido para melhor performance
        print("‚è±Ô∏è Aguardando estabiliza√ß√£o ap√≥s fechar invent√°rio...")
        time.sleep(0.2)  # ‚úÖ OTIMIZADO: Reduzido de 0.5s para 0.2s

        # Atualizar estado do jogo e limpar flag de abertura manual
        self.game_state['inventory_open'] = False
        self.game_state['manual_inventory_open'] = False
        
        # Limpar flag de limpeza autom√°tica se estava ativa
        if self.game_state.get('auto_clean_in_progress', False):
            self.game_state['auto_clean_in_progress'] = False
            self.auto_clean['in_progress'] = False
        print("‚úÖ Invent√°rio fechado - pronto para pesca")

    def improved_fishing_sequence(self):
        """Sequ√™ncia de pesca melhorada com timing correto E coordena√ß√£o inteligente"""

        # üéØ USAR SISTEMA DE COORDENA√á√ÉO PARA MACRO PRINCIPAL
        return self.request_operation(
            'macro_fishing',
            self._protected_fishing_sequence,
            context="Macro principal de pesca"
        )

    def check_rod_in_hand_needs_bait(self):
        """üîç Verificar se a vara na m√£o est√° sem isca"""
        try:
            print("üîç Verificando vara na m√£o...")

            # Detectar objetos na tela (fora do invent√°rio)
            detections = self.detect_objects()

            # Procurar vara sem isca na regi√£o central (vara na m√£o)
            # Regi√£o aproximada onde aparece vara na m√£o: centro da tela
            hand_region = {
                'x_min': 600,
                'x_max': 1300,
                'y_min': 300,
                'y_max': 700
            }

            for detection in detections:
                x, y = detection.get('center', (0, 0))
                item_class = detection.get('class', '').lower()

                # Verificar se est√° na regi√£o da m√£o
                if (hand_region['x_min'] <= x <= hand_region['x_max'] and
                    hand_region['y_min'] <= y <= hand_region['y_max']):

                    # Verificar se √© vara sem isca
                    if ('varasemisca' in item_class or 'semiscavara' in item_class or 'semiscanam' in item_class or 'namaosemisca' in item_class or
                        ('vara' in item_class and 'comisca' not in item_class and 'quebrada' not in item_class and 'namaocomisca' not in item_class and 'comiscanamao' not in item_class)):
                        print(f"üö® Vara sem isca detectada na m√£o: {item_class} em ({x}, {y})")
                        return True

            return False

        except Exception as e:
            print(f"‚ùå Erro ao verificar vara na m√£o: {e}")
            return False

    def test_rod_in_hand_detection(self):
        """üß™ TESTAR detec√ß√£o de vara na m√£o - namaocomisca e semiscanam"""
        print("\nüß™ TESTANDO DETEC√á√ÉO DE VARA NA M√ÉO...")
        print("="*50)

        try:
            import os

            # Verificar se templates existem
            templates_to_check = ['namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'VARANOBAUCI.png', 'enbausi.png']
            for template in templates_to_check:
                template_path = f"templates/{template}"
                exists = os.path.exists(template_path)
                print(f"üìÅ {template}: {'‚úÖ Existe' if exists else '‚ùå N√£o encontrado'}")

            # Detectar objetos na tela
            print("\nüîç Detectando objetos na tela...")
            detections = self.detect_objects()

            print(f"üìä Total de detec√ß√µes: {len(detections)}")

            # Procurar por vara na m√£o
            hand_region = {
                'x_min': 600, 'x_max': 1300,
                'y_min': 300, 'y_max': 700
            }

            hand_detections = []
            for detection in detections:
                x, y = detection.get('center', (0, 0))
                if (hand_region['x_min'] <= x <= hand_region['x_max'] and
                    hand_region['y_min'] <= y <= hand_region['y_max']):
                    item_class = detection.get('class', '').lower()
                    print(f"üéØ Regi√£o da m√£o: {item_class} em ({x}, {y})")
                    hand_detections.append(detection)

            # Verificar especificamente todos os padr√µes de vara na m√£o
            for detection in detections:
                item_class = detection.get('class', '').lower()
                x, y = detection.get('center', (0, 0))

                if 'namaocomisca' in item_class:
                    print(f"üü¢ NAMAOCOMISCA (COM ISCA) detectado: {item_class} em ({x}, {y})")
                elif 'comiscanamao' in item_class:
                    print(f"üü¢ COMISCANAMAO (COM ISCA) detectado: {item_class} em ({x}, {y})")
                elif 'semiscanam' in item_class:
                    print(f"üîµ SEMISCANAM (SEM ISCA) detectado: {item_class} em ({x}, {y})")
                elif 'namaosemisca' in item_class:
                    print(f"üîµ NAMAOSEMISCA (SEM ISCA) detectado: {item_class} em ({x}, {y})")

            print(f"\nüìä Resumo:")
            print(f"   ‚Ä¢ Detec√ß√µes na regi√£o da m√£o: {len(hand_detections)}")
            print(f"   ‚Ä¢ Templates verificados: {len(templates_to_check)}")

            # Testar fun√ß√£o principal
            needs_bait = self.check_rod_in_hand_needs_bait()
            print(f"   ‚Ä¢ Vara sem isca na m√£o: {'‚úÖ SIM' if needs_bait else '‚ùå N√ÉO'}")

        except Exception as e:
            print(f"‚ùå Erro no teste: {e}")
            import traceback
            traceback.print_exc()

    def handle_rod_without_bait_in_hand(self):
        """üîß Lidar com vara sem isca na m√£o - aplicar isca e continuar"""
        try:
            print("üîß Aplicando isca na vara da m√£o...")

            # Abrir invent√°rio para aplicar isca
            if not self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                time.sleep(0.8)
                self.game_state['inventory_open'] = True

            # Usar sistema simplificado de drag & drop
            # A vara "sem isca" agora estar√° no invent√°rio no slot atual
            success = self.smart_reload_rod()

            # Fechar invent√°rio
            if self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                time.sleep(0.5)
                self.game_state['inventory_open'] = False

            if success:
                print("‚úÖ Isca aplicada com sucesso na vara da m√£o!")
                # Pequena pausa para estabilizar
                time.sleep(1.0)

            return success

        except Exception as e:
            print(f"‚ùå Erro ao aplicar isca na vara da m√£o: {e}")
            # Garantir que invent√°rio seja fechado
            if self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                self.game_state['inventory_open'] = False
            return False

    def _protected_fishing_sequence(self):
        """üîí Sequ√™ncia de pesca protegida pelo sistema de coordena√ß√£o"""
        print("\nüé£ Iniciando sequ√™ncia de pesca PROTEGIDA...")

        try:
            # üéØ NOVA VERIFICA√á√ÉO: Detectar vara sem isca na m√£o
            if self.check_rod_in_hand_needs_bait():
                print("üö® VARA SEM ISCA DETECTADA NA M√ÉO!")
                # Parar fluxo, colocar isca e reiniciar
                if self.handle_rod_without_bait_in_hand():
                    print("‚úÖ Isca aplicada! Reiniciando pesca...")
                else:
                    print("‚ùå Falha ao aplicar isca - abortando pesca")
                    return False

            # Garantir que n√£o est√° com invent√°rio aberto
            if self.game_state.get('inventory_open', False):
                self.close_inventory_with_delay("Pr√©-pesca")

            # Aguardar estabiliza√ß√£o ap√≥s fechar invent√°rio (se necess√°rio)
            # (j√° inclu√≠do no close_inventory_with_delay)

            # 1. SEGURAR BOT√ÉO DIREITO 
            print("üéØ Segurando bot√£o direito...")
            pyautogui.mouseDown(button='right')
            self.game_state['right_mouse_down'] = True
            
            # 2. AGUARDAR 2 SEGUNDOS ANTES DOS CLIQUES (SOLICITADO)
            print("‚è∞ Aguardando 2 segundos antes de iniciar cliques...")
            time.sleep(2.0)
            
            # 3. 4 CLIQUES DEVAGAR COM 1 SEGUNDO CADA (SOLICITADO)
            print("üêå Executando 4 cliques devagar (1s cada)...")
            for i in range(4):
                if not self.running or self.paused:
                    break
                print(f"   üêå Clique devagar {i+1}/4")
                pyautogui.click(button='left')
                time.sleep(1.0)  # 1 segundo entre cada clique devagar

            # 4. CLIQUES R√ÅPIDOS (ap√≥s os devagar)
            print("‚ö° Iniciando cliques r√°pidos...")
            for i in range(8):  # 8 cliques r√°pidos
                if not self.running or self.paused:
                    break
                pyautogui.click(button='left')
                time.sleep(0.1)  # 100ms entre cliques

            # 3. MANTER DIREITO PRESSIONADO por mais tempo se necess√°rio
            time.sleep(0.5)

            # 4. SOLTAR BOT√ÉO DIREITO
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='right')
            self.game_state['right_mouse_down'] = False
            print("üîÑ Bot√£o direito solto - aguardando resultado...")

            return True

        except Exception as e:
            print(f"‚ùå Erro na sequ√™ncia de pesca protegida: {e}")
            # Garantir que bot√£o direito seja solto em caso de erro
            try:
                if self.game_state.get('right_mouse_down', False):
                    focus_game_window()  # Garantir foco
                    pyautogui.mouseUp(button='right')
                    self.game_state['right_mouse_down'] = False
            except:
                pass
            return False

    def detect_inventory_chest_division(self):
        """Detectar se a divis√≥ria invent√°rio/ba√∫ est√° vis√≠vel (x=1233)"""
        try:
            import cv2
            import numpy as np
            import mss

            with mss.mss() as sct:
                # Capturar regi√£o da linha divis√≥ria - REFATORADO
                region = {
                    'top': 100,
                    'left': INVENTORY_CHEST_DIVIDER_X - 3,  # Ao redor da divis√≥ria
                    'width': 10,
                    'height': 800
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)

            # Procurar linha vertical
            gray = cv2.cvtColor(screen[:,:,:3], cv2.COLOR_BGR2GRAY)
            edges = cv2.Canny(gray, 100, 200)

            # Contar pixels de borda na linha central (x=1233)
            center_column = edges[:, edges.shape[1]//2]
            edge_pixels = np.sum(center_column > 0)

            # Se tem muitos pixels de borda, divis√≥ria est√° vis√≠vel
            threshold = 50
            division_visible = edge_pixels > threshold

            if division_visible:
                print(f"[DIVISION] Divis√≥ria invent√°rio/ba√∫ detectada - pixels: {edge_pixels}")

            return division_visible

        except Exception as e:
            print(f"[DIVISION] Erro na detec√ß√£o: {e}")
            return False

    def intelligent_rod_priority_system(self):
        """üéØ SISTEMA DE PRIORIZA√á√ÉO INTELIGENTE: VARANOBAUCI tem prioridade m√°xima sobre recargas"""
        print("\nüéØ SISTEMA DE PRIORIZA√á√ÉO INTELIGENTE ATIVO...")

        if not hasattr(self, 'rod_status_tracking'):
            print("‚ö†Ô∏è Dados de tracking n√£o dispon√≠veis")
            return False

        available_with_bait = self.rod_status_tracking.get('available_with_bait', [])
        available_without_bait = self.rod_status_tracking.get('available_without_bait', [])
        current_rod = self.get_absolute_rod_number()

        print(f"üìä Estado atual:")
        print(f"   ‚úÖ Com isca: {available_with_bait}")
        print(f"   ‚ö†Ô∏è Sem isca: {available_without_bait}")
        print(f"   üé£ Vara atual: {current_rod}")

        # PRIORIDADE 1: Se h√° varas com isca (VARANOBAUCI, etc), usar elas PRIMEIRO
        if available_with_bait:
            other_rods_with_bait = [r for r in available_with_bait if r != current_rod]

            if other_rods_with_bait:
                target_rod = other_rods_with_bait[0]
                print(f"üéØ PRIORIDADE M√ÅXIMA: Trocando para vara {target_rod} (tem isca) ANTES de recarregar qualquer outra")
                self.switch_to_absolute_rod(target_rod)
                return True

        # PRIORIDADE 2: Se n√£o h√° varas com isca, recarregar as sem isca
        if available_without_bait:
            print(f"üîß Nenhuma vara com isca dispon√≠vel. Recarregando {len(available_without_bait)} varas sem isca...")
            return self.reload_all_rods()

        print("‚ö†Ô∏è Situa√ß√£o cr√≠tica: Nenhuma vara dispon√≠vel")
        return False

    def comprehensive_rod_management(self):
        """Sistema completo de gerenciamento de varas"""
        print("\nüîß INICIANDO GERENCIAMENTO COMPLETO DE VARAS...")

        # 1. ABRIR INVENT√ÅRIO PARA AN√ÅLISE
        if not self.game_state.get('inventory_open', False):
            print("üì¶ Abrindo invent√°rio para an√°lise completa...")
            pyautogui.press('tab')
            time.sleep(2.0)  # Dar tempo para detec√ß√µes
            self.game_state['inventory_open'] = True

        # 2. AGUARDAR DETEC√á√ïES DO CATCH VIEWER
        print("üîç Aguardando an√°lise completa do Catch Viewer...")
        for i in range(15):  # At√© 7.5 segundos
            time.sleep(0.5)
            if hasattr(self, 'rod_status_tracking') and self.rod_status_tracking.get('slots'):
                print(f"‚úÖ An√°lise conclu√≠da ap√≥s {(i+1)*0.5:.1f}s")
                break

        # 3. ANALISAR SITUA√á√ÉO ATUAL
        if not hasattr(self, 'rod_status_tracking'):
            print("‚ùå N√£o foi poss√≠vel obter dados das varas!")
            self.close_inventory_with_delay("Falha na an√°lise")
            return False

        with_bait = self.rod_status_tracking.get('available_with_bait', [])
        without_bait = self.rod_status_tracking.get('available_without_bait', [])
        broken = self.rod_status_tracking.get('broken_rods', [])
        empty_slots = self.calculate_empty_slots()

        print(f"\nüìä AN√ÅLISE ATUAL:")
        print(f"   ‚úÖ Varas com isca: {with_bait} (total: {len(with_bait)})")
        print(f"   ‚ö†Ô∏è Varas sem isca: {without_bait} (total: {len(without_bait)})")
        print(f"   ‚ùå Varas quebradas: {broken} (total: {len(broken)})")
        print(f"   üî≤ Slots vazios: {empty_slots} (total: {len(empty_slots)})")

        # 4. EXECUTAR A√á√ïES CONFORME NECESS√ÅRIO
        actions_taken = []

        # 4.1 JOGAR VARAS QUEBRADAS FORA
        if broken:
            print(f"\nüóëÔ∏è Descartando {len(broken)} vara(s) quebrada(s)...")
            for slot in broken:
                if self.discard_broken_rod(slot):
                    actions_taken.append(f"Descartou vara quebrada slot {slot}")
                    empty_slots.append(slot)  # Slot agora est√° vazio

        # 4.2 RECARREGAR VARAS SEM ISCA
        if without_bait:
            print(f"\nüîÑ Recarregando {len(without_bait)} vara(s) sem isca...")
            for slot in without_bait:
                if self.reload_rod_with_bait(slot):
                    actions_taken.append(f"Recarregou vara slot {slot}")
                    # Mover de sem isca para com isca
                    with_bait.append(slot)

        # 4.3 VERIFICAR SE PRECISA BUSCAR VARAS NO BA√ö
        total_active_rods = len(with_bait) + len(without_bait)
        if total_active_rods < 4 or len(empty_slots) > 2:
            print(f"\nüè™ Precisamos de mais varas! Usando sistema coordenado...")

            # ‚ö° USAR COORDENA√á√ÉO CENTRAL PARA BA√ö
            if self.coordinate_chest_operations("Buscar varas no ba√∫",
                                               lambda chest_already_open=False: self.fetch_rods_from_chest(empty_slots, chest_already_open)):
                actions_taken.append("Buscou varas no ba√∫")

        # 5. FECHAR INVENT√ÅRIO E ATUALIZAR SISTEMA
        self.close_inventory_with_delay("Gerenciamento completo")

        # 6. CONFIGURAR SISTEMA DE CICLO INTELIGENTE
        self.setup_intelligent_rod_cycling()

        print(f"\n‚úÖ GERENCIAMENTO CONCLU√çDO!")
        print(f"üìã A√ß√µes realizadas: {len(actions_taken)}")
        for action in actions_taken:
            print(f"   ‚Ä¢ {action}")

        return len(actions_taken) > 0

    def calculate_empty_slots(self):
        """Calcular quais slots est√£o vazios"""
        if not hasattr(self, 'rod_status_tracking'):
            return list(range(1, 7))  # Assumir todos vazios se n√£o tem dados

        occupied_slots = set(self.rod_status_tracking.get('slots', {}).keys())
        all_slots = set(range(1, 7))
        empty_slots = list(all_slots - occupied_slots)

        return sorted(empty_slots)

    def discard_broken_rod(self, slot):
        """üîß Manejo de vara quebrada (descarte ou armazenamento conforme configura√ß√£o)"""
        try:
            # ‚ö° VERIFICAR CONFIGURA√á√ÉO DO USU√ÅRIO
            broken_rod_action = self.config.get('broken_rod_action', 'discard')
            action_name = "Descartando" if broken_rod_action == 'discard' else "Guardando no ba√∫"
            
            print(f"üîß {action_name} vara quebrada do slot {slot}...")
            print(f"‚öôÔ∏è MODO CONFIGURADO: {broken_rod_action}")
            
            if broken_rod_action == 'save':
                # üì¶ MODO ARMAZENAMENTO - usar fun√ß√£o espec√≠fica
                self.save_broken_rod_to_chest(slot)
                return True

            # Selecionar o slot
            focus_game_window()  # Garantir foco antes de pressionar tecla
            pyautogui.press(str(slot))
            time.sleep(0.5)

            # Clicar e arrastar para fora do invent√°rio (lado direito)
            # Assumindo que a vara aparece na regi√£o central ap√≥s sele√ß√£o
            pyautogui.click(960, 540)  # Centro da tela
            time.sleep(0.2)

            # Arrastar para fora (lado direito)
            pyautogui.drag(1500, 540, duration=0.5, button='left')
            time.sleep(0.3)

            print(f"‚úÖ Vara quebrada do slot {slot} descartada")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao descartar vara quebrada slot {slot}: {e}")
            return False

    def reload_rod_with_bait(self, slot):
        """Recarregar vara espec√≠fica com isca"""
        try:
            print(f"üé£ Recarregando vara do slot {slot}...")

            # Selecionar o slot
            focus_game_window()  # Garantir foco antes de pressionar tecla
            pyautogui.press(str(slot))
            time.sleep(0.5)

            # Encontrar isca no invent√°rio (lado esquerdo da divis√≥ria)
            bait_position = self.find_bait_in_inventory()
            if not bait_position:
                print(f"‚ùå N√£o encontrou isca para recarregar slot {slot}")
                return False

            # Clicar na isca
            pyautogui.click(bait_position[0], bait_position[1])
            time.sleep(0.3)

            print(f"‚úÖ Vara do slot {slot} recarregada")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao recarregar vara slot {slot}: {e}")
            return False

    def find_bait_in_inventory(self):
        """Encontrar isca no lado esquerdo do invent√°rio (x < 1233)"""
        try:
            # Lista de iscas por prioridade
            bait_templates = ['wolfmeat.png', 'bearmeat.png', 'grub.png', 'worm.png']

            import cv2
            import numpy as np
            import mss
            import os

            with mss.mss() as sct:
                # Capturar apenas lado esquerdo (invent√°rio)
                region = {
                    'top': 200,
                    'left': 500,
                    'width': 633,  # At√© x=1233 (largura do invent√°rio)
                    'height': 600
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)
                screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)

            # Procurar por cada tipo de isca
            for bait_name in bait_templates:
                template_path = f"templates/{bait_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path)
                    if template is not None:
                        result = cv2.matchTemplate(screen_bgr, template, cv2.TM_CCOEFF_NORMED)
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        if max_val > 0.7:
                            # Converter coordenadas relativas para absolutas
                            abs_x = region['left'] + max_loc[0] + template.shape[1]//2
                            abs_y = region['top'] + max_loc[1] + template.shape[0]//2
                            print(f"üé£ Isca encontrada: {bait_name} em ({abs_x}, {abs_y})")
                            return (abs_x, abs_y)

            return None

        except Exception as e:
            print(f"‚ùå Erro ao procurar isca: {e}")
            return None

    def fetch_rods_from_chest(self, empty_slots, chest_already_open=False):
        """üîß SISTEMA CORRIGIDO: Buscar varas do ba√∫ para slots espec√≠ficos vazios"""
        try:
            print(f"\nüè™ [CORRIGIDO] Buscando varas para slots espec√≠ficos: {empty_slots}")

            # 1. PRIMEIRO: Limpar slots vazios garantindo que est√£o livres
            self.clean_broken_rods_before_replacement(empty_slots)

            # 2. SEGUNDO: Garantir limpeza completa dos slots com clique direito
            self.ensure_empty_slots_are_clean(empty_slots)

            # ‚ö° COORDENA√á√ÉO CENTRAL - verificar se ba√∫ j√° est√° aberto
            if not chest_already_open:
                # Verificar se j√° temos divis√≥ria vis√≠vel (ba√∫ j√° aberto)
                if not self.detect_inventory_chest_division():
                    # Abrir ba√∫ se n√£o estiver aberto
                    if not self.open_chest_safely():
                        print("‚ùå Falha ao abrir ba√∫")
                        return False
                    time.sleep(1.5)
            else:
                print("‚úÖ [COORDENADO] Ba√∫ j√° est√° aberto - prosseguindo diretamente!")
                time.sleep(0.5)  # Pausa menor j√° que ba√∫ est√° aberto

            # Aguardar divis√≥ria ficar vis√≠vel
            for i in range(10):
                if self.detect_inventory_chest_division():
                    print("‚úÖ Divis√≥ria invent√°rio/ba√∫ detectada")
                    break
                time.sleep(0.5)
            else:
                print("‚ùå Divis√≥ria n√£o detectada - ba√∫ pode n√£o estar aberto")
                return False

            # Buscar varas no lado direito (ba√∫)
            rods_found = self.find_rods_in_chest()
            baits_found = self.find_baits_in_chest()

            print(f"üì¶ Encontrado no ba√∫: {len(rods_found)} varas, {len(baits_found)} iscas")

            # üéØ CORRE√á√ÉO CR√çTICA: Pegar EXATAMENTE a quantidade de slots vazios
            rods_needed = len(empty_slots)  # N√£o usar min() - pegar exato

            if len(rods_found) < rods_needed:
                print(f"‚ö†Ô∏è ATEN√á√ÉO: S√≥ h√° {len(rods_found)} varas no ba√∫ para {rods_needed} slots!")
                rods_needed = len(rods_found)

            print(f"üéØ Coletando EXATAMENTE {rods_needed} varas para slots {empty_slots[:rods_needed]}")

            # Priorizar varas com isca
            rods_with_bait = [r for r in rods_found if 'comisca' in r.get('name', '').lower()]
            rods_without_bait = [r for r in rods_found if 'semisca' in r.get('name', '').lower()]

            collected_rods = 0

            # 2. COLETA ESTRAT√âGICA - varas COM isca primeiro
            for i, rod in enumerate(rods_with_bait[:rods_needed]):
                target_slot = empty_slots[collected_rods] if collected_rods < len(empty_slots) else None
                print(f"   üé£ [{collected_rods+1}/{rods_needed}] Transferindo vara COM isca para slot {target_slot}")

                if self.transfer_item_from_chest_to_inventory(rod):
                    collected_rods += 1
                    if collected_rods >= rods_needed:
                        break

            # 3. COLETA COMPLEMENTAR - varas SEM isca + iscas autom√°ticas
            if collected_rods < rods_needed:
                remaining_needed = rods_needed - collected_rods
                print(f"   üîß Coletando {remaining_needed} varas SEM isca + iscas para slots restantes...")

                for i, rod in enumerate(rods_without_bait[:remaining_needed]):
                    target_slot = empty_slots[collected_rods] if collected_rods < len(empty_slots) else None
                    print(f"   üõ†Ô∏è [{collected_rods+1}/{rods_needed}] Transferindo vara SEM isca para slot {target_slot}")

                    if self.transfer_item_from_chest_to_inventory(rod):
                        collected_rods += 1

                        # üéØ NOVA L√ìGICA: Pegar isca automaticamente junto
                        if baits_found:
                            bait = baits_found.pop(0)
                            print(f"      ü•© Pegando isca {bait.get('name', 'isca')} para a vara")
                            self.transfer_item_from_chest_to_inventory(bait)

            # 4. RESULTADO FINAL
            actual_filled_slots = empty_slots[:collected_rods]
            print(f"‚úÖ CONCLU√çDO: {collected_rods} varas coletadas para slots {actual_filled_slots}")

            if collected_rods < len(empty_slots):
                unfilled_slots = empty_slots[collected_rods:]
                print(f"‚ö†Ô∏è SLOTS N√ÉO PREENCHIDOS: {unfilled_slots} (faltam varas no ba√∫)")

            return collected_rods > 0

        except Exception as e:
            print(f"‚ùå Erro ao buscar varas no ba√∫: {e}")
            return False

    def clean_broken_rods_before_replacement(self, empty_slots):
        """üîß NOVA FUN√á√ÉO: Remover iscas e descartar varas quebradas antes de pegar novas"""
        print(f"\nüßπ Limpando varas quebradas nos slots {empty_slots}...")

        try:
            # Definir posi√ß√µes fixas dos slots de vara
            slot_positions = {
                1: (709, 1005),   # Slot 1
                2: (805, 1005),   # Slot 2
                3: (899, 1005),   # Slot 3
                4: (992, 1005),   # Slot 4
                5: (1092, 1005),  # Slot 5
                6: (1188, 1005)   # Slot 6
            }

            for slot in empty_slots:
                print(f"   üîç Verificando slot {slot}...")

                # Abrir invent√°rio se n√£o estiver aberto
                if not self.game_state.get('inventory_open', False):
                    pyautogui.press('tab')
                    time.sleep(0.8)
                    self.game_state['inventory_open'] = True

                # Detectar se h√° vara quebrada no slot
                slot_pos = slot_positions.get(slot)
                if not slot_pos:
                    continue

                # Verificar se h√° item no slot usando detec√ß√£o
                detections = self.detect_objects()
                vara_quebrada_found = False

                for detection in detections:
                    # Verificar se est√° na regi√£o do slot espec√≠fico
                    det_x, det_y = detection.get('center', (0, 0))
                    slot_x, slot_y = slot_pos

                    # Toler√¢ncia de 50 pixels para o slot
                    if (abs(det_x - slot_x) < 50 and abs(det_y - slot_y) < 50):
                        item_class = detection.get('class', '').lower()

                        # Verificar se √© vara quebrada
                        if 'quebrada' in item_class or 'broken' in item_class:
                            vara_quebrada_found = True
                            print(f"      üö® Vara quebrada detectada no slot {slot}!")

                            # Remover isca primeiro (clique direito)
                            print(f"      ü•© Removendo isca da vara quebrada...")
                            pyautogui.rightClick(slot_x, slot_y)
                            time.sleep(0.5)

                            # Arrastar vara quebrada para fora do invent√°rio (descartar)
                            print(f"      üóëÔ∏è Descartando vara quebrada...")
                            pyautogui.drag(slot_x, slot_y, slot_x + 200, slot_y - 200, duration=0.5)
                            time.sleep(0.5)

                            break

                if not vara_quebrada_found:
                    print(f"      ‚úÖ Slot {slot} j√° est√° limpo")

            # Fechar invent√°rio ap√≥s limpeza
            if self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                time.sleep(0.5)
                self.game_state['inventory_open'] = False

            print("‚úÖ Limpeza de varas quebradas conclu√≠da!")

        except Exception as e:
            print(f"‚ùå Erro na limpeza de varas quebradas: {e}")
            # Garantir que invent√°rio seja fechado
            if self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                self.game_state['inventory_open'] = False

    def ensure_empty_slots_are_clean(self, empty_slots):
        """üßº GARANTIR que slots est√£o completamente limpos com clique direito"""
        print(f"\nüßº Garantindo limpeza completa dos slots {empty_slots}...")

        try:
            # Definir posi√ß√µes fixas dos slots de vara
            slot_positions = {
                1: (709, 1005),   # Slot 1
                2: (805, 1005),   # Slot 2
                3: (899, 1005),   # Slot 3
                4: (992, 1005),   # Slot 4
                5: (1092, 1005),  # Slot 5
                6: (1188, 1005)   # Slot 6
            }

            # Abrir invent√°rio se n√£o estiver aberto
            if not self.game_state.get('inventory_open', False):
                pyautogui.press('tab')
                time.sleep(0.8)
                self.game_state['inventory_open'] = True

            # Clicar bot√£o direito 1 vez em cada slot vazio para garantir limpeza
            for slot in empty_slots:
                slot_pos = slot_positions.get(slot)
                if slot_pos:
                    print(f"   üßº Limpando slot {slot} com clique direito...")
                    pyautogui.rightClick(slot_pos[0], slot_pos[1])
                    time.sleep(0.3)  # Pausa entre cliques

            print("‚úÖ Limpeza garantida com clique direito conclu√≠da!")

        except Exception as e:
            print(f"‚ùå Erro na limpeza com clique direito: {e}")

    def find_rods_in_chest(self):
        """Encontrar varas no lado direito (ba√∫) usando template matching"""
        try:
            rod_templates = ['VARANOBAUCI.png', 'varacomisca.png', 'varasemisca.png', 'comiscavara.png', 'semiscavara.png', 'namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'enbausi.png']  # üéØ VARANOBAUCI primeiro
            found_rods = []

            import cv2
            import numpy as np
            import mss
            import os

            with mss.mss() as sct:
                # Capturar apenas lado direito (ba√∫)
                region = {
                    'top': 200,
                    'left': 1214,  # In√≠cio do ba√∫ (ap√≥s divis√≥ria)
                    'width': 677,   # Resto da tela
                    'height': 600
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)
                screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)

            for template_name in rod_templates:
                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path)
                    if template is not None:
                        result = cv2.matchTemplate(screen_bgr, template, cv2.TM_CCOEFF_NORMED)
                        locations = np.where(result >= 0.75)

                        for pt in zip(*locations[::-1]):
                            abs_x = region['left'] + pt[0] + template.shape[1]//2
                            abs_y = region['top'] + pt[1] + template.shape[0]//2

                            found_rods.append({
                                'name': template_name,
                                'x': abs_x,
                                'y': abs_y,
                                'confidence': result[pt[1], pt[0]]
                            })

            return found_rods[:6]  # M√°ximo 6 varas

        except Exception as e:
            print(f"‚ùå Erro ao procurar varas no ba√∫: {e}")
            return []

    def find_baits_in_chest(self):
        """Encontrar iscas no ba√∫"""
        try:
            bait_templates = ['wolfmeat.png', 'bearmeat.png', 'grub.png', 'worm.png']
            found_baits = []

            import cv2
            import numpy as np
            import mss
            import os

            with mss.mss() as sct:
                region = {
                    'top': 200,
                    'left': 1243,
                    'width': 677,
                    'height': 600
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)
                screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)

            for template_name in bait_templates:
                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path)
                    if template is not None:
                        result = cv2.matchTemplate(screen_bgr, template, cv2.TM_CCOEFF_NORMED)
                        locations = np.where(result >= 0.7)

                        for pt in zip(*locations[::-1]):
                            abs_x = region['left'] + pt[0] + template.shape[1]//2
                            abs_y = region['top'] + pt[1] + template.shape[0]//2

                            found_baits.append({
                                'name': template_name,
                                'x': abs_x,
                                'y': abs_y,
                                'confidence': result[pt[1], pt[0]]
                            })

            return found_baits[:10]  # M√°ximo 10 iscas

        except Exception as e:
            return []

    def transfer_item_from_chest_to_inventory(self, item):
        """Transferir item do ba√∫ para invent√°rio usando Shift+Click"""
        try:
            x, y = item['x'], item['y']
            print(f"üîÑ Transferindo {item['name']} de ({x}, {y})...")

            # Shift+Click para transferir
            pyautogui.keyDown('shift')
            time.sleep(0.1)
            pyautogui.click(x, y)
            time.sleep(0.2)
            pyautogui.keyUp('shift')

            return True

        except Exception as e:
            print(f"‚ùå Erro ao transferir item: {e}")
            return False

    def setup_intelligent_rod_cycling(self):
        """Configurar sistema inteligente de ciclo por antiguidade (1,2 ‚Üí 3,4 ‚Üí 5,6)"""
        if not hasattr(self, 'rod_status_tracking'):
            return

        with_bait = self.rod_status_tracking.get('available_with_bait', [])

        # Sistema de antiguidade - inicializar tracking se n√£o existir
        if not hasattr(self, 'rod_age_system'):
            self.rod_age_system = {
                'pair_order': ['1-2', '3-4', '5-6'],
                'current_pair_index': 0,
                'pair_usage_count': {'1-2': 0, '3-4': 0, '5-6': 0},
                'max_usage_per_pair': 30  # Usar cada dupla por 30 peixes antes de rodar
            }

        # Definir duplas
        pairs = {
            '1-2': [1, 2],
            '3-4': [3, 4],
            '5-6': [5, 6]
        }

        # L√ìGICA DE ANTIGUIDADE: Usar duplas em ordem, n√£o por disponibilidade
        current_pair_name = self.rod_age_system['pair_order'][self.rod_age_system['current_pair_index']]
        current_pair_slots = pairs[current_pair_name]

        # Verificar se a dupla atual tem varas com isca
        current_pair_with_bait = [slot for slot in current_pair_slots if slot in with_bait]

        if current_pair_with_bait:
            # Dupla atual tem isca - usar ela
            self.rod_system['current_pair'] = current_pair_name
            target_rod = current_pair_with_bait[0]

            if target_rod in [1, 2]:
                self.rod_system['current_rod'] = 1 if target_rod == 1 else 2
            elif target_rod in [3, 4]:
                self.rod_system['current_rod'] = 1 if target_rod == 3 else 2
            elif target_rod in [5, 6]:
                self.rod_system['current_rod'] = 1 if target_rod == 5 else 2

            print(f"üéØ SISTEMA ANTIGUIDADE: Usando dupla {current_pair_name} (ordem: {self.rod_age_system['current_pair_index']+1}/3)")
            print(f"   ‚Ä¢ Vara ativa: {target_rod}")
            print(f"   ‚Ä¢ Uso da dupla: {self.rod_age_system['pair_usage_count'][current_pair_name]}/{self.rod_age_system['max_usage_per_pair']}")

        else:
            # Dupla atual n√£o tem isca - procurar pr√≥xima na ordem
            print(f"‚ö†Ô∏è Dupla {current_pair_name} sem isca dispon√≠vel")

            for i in range(3):  # Tentar todas as duplas
                next_index = (self.rod_age_system['current_pair_index'] + i + 1) % 3
                next_pair_name = self.rod_age_system['pair_order'][next_index]
                next_pair_slots = pairs[next_pair_name]
                next_pair_with_bait = [slot for slot in next_pair_slots if slot in with_bait]

                if next_pair_with_bait:
                    print(f"üîÑ ROTACIONANDO para pr√≥xima dupla: {next_pair_name}")
                    self.rod_age_system['current_pair_index'] = next_index

                    self.rod_system['current_pair'] = next_pair_name
                    target_rod = next_pair_with_bait[0]

                    if target_rod in [1, 2]:
                        self.rod_system['current_rod'] = 1 if target_rod == 1 else 2
                    elif target_rod in [3, 4]:
                        self.rod_system['current_rod'] = 1 if target_rod == 3 else 2
                    elif target_rod in [5, 6]:
                        self.rod_system['current_rod'] = 1 if target_rod == 5 else 2

                    break
            else:
                print("‚ùå Nenhuma dupla com vara com isca encontrada!")
                return

        # PROTE√á√ÉO ANTI-BUG: Se s√≥ tem 1 vara com isca total
        if len(with_bait) == 1:
            print("‚ö†Ô∏è APENAS 1 VARA COM ISCA - Ativando prote√ß√£o anti-bug")
            self.single_rod_protection = True
            self.protected_rod_slot = with_bait[0]
        else:
            self.single_rod_protection = False

    def advance_rod_age_system(self):
        """üß† SISTEMA DE ANTIGUIDADE INTELIGENTE - s√≥ rotaciona para duplas com iscas"""
        if not hasattr(self, 'rod_age_system'):
            return False

        current_pair_name = self.rod_age_system['pair_order'][self.rod_age_system['current_pair_index']]
        self.rod_age_system['pair_usage_count'][current_pair_name] += 1

        usage_count = self.rod_age_system['pair_usage_count'][current_pair_name]
        max_usage = self.rod_age_system['max_usage_per_pair']

        # Se usou a dupla o suficiente, tentar rodar para pr√≥xima COM ISCAS
        if usage_count >= max_usage:
            print(f"\nüîÑ DUPLA {current_pair_name} USADA {usage_count} VEZES - buscando pr√≥xima com iscas...")

            # Verificar dados do rod tracking
            if not hasattr(self, 'rod_status_tracking'):
                print("‚ùå Sem dados de rod tracking - mantendo dupla atual")
                return False

            available_with_bait = self.rod_status_tracking.get('available_with_bait', [])
            pairs = {
                '1-2': [1, 2],
                '3-4': [3, 4],
                '5-6': [5, 6]
            }

            # Buscar pr√≥xima dupla com iscas dispon√≠veis (INTELIGENTE)
            found_next_pair = False
            checked_pairs = 0

            while checked_pairs < 3:
                # Testar pr√≥xima dupla na sequ√™ncia
                test_index = (self.rod_age_system['current_pair_index'] + checked_pairs + 1) % 3
                test_pair_name = self.rod_age_system['pair_order'][test_index]
                test_pair_slots = pairs[test_pair_name]

                # Verificar se essa dupla tem varas com isca
                pair_with_bait = [slot for slot in test_pair_slots if slot in available_with_bait]

                print(f"üîç Testando dupla {test_pair_name}: slots {test_pair_slots} ‚Üí com isca: {pair_with_bait}")

                if len(pair_with_bait) >= 1:  # Pelo menos 1 vara com isca na dupla
                    print(f"‚úÖ INTELIGENTE: Rotacionando para dupla {test_pair_name} (tem {len(pair_with_bait)} vara(s) com isca)")

                    # Resetar contador da dupla atual
                    self.rod_age_system['pair_usage_count'][current_pair_name] = 0

                    # Avan√ßar para a dupla encontrada
                    self.rod_age_system['current_pair_index'] = test_index

                    print(f"   ‚û°Ô∏è Nova dupla ativa: {test_pair_name}")
                    print(f"   üìä Ciclo: 1-2({self.rod_age_system['pair_usage_count']['1-2']}) ‚Üí 3-4({self.rod_age_system['pair_usage_count']['3-4']}) ‚Üí 5-6({self.rod_age_system['pair_usage_count']['5-6']})")
                    print(f"   üé£ Varas com isca na nova dupla: {pair_with_bait}")

                    # Reconfigurar sistema com nova dupla
                    self.setup_intelligent_rod_cycling()
                    found_next_pair = True
                    break
                else:
                    print(f"‚ùå Dupla {test_pair_name} sem iscas - continuando busca...")

                checked_pairs += 1

            if not found_next_pair:
                print("‚ö†Ô∏è NENHUMA DUPLA COM ISCAS ENCONTRADA - mantendo dupla atual e for√ßando recarregamento")
                # Manter dupla atual mas resetar uso para for√ßar recarregamento
                self.rod_age_system['pair_usage_count'][current_pair_name] = max_usage - 5

                # Agendar gerenciamento completo para resolver situa√ß√£o
                if hasattr(self, 'comprehensive_rod_management'):
                    self.add_priority_task(1, "üîß Gerenciamento completo - todas duplas sem iscas", self.comprehensive_rod_management)

                return False

            return True

        return False

    def intelligent_rod_switch_with_protection(self):
        """Troca inteligente com prote√ß√£o anti-bug"""
        if hasattr(self, 'single_rod_protection') and self.single_rod_protection:
            # PROTE√á√ÉO: Se s√≥ tem 1 vara com isca, fazer movimento falso
            protected_slot = getattr(self, 'protected_rod_slot', 1)

            # Encontrar slot vazio ou diferente para clicar
            other_slot = 6 if protected_slot != 6 else 5

            print(f"üõ°Ô∏è PROTE√á√ÉO ANTI-BUG: Clicando slot {other_slot} e voltando para {protected_slot}")

            # Clicar em outro slot
            pyautogui.press(str(other_slot))
            time.sleep(0.3)

            # Voltar para vara protegida
            pyautogui.press(str(protected_slot))
            time.sleep(0.3)

            return protected_slot
        else:
            # Troca normal entre varas com isca
            return self.normal_intelligent_rod_switch()

    def normal_intelligent_rod_switch(self):
        """Troca normal entre varas com isca dispon√≠veis - PRIORIDADE VARANOBAUCI"""
        if not hasattr(self, 'rod_status_tracking'):
            return 1

        with_bait = self.rod_status_tracking.get('available_with_bait', [])
        if len(with_bait) < 2:
            return with_bait[0] if with_bait else 1

        current_rod = self.get_absolute_rod_number()

        # PRIORIDADE VARANOBAUCI (rod 1) - sempre preferir se dispon√≠vel
        if 1 in with_bait and current_rod != 1:
            next_rod = 1
            print(f"üéØ PRIORIDADE VARANOBAUCI: Trocando de vara {current_rod} para rod 1")
        else:
            # Encontrar pr√≥xima vara com isca (comportamento normal)
            current_index = with_bait.index(current_rod) if current_rod in with_bait else 0
            next_index = (current_index + 1) % len(with_bait)
            next_rod = with_bait[next_index]
            print(f"üîÑ Trocando de vara {current_rod} para {next_rod}")

        pyautogui.press(str(next_rod))
        time.sleep(0.3)

        return next_rod

    # üéØ SISTEMA TEMPLATE MATCHING (SUBSTITUI√á√ÉO DO YOLO)
    def template_detect_objects(self, region=None, confidence_threshold=0.7):
        """Detectar objetos usando template matching OTIMIZADO com TemplateManager"""
        detections = []

        try:
            # üéØ USAR TEMPLATE MANAGER CENTRALIZADO
            template_manager = TemplateManager()
            
            # Garantir que templates estejam carregados
            if not template_manager.is_loaded():
                print("üîÑ Carregando templates via TemplateManager...")
                if not template_manager.load_all_templates():
                    print("‚ùå Falha ao carregar templates")
                    return detections
            
            all_templates = template_manager.get_all_templates()
            if not all_templates:
                print("‚ö†Ô∏è Nenhum template carregado no TemplateManager")
                return detections

            import mss
            import cv2
            import numpy as np

            print(f"üìã Templates carregados: {len(all_templates)} items (via cache)")

            # Criar nova inst√¢ncia MSS sem lock
            with mss.mss() as sct:
                # Definir regi√£o de captura
                if region is None:
                    region = {
                        'top': 0,
                        'left': 0,
                        'width': 1920,
                        'height': 1080
                    }

                # Capturar tela
                screenshot = sct.grab(region)
                screen = np.array(screenshot)
                del screenshot  # üßπ Liberar mem√≥ria imediatamente

                # Converter BGRA para BGR
                if len(screen.shape) == 3 and screen.shape[2] == 4:
                    screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)
                else:
                    screen_bgr = screen

                print(f"üì∏ Tela capturada: {screen_bgr.shape}")

                # Testar cada template PR√â-CARREGADO
                templates_tested = 0
                items_found = []

                for template_name, template_data in all_templates.items():
                    # üöÄ TEMPLATE J√Å EM MEM√ìRIA - SEM I/O!
                    template = template_data['image']
                    templates_tested += 1

                    # Obter nome da classe para confian√ßa (remover .png)
                    class_name = template_name.replace('.png', '')
                    template_confidence = self.template_confidence_manager.get_template_confidence(class_name)

                    # Template matching
                    result = cv2.matchTemplate(screen_bgr, template, cv2.TM_CCOEFF_NORMED)

                    # Aplicar Non-Maximum Suppression diretamente no resultado
                    # Encontrar apenas os picos locais para evitar m√∫ltiplas detec√ß√µes
                    threshold_result = result.copy()
                    threshold_result[threshold_result < template_confidence] = 0

                    # Encontrar m√°ximos locais
                    locations = np.where(result >= template_confidence)

                    # Processar cada detec√ß√£o
                    processed_locations = []
                    for pt in zip(*locations[::-1]):
                        confidence = result[pt[1], pt[0]]

                        # Converter coordenadas para absolutes
                        x1 = region['left'] + pt[0]
                        y1 = region['top'] + pt[1]
                        x2 = x1 + template.shape[1]
                        y2 = y1 + template.shape[0]

                        center_x = (x1 + x2) // 2
                        center_y = (y1 + y2) // 2

                        detection = {
                            'class': class_name,
                            'confidence': float(confidence),
                            'box': [x1, y1, x2, y2],
                            'center': [center_x, center_y],
                            'center_x': center_x,
                            'center_y': center_y,
                            'x': x1,  # Para compatibilidade com verifica√ß√£o x < 1242
                            'y': y1
                        }

                        detections.append(detection)

                        # Log de item encontrado
                        side = "invent√°rio" if x1 < 1242 else "ba√∫"
                        items_found.append(f"{class_name} no {side}")

                print(f"‚úÖ Templates testados: {templates_tested}")
                print(f"üì¶ Detec√ß√µes brutas: {len(detections)}")

                # SUPRESS√ÉO DE DETEC√á√ïES SOBREPOSTAS
                # Remover apenas detec√ß√µes que est√£o sobrepostas (mesmo item detectado m√∫ltiplas vezes)
                filtered_detections = []
                min_distance = 30  # Dist√¢ncia m√≠nima entre detec√ß√µes (30 pixels = sobreposi√ß√£o)

                for detection in detections:
                    # Verificar se esta detec√ß√£o est√° sobreposta com alguma j√° filtrada
                    is_overlapping = False

                    for filtered in filtered_detections:
                        # Calcular dist√¢ncia entre centros
                        dx = abs(detection['center_x'] - filtered['center_x'])
                        dy = abs(detection['center_y'] - filtered['center_y'])
                        distance = (dx**2 + dy**2)**0.5

                        # Se estiver MUITO pr√≥ximo (sobreposto), √© detec√ß√£o duplicada do MESMO item f√≠sico
                        # Permite itens iguais em lugares diferentes (distance >= min_distance)
                        if distance < min_distance:
                            # Manter a detec√ß√£o com maior confian√ßa
                            if detection['confidence'] > filtered['confidence']:
                                filtered_detections.remove(filtered)
                                filtered_detections.append(detection)
                            is_overlapping = True
                            break

                    # Se n√£o estiver sobreposta, adicionar √† lista filtrada
                    if not is_overlapping:
                        filtered_detections.append(detection)

                print(f"üì¶ Detec√ß√µes filtradas: {len(filtered_detections)} (removidas {len(detections) - len(filtered_detections)} duplicatas)")

                if filtered_detections:
                    # Mostrar itens √∫nicos encontrados
                    unique_items = {}
                    for det in filtered_detections:
                        side = "invent√°rio" if det['x'] < 1242 else "ba√∫"
                        key = f"{det['class']} no {side}"
                        if key not in unique_items:
                            unique_items[key] = 0
                        unique_items[key] += 1

                    print("   Itens detectados:")
                    for item, count in list(unique_items.items())[:10]:
                        if count > 1:
                            print(f"      ‚Ä¢ {item} (x{count})")
                        else:
                            print(f"      ‚Ä¢ {item}")

                return filtered_detections

        except Exception as e:
            print(f"‚ùå Erro no template matching: {e}")
            import traceback
            traceback.print_exc()
            return []

    def detect_peixe_capturado(self):
        """Detectar 'peixe capturado' usando template matching"""
        detections = self.template_detect_objects()

        for detection in detections:
            if detection['class'] == 'peixe_capturado' and detection['confidence'] > 0.8:
                print(f"üé£ PEIXE CAPTURADO detectado! Confian√ßa: {detection['confidence']:.2f}")
                return True

        return False

    def template_detect_inventory_state(self):
        """Detectar estado do invent√°rio usando template matching"""
        detections = self.template_detect_objects()

        for detection in detections:
            if detection['class'] == 'inventario_aberto' and detection['confidence'] > 0.7:
                return True

        return False

    # ‚ö° SISTEMA CENTRAL DE COORDENA√á√ÉO INTELIGENTE
    def smart_chest_detection_with_cache(self):
        """Detec√ß√£o inteligente de ba√∫ com cache para evitar verifica√ß√µes desnecess√°rias"""
        current_time = time.time()
        cache_duration = 10.0  # Cache v√°lido por 10 segundos

        # Verificar cache primeiro
        if (self.coordination_system['chest_detection_result'] is not None and
            current_time - self.coordination_system['chest_last_check'] < cache_duration):

            cached_result = self.coordination_system['chest_detection_result']
            print(f"üì¶ [CACHE] Usando resultado de detec√ß√£o de ba√∫: {cached_result}")
            return cached_result

        # Cache expirado ou n√£o existe - fazer nova detec√ß√£o
        print("üîç [FRESH] Detectando estado do ba√∫...")

        # Usar as detec√ß√µes do YOLO para ba√∫ aberto
        chest_open = self.detect_inventory_chest_division()

        # Se n√£o detectou pela divis√≥ria, tentar detectar pelo template
        if not chest_open:
            chest_open = self.detect_chest_open_template()

        # Atualizar cache
        self.coordination_system['chest_detection_result'] = chest_open
        self.coordination_system['chest_last_check'] = current_time

        print(f"üì¶ [RESULT] Ba√∫ {'ABERTO' if chest_open else 'FECHADO'} - cache atualizado")
        return chest_open

    def detect_chest_open_template(self):
        """Detectar ba√∫ aberto usando template matching"""
        try:
            import cv2
            import numpy as np
            import mss
            import os

            # Template de "barril aberto" ou similar
            chest_templates = ['barril_aberto.png', 'chest_open.png', 'bau_aberto.png']

            with mss.mss() as sct:
                # Regi√£o central da tela onde ba√∫s aparecem
                region = {
                    'top': 100,
                    'left': 400,
                    'width': 1120,
                    'height': 800
                }
                screenshot = sct.grab(region)
                screen = np.array(screenshot)
                screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)

            for template_name in chest_templates:
                template_path = f"templates/{template_name}"
                if os.path.exists(template_path):
                    template = cv2.imread(template_path)
                    if template is not None:
                        result = cv2.matchTemplate(screen_bgr, template, cv2.TM_CCOEFF_NORMED)
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                        if max_val > 0.7:
                            print(f"‚úÖ Ba√∫ detectado aberto via template: {template_name} (conf: {max_val:.2f})")
                            return True

            return False

        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o de ba√∫ por template: {e}")
            return False

    def coordinate_chest_operations(self, operation_name, operation_func):
        """Coordenar opera√ß√µes de ba√∫ para evitar comandos duplicados"""

        # Verificar se j√° h√° opera√ß√£o de ba√∫ em andamento
        if self.coordination_system['resource_locks']['chest_opening']:
            print(f"üîí [COORDENA√á√ÉO] Opera√ß√£o de ba√∫ j√° em andamento - aguardando {operation_name}")

            # Aguardar at√© 15 segundos
            for i in range(30):
                time.sleep(0.5)
                if not self.coordination_system['resource_locks']['chest_opening']:
                    break
            else:
                print(f"‚è∞ [TIMEOUT] Timeout aguardando libera√ß√£o de ba√∫ para {operation_name}")
                return False

        # Verificar se ba√∫ j√° est√° aberto
        if self.smart_chest_detection_with_cache():
            print(f"‚úÖ [OTIMIZADO] Ba√∫ j√° est√° aberto para {operation_name} - reutilizando!")
            return operation_func(chest_already_open=True)

        # Ba√∫ fechado - precisa abrir
        print(f"üîê [COORDENA√á√ÉO] Ba√∫ fechado - abrindo para {operation_name}")

        # Marcar como ocupado
        self.coordination_system['resource_locks']['chest_opening'] = True

        try:
            # Abrir ba√∫ uma √∫nica vez
            if self.open_chest_safely():
                # Aguardar ba√∫ abrir
                time.sleep(2.0)

                # Invalidar cache para for√ßar nova detec√ß√£o
                self.coordination_system['chest_detection_result'] = None

                # Verificar se realmente abriu
                if self.smart_chest_detection_with_cache():
                    print(f"‚úÖ [SUCESSO] Ba√∫ aberto com sucesso para {operation_name}")
                    result = operation_func(chest_already_open=True)
                else:
                    print(f"‚ùå [FALHA] Falha ao abrir ba√∫ para {operation_name}")
                    result = False
            else:
                print(f"‚ùå [FALHA] open_chest_safely() falhou para {operation_name}")
                result = False

            return result

        finally:
            # Sempre liberar lock
            self.coordination_system['resource_locks']['chest_opening'] = False

    def prevent_duplicate_priority_tasks(self, task_name):
        """Evitar tarefas priorit√°rias duplicadas"""
        task_hash = hash(task_name)

        if task_hash in self.coordination_system['scheduled_tasks']:
            print(f"‚ö†Ô∏è [DUPLICATA] Tarefa '{task_name}' j√° agendada - ignorando")
            return False

        # Adicionar √† lista de agendadas
        self.coordination_system['scheduled_tasks'].add(task_hash)

        # Remover ap√≥s 30 segundos para permitir reagendamento
        def remove_after_delay():
            time.sleep(30)
            self.coordination_system['scheduled_tasks'].discard(task_hash)

        threading.Thread(target=remove_after_delay, daemon=True).start()

        print(f"‚úÖ [AGENDADO] Tarefa '{task_name}' agendada com sucesso")
        return True

    def test_templates_system(self):
        """üß™ TESTAR todos os templates encontrados"""
        print("\n" + "="*70)
        print("üß™ TESTE DE TEMPLATES - SISTEMA CORRIGIDO")
        print("="*70)

        print(f"\nüìÅ Pasta templates: templates")
        print(f"üéØ Templates mapeados: {len(self.template_classes)}")
        print(f"‚úÖ Templates funcionais: {len(self.available_templates)}")

        # Mostrar templates por categoria
        categories = {
            'CR√çTICAS': ['peixe_capturado', 'inventario_aberto', 'barril_aberto'],
            'VARAS': ['vara_com_isca', 'vara_sem_isca', 'vara_quebrada', 'vara_com_isca_alt', 'vara_sem_isca_alt'],
            'PEIXES': ['anchova', 'salmao', 'sardinha', 'truta', 'tubarao', 'perca_amarela'],
            'ISCAS': ['carne_urso', 'carne_lobo', 'isca', 'minhoca', 'carne_urso_alt'],
            'ALIMENTA√á√ÉO': ['file_frito', 'comer'],
            'BACKUP/DUPLICATAS': [k for k in self.template_classes.keys() if '_alt' in k or 'caixa_' in k]
        }

        for category, templates in categories.items():
            print(f"\nüìã {category}:")
            found = 0
            for template in templates:
                if template in self.available_templates:
                    path = self.available_templates[template]
                    filename = path.split('/')[-1] if '/' in path else path.split('\\')[-1]
                    print(f"   ‚úÖ {template}: {filename}")
                    found += 1
                else:
                    expected_file = self.template_classes.get(template, 'N/A')
                    print(f"   ‚ùå {template}: {expected_file} (n√£o encontrado)")
            print(f"   üìä {found}/{len(templates)} encontrados")

        # Detectar duplicatas autom√°ticamente
        print(f"\nüîÑ AN√ÅLISE DE DUPLICATAS:")
        main_templates = [k for k in self.available_templates.keys() if '_alt' not in k and 'caixa_' not in k]
        alt_templates = [k for k in self.available_templates.keys() if '_alt' in k]

        for alt in alt_templates:
            main_name = alt.replace('_alt', '')
            if main_name in main_templates:
                main_file = self.available_templates[main_name].split('\\')[-1]
                alt_file = self.available_templates[alt].split('\\')[-1]
                print(f"   üîÑ DUPLICATA: {main_name} ({main_file}) + {alt} ({alt_file})")

        print(f"\n‚úÖ SISTEMA DE TEMPLATES VERIFICADO!")
        print("="*70)

    def test_coordination_system(self):
        """üß™ FUN√á√ÉO DE TESTE - Sistema de Coordena√ß√£o Central"""
        print("\n" + "="*70)
        print("üß™ TESTANDO SISTEMA DE COORDENA√á√ÉO CENTRAL")
        print("="*70)

        # 1. Testar detec√ß√£o de ba√∫ com cache
        print("\n1Ô∏è‚É£ Testando detec√ß√£o inteligente de ba√∫:")
        result1 = self.smart_chest_detection_with_cache()
        print(f"   Resultado 1: {result1}")

        # 2. Testar cache (deve usar resultado anterior)
        print("\n2Ô∏è‚É£ Testando cache (deve reutilizar):")
        result2 = self.smart_chest_detection_with_cache()
        print(f"   Resultado 2: {result2}")

        # 3. Testar preven√ß√£o de duplicatas
        print("\n3Ô∏è‚É£ Testando preven√ß√£o de duplicatas:")
        task1 = self.add_priority_task(5, "Teste Duplicata", lambda: print("Executando teste"))
        task2 = self.add_priority_task(5, "Teste Duplicata", lambda: print("Executando teste"))
        print(f"   Primeira tarefa: {task1}")
        print(f"   Segunda tarefa (duplicata): {task2}")

        # 4. Testar sistema de antiguidade inteligente
        print("\n4Ô∏è‚É£ Testando sistema de antiguidade:")
        if hasattr(self, 'rod_age_system'):
            current_pair = self.rod_age_system['pair_order'][self.rod_age_system['current_pair_index']]
            usage = self.rod_age_system['pair_usage_count'][current_pair]
            print(f"   Dupla atual: {current_pair}")
            print(f"   Uso atual: {usage}/{self.rod_age_system['max_usage_per_pair']}")

            # Simular avan√ßo
            if hasattr(self, 'rod_status_tracking'):
                available = self.rod_status_tracking.get('available_with_bait', [])
                print(f"   Varas com isca: {available}")

        # 5. Mostrar status dos locks
        print("\n5Ô∏è‚É£ Status dos Resource Locks:")
        for lock_name, status in self.coordination_system['resource_locks'].items():
            status_icon = "üîí" if status else "üîì"
            print(f"   {status_icon} {lock_name}: {'OCUPADO' if status else 'LIVRE'}")

        # 6. Testar fila inteligente
        print("\n6Ô∏è‚É£ Testando Fila Inteligente:")
        print("   üìù Adicionando opera√ß√µes de teste...")
        self.add_to_smart_queue('chest', 'Teste Alimenta√ß√£o', lambda: print('‚úÖ Executando alimenta√ß√£o'), priority=4)
        self.add_to_smart_queue('chest', 'Teste Limpeza', lambda: print('‚úÖ Executando limpeza'), priority=6)

        # 7. Status das filas
        print("\n7Ô∏è‚É£ Status das Filas:")
        chest_ops = len(self.coordination_system['smart_queue']['chest_operations'])
        inv_ops = len(self.coordination_system['smart_queue']['inventory_operations'])
        combined_ops = len(self.coordination_system['smart_queue']['combined_operations'])
        executing = self.coordination_system['smart_queue']['executing']

        print(f"   üè™ Opera√ß√µes de ba√∫: {chest_ops}")
        print(f"   üì¶ Opera√ß√µes de invent√°rio: {inv_ops}")
        print(f"   üî• Opera√ß√µes combinadas: {combined_ops}")
        print(f"   ‚ö° Executando: {'SIM' if executing else 'N√ÉO'}")

        print("\n‚úÖ TESTE DO SISTEMA DE COORDENA√á√ÉO CONCLU√çDO!")
        print("="*70)

    # üß† SISTEMA DE FILA INTELIGENTE PARA OPERA√á√ïES SIMULT√ÇNEAS
    def add_to_smart_queue(self, operation_type, operation_name, operation_func, priority=5, *args, **kwargs):
        """Adicionar opera√ß√£o √† fila inteligente baseada no tipo de recurso necess√°rio"""

        operation = {
            'name': operation_name,
            'function': operation_func,
            'priority': priority,
            'args': args,
            'kwargs': kwargs,
            'timestamp': time.time(),
            'type': operation_type
        }

        print(f"üìù [FILA] Adicionando '{operation_name}' √† fila {operation_type}")

        # Adicionar √† fila apropriada
        if operation_type == 'chest':
            self.coordination_system['smart_queue']['chest_operations'].append(operation)
        elif operation_type == 'inventory':
            self.coordination_system['smart_queue']['inventory_operations'].append(operation)
        elif operation_type == 'combined':
            self.coordination_system['smart_queue']['combined_operations'].append(operation)

        # Ordenar por prioridade
        self._sort_queue(operation_type)

        # Tentar executar fila se n√£o estiver executando
        if not self.coordination_system['smart_queue']['executing']:
            self.execute_smart_queue()

    def _sort_queue(self, queue_type):
        """Ordenar fila por prioridade (menor n√∫mero = maior prioridade)"""
        if queue_type == 'chest':
            self.coordination_system['smart_queue']['chest_operations'].sort(
                key=lambda x: (x['priority'], x['timestamp'])
            )
        elif queue_type == 'inventory':
            self.coordination_system['smart_queue']['inventory_operations'].sort(
                key=lambda x: (x['priority'], x['timestamp'])
            )
        elif queue_type == 'combined':
            self.coordination_system['smart_queue']['combined_operations'].sort(
                key=lambda x: (x['priority'], x['timestamp'])
            )

    def execute_smart_queue(self):
        """üéØ EXECUTAR FILA INTELIGENTE - combina opera√ß√µes quando poss√≠vel"""

        if self.coordination_system['smart_queue']['executing']:
            print("‚ö†Ô∏è [FILA] Execu√ß√£o j√° em andamento - ignorando")
            return

        self.coordination_system['smart_queue']['executing'] = True

        try:
            print("\n" + "="*60)
            print("üß† EXECUTANDO FILA INTELIGENTE DE OPERA√á√ïES")
            print("="*60)

            # 1. VERIFICAR OPERA√á√ïES COMBINADAS (maior prioridade)
            if self.coordination_system['smart_queue']['combined_operations']:
                self._execute_combined_operations()

            # 2. VERIFICAR OPERA√á√ïES DE BA√ö (podem ser combinadas)
            chest_ops = self.coordination_system['smart_queue']['chest_operations']
            if len(chest_ops) > 1:
                print(f"üè™ [OTIMIZA√á√ÉO] {len(chest_ops)} opera√ß√µes de ba√∫ detectadas - combinando!")
                self._execute_multiple_chest_operations(chest_ops)
            elif len(chest_ops) == 1:
                print("üè™ [SIMPLES] Executando opera√ß√£o √∫nica de ba√∫")
                self._execute_single_chest_operation(chest_ops[0])
                chest_ops.clear()

            # 3. VERIFICAR OPERA√á√ïES DE INVENT√ÅRIO
            inventory_ops = self.coordination_system['smart_queue']['inventory_operations']
            if inventory_ops:
                print(f"üì¶ [INVENT√ÅRIO] {len(inventory_ops)} opera√ß√µes de invent√°rio")
                self._execute_inventory_operations(inventory_ops)

            print("‚úÖ FILA INTELIGENTE EXECUTADA COM SUCESSO!")

        except Exception as e:
            print(f"‚ùå Erro na execu√ß√£o da fila inteligente: {e}")
        finally:
            self.coordination_system['smart_queue']['executing'] = False

    def _execute_combined_operations(self):
        """Executar opera√ß√µes que podem ser combinadas (alimenta√ß√£o + limpeza)"""
        combined_ops = self.coordination_system['smart_queue']['combined_operations']

        if not combined_ops:
            return

        print(f"üî• [COMBINADO] Executando {len(combined_ops)} opera√ß√µes combinadas")

        # Agrupar por tipo de opera√ß√£o
        feeding_ops = [op for op in combined_ops if 'alimenta' in op['name'].lower()]
        cleaning_ops = [op for op in combined_ops if 'limpeza' in op['name'].lower()]

        if feeding_ops and cleaning_ops:
            print("üçñüßπ [SUPER OTIMIZADO] Alimenta√ß√£o + Limpeza juntas!")
            self.execute_feeding_and_cleaning_combined()
        else:
            # Executar individualmente se n√£o podem ser combinadas
            for op in combined_ops:
                print(f"‚ñ∂Ô∏è Executando: {op['name']}")
                op['function'](*op['args'], **op['kwargs'])

        combined_ops.clear()

    def _execute_multiple_chest_operations(self, chest_ops):
        """üè™ OTIMIZA√á√ÉO M√ÅXIMA: M√∫ltiplas opera√ß√µes com ba√∫ aberto uma s√≥ vez"""

        print(f"üî• [MEGA OTIMIZADO] {len(chest_ops)} opera√ß√µes usando ba√∫ aberto APENAS UMA VEZ!")

        # Abrir ba√∫ apenas uma vez
        if not self.smart_chest_detection_with_cache():
            print("üîê [COORDENADO] Abrindo ba√∫ para m√∫ltiplas opera√ß√µes...")
            if not self.open_chest_safely():
                print("‚ùå Falha ao abrir ba√∫ - abortando opera√ß√µes")
                return
            time.sleep(2.0)

        # Executar todas as opera√ß√µes com ba√∫ j√° aberto
        for i, op in enumerate(chest_ops, 1):
            print(f"‚ñ∂Ô∏è [{i}/{len(chest_ops)}] Executando: {op['name']}")

            try:
                # Adicionar par√¢metro indicando que ba√∫ j√° est√° aberto
                if 'chest_already_open' in op['kwargs']:
                    op['kwargs']['chest_already_open'] = True
                else:
                    # Se fun√ß√£o n√£o suporta o par√¢metro, executar normalmente
                    pass

                op['function'](*op['args'], **op['kwargs'])
                print(f"‚úÖ [{i}/{len(chest_ops)}] Conclu√≠do: {op['name']}")

            except Exception as e:
                print(f"‚ùå [{i}/{len(chest_ops)}] Erro em {op['name']}: {e}")

        chest_ops.clear()
        print("üè™ [OTIMIZADO] Todas as opera√ß√µes de ba√∫ conclu√≠das com uma √∫nica abertura!")

    def _execute_single_chest_operation(self, operation):
        """Executar opera√ß√£o √∫nica de ba√∫"""
        print(f"‚ñ∂Ô∏è [√öNICO] Executando opera√ß√£o de ba√∫: {operation['name']}")
        operation['function'](*operation['args'], **operation['kwargs'])

    def _execute_inventory_operations(self, inventory_ops):
        """Executar opera√ß√µes que precisam apenas do invent√°rio"""
        for op in inventory_ops:
            print(f"‚ñ∂Ô∏è [INVENT√ÅRIO] Executando: {op['name']}")
            op['function'](*op['args'], **op['kwargs'])

        inventory_ops.clear()

    def find_new_rod_in_inventory(self):
        """Encontrar nova vara no invent√°rio usando YOLO"""
        try:
            detections = self.detect_objects()
            for detection in detections:
                class_name = self.yolo_model.names.get(detection['class'], 'unknown')
                if class_name == 'vara':
                    # Verificar se est√° na √°rea do invent√°rio (esquerda da tela)
                    if detection['x'] < 1242:  # Linha divis√≥ria do invent√°rio
                        print(f"   üéØ Nova vara encontrada em ({detection['x']:.0f}, {detection['y']:.0f})")
                        return (detection['x'], detection['y'])

            print("   ‚ùå Nenhuma vara nova encontrada no invent√°rio")
            return None

        except Exception as e:
            print(f"   ‚ùå Erro ao procurar nova vara: {e}")
            return None

    def analyze_rod_positions(self):
        """Analisar todas as posi√ß√µes das varas com detalhes completos"""
        if not hasattr(self, 'current_detections') or not self.current_detections:
            print("‚ùå Nenhuma detec√ß√£o dispon√≠vel")
            return

        all_rod_positions = []
        for detection in self.current_detections:
            class_name = self.yolo_model.names.get(detection['class'], 'unknown')
            if class_name in ['vara', 'vara com isca']:
                all_rod_positions.append({
                    'class': class_name,
                    'x': detection['x'],
                    'y': detection['y'],
                    'confidence': detection.get('confidence', 0)
                })

        if all_rod_positions:
            print(f"\nüîç AN√ÅLISE COMPLETA - {len(all_rod_positions)} varas detectadas:")

            # An√°lise por Y (vertical)
            print("üìä AN√ÅLISE VERTICAL (Y):")
            all_rod_positions.sort(key=lambda r: r['y'])
            y_values = [r['y'] for r in all_rod_positions]
            min_y, max_y = min(y_values), max(y_values)

            for i, pos in enumerate(all_rod_positions):
                status = "‚úÖ V√ÅLIDA" if pos['y'] >= 850 else "‚ùå INV√ÅLIDA"
                print(f"   {i+1}. {pos['class']} - X:{pos['x']:.0f}, Y:{pos['y']:.0f} - {status}")

            print(f"üìà Y M√≠n={min_y:.0f}, M√°x={max_y:.0f}, Diferen√ßa={max_y-min_y:.0f}")

            # An√°lise por X (horizontal)
            print("\nüìä AN√ÅLISE HORIZONTAL (X - ordem dos slots):")
            # Filtrar apenas varas v√°lidas (Y >= 850)
            valid_rods = [r for r in all_rod_positions if r['y'] >= 850]
            valid_rods.sort(key=lambda r: r['x'])

            if valid_rods:
                x_values = [r['x'] for r in valid_rods]
                min_x, max_x = min(x_values), max(x_values)
                spacing = (max_x - min_x) / max(1, len(valid_rods)-1) if len(valid_rods) > 1 else 0

                print(f"üéØ {len(valid_rods)} varas v√°lidas ordenadas por X:")
                for i, pos in enumerate(valid_rods):
                    slot = i + 1
                    print(f"   SLOT {slot}: {pos['class']} - X:{pos['x']:.0f}, Y:{pos['y']:.0f}")

                print(f"üìè X M√≠n={min_x:.0f}, M√°x={max_x:.0f}, Espa√ßamento m√©dio={spacing:.0f}")

                # Verificar se h√° clusters/grupos
                if len(valid_rods) > 1:
                    gaps = []
                    for i in range(1, len(valid_rods)):
                        gap = valid_rods[i]['x'] - valid_rods[i-1]['x']
                        gaps.append(gap)

                    avg_gap = sum(gaps) / len(gaps)
                    print(f"üîç Espa√ßamento entre varas: M√©dio={avg_gap:.0f}")

                    # Detectar poss√≠veis clusters
                    large_gaps = [gap for gap in gaps if gap > avg_gap * 1.5]
                    if large_gaps:
                        print(f"‚ö†Ô∏è Detectados {len(large_gaps)} espa√ßamentos grandes (poss√≠veis separa√ß√µes de grupos)")
            else:
                print("‚ùå Nenhuma vara v√°lida encontrada (todas Y < 850)")
                print("üí° Considere diminuir o filtro Y para 800 ou menos")
        else:
            print("‚ùå Nenhuma vara detectada pelo YOLO")

    def test_rod_mapping(self):
        """Fun√ß√£o de teste para verificar mapeamento de slots"""
        print("\n" + "="*60)
        print("üß™ TESTE DE MAPEAMENTO DE SLOTS DE VARA")
        print("="*60)

        if not hasattr(self, 'current_detections') or not self.current_detections:
            print("‚ùå Nenhuma detec√ß√£o dispon√≠vel")
            print("üí° Execute o bot ou abra o visualizador YOLO primeiro")
            return

        self.analyze_rod_positions()

        print("\nüéØ APLICANDO FILTROS:")
        rod_slots = self.map_rod_slots(self.current_detections)

        if rod_slots:
            print(f"\n‚úÖ MAPEAMENTO FINAL - {len(rod_slots)} slots mapeados:")
            for slot in range(1, 7):
                if slot in rod_slots:
                    info = rod_slots[slot]
                    status = "üé£ COM ISCA" if info['has_bait'] else "üéØ VAZIA"
                    print(f"   SLOT {slot}: {status} - X:{info['position'][0]:.0f}, Y:{info['position'][1]:.0f}")
                else:
                    print(f"   SLOT {slot}: ‚ùå N√ÉO DETECTADO")
        else:
            print("‚ùå Nenhum slot mapeado!")

        print("="*60 + "\n")

    def calibrate_rod_slots(self):
        """Fun√ß√£o para calibrar as posi√ß√µes dos slots - USE COM VARAS NOS SLOTS!"""
        print("\nüîß CALIBRA√á√ÉO DE SLOTS - DETECTANDO VARAS...")
        print("‚ö†Ô∏è IMPORTANTE: Coloque uma vara em cada slot que voc√™ usa!")

        detections = self.detect_objects()
        if not detections:
            print("‚ùå Nenhuma detec√ß√£o YOLO!")
            return

        rod_positions = []
        for detection in detections:
            class_name = self.yolo_model.names.get(detection['class'], 'unknown')
            if class_name in ['vara', 'vara com isca']:
                rod_positions.append({
                    'x': detection['x'],
                    'y': detection['y'],
                    'class': class_name
                })

        if not rod_positions:
            print("‚ùå Nenhuma vara detectada!")
            return

        # Ordenar por X (horizontal)
        rod_positions.sort(key=lambda r: r['x'])

        print(f"\n‚úÖ {len(rod_positions)} VARAS DETECTADAS:")
        print("=" * 50)

        for i, rod in enumerate(rod_positions, 1):
            print(f"SLOT {i}: X={rod['x']:.0f}, Y={rod['y']:.0f} ({rod['class']})")

        print("\nüìù COPIE ESTAS COORDENADAS PARA O C√ìDIGO:")
        print("SLOT_POSITIONS = {")
        for i, rod in enumerate(rod_positions, 1):
            print(f"    {i}: ({rod['x']:.0f}, {rod['y']:.0f}),")
        print("}")

        return rod_positions

    def get_current_rod_status(self):
        """üéØ SISTEMA INTELIGENTE: Obter status das varas usando tracking avan√ßado"""
        print("\nüîç OBTENDO STATUS ATUAL DAS VARAS COM TRACKING...")

        # Usar sistema de detec√ß√£o com tracking
        try:
            # For√ßar nova detec√ß√£o
            detections = self.detect_objects()

            # Procurar por varas de pesca
            rod_classes = ['vara de pesca', 'vara de pesca profissional', 'handmade fishing rod',
                          'vara', 'vara com isca', 'fishing rod']

            # üéØ USAR SISTEMA DE TRACKING AVAN√áADO
            rod_tracking_data = self.process_rod_detections_with_tracking(detections, rod_classes)

            # Converter para formato legado para compatibilidade
            rod_slots = {}

            for slot, rod_state in rod_tracking_data['rod_states'].items():
                rod_slots[slot] = {
                    'position': rod_state['position'],
                    'has_bait': rod_state['has_bait'],
                    'class_name': rod_state['class'],
                    'confidence': rod_state['confidence'],
                    'last_updated': rod_state['timestamp']
                }

            # üìä RELAT√ìRIO DETALHADO COM TRACKING
            if rod_slots:
                print(f"üé£ TRACKING DE VARAS - {len(rod_slots)} varas mapeadas:")
                print(f"   ‚Ä¢ Varas com isca: {len(rod_tracking_data['baited_slots'])}")
                print(f"   ‚Ä¢ Varas vazias: {len(rod_tracking_data['empty_slots'])}")

                for slot, info in rod_slots.items():
                    status = "üü¢ COM ISCA" if info['has_bait'] else "üî¥ VAZIA"
                    age = time.time() - info['last_updated']
                    print(f"   Slot {slot}: {status} - Conf: {info['confidence']:.2f} - Idade: {age:.1f}s")

                # üö® AVISO se muitas varas vazias
                empty_count = len(rod_tracking_data['empty_slots'])
                total_count = len(rod_slots)
                if empty_count > total_count * 0.5:  # Mais de 50% vazias
                    print(f"‚ö†Ô∏è [AVISO] {empty_count}/{total_count} varas est√£o vazias! Considere recarregar.")
            else:
                print("‚ùå Nenhuma vara detectada no invent√°rio!")

            return rod_slots

        except Exception as e:
            print(f"‚ùå Erro ao obter status das varas: {e}")
            return {}

    def reload_rod(self):
        """Recarregar vara com iscas - VERS√ÉO INTELIGENTE"""
        print("üîß Iniciando recarga inteligente de vara...")

        # Usar o novo sistema inteligente
        current_rod = self.get_absolute_rod_number()

        # Chamar a nova fun√ß√£o inteligente
        success = self.smart_reload_rod(current_rod)

        if success:
            print(f"‚úÖ Vara {current_rod} recarregada com sucesso!")
            # Resetar contadores de timeout para a vara recarregada
            if self.rod_system['current_rod'] == 1:
                self.rod_system['rod1_timeouts'] = 0
            else:
                self.rod_system['rod2_timeouts'] = 0
        else:
            print(f"‚ùå Falha ao recarregar vara {current_rod}")
            # Tentar buscar mais iscas no ba√∫ se falhou
            print("üîç Tentando buscar iscas no ba√∫...")
            self.get_baits_from_chest()

        return success

    def reload_rod_OLD(self):
        """Recarregar vara com iscas - VERS√ÉO ANTIGA"""
        print("üîß Iniciando recarga de vara...")

        try:
            # TAB para abrir invent√°rio
            focus_game_window()  # Garantir foco antes de pressionar TAB
            pyautogui.press('tab')
            time.sleep(0.8)

            # CORRE√á√ÉO: Verificar se REALMENTE precisa recarregar
            print("   üîç Analisando invent√°rio...")
            detections = self.detect_objects()
            vara_vazia = None
            iscas_disponiveis = []
            varas_com_isca = []

            for detection in detections:
                x_pos = detection['center'][0]
                if x_pos < 1242:  # S√≥ itens no invent√°rio
                    if detection['class'] == 'vara':  # Vara vazia (SEM isca)
                        vara_vazia = detection
                        print(f"   üé£ Vara VAZIA detectada em {detection['center']}")
                    elif detection['class'] == 'vara com isca':  # Vara com isca
                        varas_com_isca.append(detection)
                        print(f"   ‚úÖ Vara COM ISCA detectada em {detection['center']}")
                    elif detection['class'] in ['carne de urso', 'carne de lobo', 'truta', 'smalltrout']:
                        iscas_disponiveis.append(detection)
                        print(f"   ü•© Isca {detection['class']} dispon√≠vel")

            print(f"   üìä Resumo: {len(varas_com_isca)} vara(s) com isca, {0 if not vara_vazia else 1} vara vazia, {len(iscas_disponiveis)} isca(s)")

            if vara_vazia and iscas_disponiveis:
                # Prioridade: carne de urso > carne de lobo > truta > smalltrout
                isca_escolhida = None
                print("   üîç Selecionando melhor isca...")

                # 1¬™ prioridade: carne de urso
                for isca in iscas_disponiveis:
                    if isca['class'] == 'carne de urso':
                        isca_escolhida = isca
                        print("   ‚úÖ Escolhida: carne de urso (prioridade 1)")
                        break

                # 2¬™ prioridade: carne de lobo
                if not isca_escolhida:
                    for isca in iscas_disponiveis:
                        if isca['class'] == 'carne de lobo':
                            isca_escolhida = isca
                            print("   ‚úÖ Escolhida: carne de lobo (prioridade 2)")
                            break

                # 3¬™ prioridade: truta
                if not isca_escolhida:
                    for isca in iscas_disponiveis:
                        if isca['class'] == 'truta':
                            isca_escolhida = isca
                            print("   ‚úÖ Escolhida: truta (prioridade 3)")
                            break

                # 4¬™ prioridade: smalltrout
                if not isca_escolhida:
                    for isca in iscas_disponiveis:
                        if isca['class'] == 'smalltrout':
                            isca_escolhida = isca
                            print("   ‚úÖ Escolhida: smalltrout (prioridade 4)")
                            break

                if isca_escolhida:
                    print(f"\n   üîß INICIANDO RECARGA: {isca_escolhida['class']} ‚Üí vara vazia")

                    # PASSO 1: Clique ESQUERDO na vara vazia (selecionar)
                    print(f"   [1/2] Clique ESQUERDO na vara vazia em {vara_vazia['center']}")
                    pyautogui.click(vara_vazia['center'])
                    time.sleep(0.3)

                    # PASSO 2: Clique DIREITO na isca (aplicar)
                    print(f"   [2/2] Clique DIREITO na {isca_escolhida['class']} em {isca_escolhida['center']}")
                    pyautogui.click(isca_escolhida['center'], button='right')
                    time.sleep(0.3)

                    print(f"   ‚úÖ Vara recarregada com {isca_escolhida['class']}!")

                    # Reset contador da vara atual
                    current_rod = self.rod_system['current_rod']
                    if current_rod == 1:
                        self.rod_system['rod1_usage'] = 0
                    else:
                        self.rod_system['rod2_usage'] = 0
                else:
                    print("   ‚ö†Ô∏è Isca n√£o encontrada nas prioridades")
            else:
                print("   ‚ÑπÔ∏è Recarga n√£o necess√°ria:")
                if not vara_vazia:
                    print("   ‚Ä¢ Nenhuma vara vazia detectada")
                if not iscas_disponiveis:
                    print("   ‚Ä¢ Nenhuma isca dispon√≠vel (carne de urso/lobo/truta/smalltrout)")

            # TAB para fechar invent√°rio
            print("   üö™ Fechando invent√°rio...")
            self.close_inventory_with_delay("Auto opera√ß√£o")

        except Exception as e:
            print(f"‚ùå Erro na recarga: {e}")
            # Garantir que invent√°rio seja fechado em caso de erro
            try:
                pyautogui.press('tab')
            except:
                pass

    def get_baits_from_chest(self):
        """Pegar iscas e varas com isca do ba√∫ - Sistema Completo"""
        print("üì¶ Pegando iscas/varas do ba√∫...")

        try:
            # Abrir ba√∫
            self.open_chest()
            time.sleep(1)

            # Detectar objetos e separar por localiza√ß√£o (linha 1242,763)
            detections = self.detect_objects()
            items_no_bau = []

            for detection in detections:
                if detection['class'] in ['carne de urso', 'carne de lobo', 'truta', 'smalltrout', 'vara com isca']:
                    x_pos = detection['center'][0]
                    # Direita da linha = ba√∫ (> 1242)
                    if x_pos > 1242:
                        items_no_bau.append(detection)

            if items_no_bau:
                # Prioridade: vara com isca > carne de urso > carne de lobo > truta > smalltrout
                items_no_bau.sort(key=lambda x: {
                    'vara com isca': 0,
                    'carne de urso': 1,
                    'carne de lobo': 2,
                    'truta': 3,
                    'smalltrout': 4
                }.get(x['class'], 5))

                print(f"üéØ Encontrados {len(items_no_bau)} itens no ba√∫:")
                for item in items_no_bau:
                    print(f"   ‚Ä¢ {item['class']} em {item['center']}")
                    # Clicar com bot√£o direito para mover do ba√∫ ‚Üí invent√°rio
                    pyautogui.click(item['center'], button='right')
                    time.sleep(0.3)
                    print(f"   ‚úÖ {item['class']} movido para invent√°rio")
            else:
                print("‚ö†Ô∏è Nenhuma isca/vara com isca encontrada no ba√∫!")

            # Fechar ba√∫
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # Se pegou iscas, tentar recarregar varas agora
            if any(item['class'] in ['carne de urso', 'carne de lobo', 'truta', 'smalltrout'] for item in items_no_bau):
                print("üîß Tentando recarregar varas com as novas iscas...")
                time.sleep(0.5)
                pyautogui.press('tab')  # Abrir invent√°rio
                time.sleep(0.5)
                self.reload_rod()  # Tentar recarga

        except Exception as e:
            print(f"‚ùå Erro ao pegar iscas: {e}")

    def need_store_fish(self):
        """Verificar se precisa guardar peixes no ba√∫ - USA CONFIGURA√á√ÉO DA UI"""
        # Verificar se est√° habilitado
        # Auto_store removido - usando auto_clean 
        if not self.auto_clean.get('enabled', True):
            return False

        # CORRE√á√ÉO: Usar auto_clean interval para consist√™ncia
        loot_interval = self.auto_clean.get('interval', 10)
        fish_count = self.auto_clean.get('fish_count_since_last', 0)

        print(f"üêü [DEBUG] Armazenamento: {fish_count}/{loot_interval} peixes (usando auto_clean interval)")

        if fish_count >= loot_interval:
            print(f"üì¶ Hora de guardar peixes! ({fish_count} peixes, limite auto_clean: {loot_interval})")
            return True

        # N√ÉO verificar invent√°rio nos primeiros ciclos
        if self.ciclos_completados < 5:
            return False

        # Verificar tamb√©m se invent√°rio est√° cheio
        return self.safe_check_inventory_contents("fish")

    def store_fish_in_chest(self):
        """Guardar peixes no ba√∫ automaticamente"""
        print("\n" + "-"*50)
        print("üêü GUARDANDO PEIXES NO BA√ö")
        print("-"*50)

        # Resetar contador ap√≥s guardar
        # Auto_store removido - reset feito no auto_clean
        # Reset j√° √© feito automaticamente ap√≥s limpeza

        try:
            # ETAPA 1: Abrir ba√∫
            print("\n[1/4] Abrindo ba√∫...")
            print("   M√©todo: open_chest()")
            print(f"   Config: lado={self.config.get('chest_side', 'left')}, dist={self.config.get('chest_distance', 1200)}")

            chest_opened = self.open_chest()

            if chest_opened == False:
                print("   ‚ùå FALHA ao abrir ba√∫!")
                print("   Dica: Use F11 para testar macro do ba√∫")
                return False

            print("   ‚úì Ba√∫ aberto (aguardando 1s)")
            time.sleep(1)

            # ETAPA 2: Detectar objetos
            print("\n[2/4] Detectando objetos na tela...")
            detections = self.detect_objects()

            if not detections:
                print("   ‚ö†Ô∏è Nenhuma detec√ß√£o YOLO")
                pyautogui.press('tab')
                return False

            print(f"   ‚úì {len(detections)} objetos detectados")

            # ETAPA 3: Filtrar peixes
            print("\n[3/4] Filtrando peixes no invent√°rio...")
            fish_classes = ['anchova', 'aranque', 'salmao', 'sardinha', 'truta', 'smalltrout', 'tubarao', 'parca', 'file de peixe',
                           'scrap', 'sinalizador', 'cartao_azul', 'flare', 'bluecard',
                           'bullet', 'bala', 'municao', 'bone', 'bonefrag', 'osso', 'fat', 'gordura']
            peixes_no_inventario = []

            for detection in detections:
                if detection['class'] in fish_classes:
                    x_pos = detection['center'][0]
                    # Esquerda da linha = invent√°rio (< 1242)
                    if x_pos < 1242:
                        peixes_no_inventario.append(detection)
                        print(f"   ‚Ä¢ {detection['class']} em x={x_pos}")

            # ETAPA 4: Transferir
            if peixes_no_inventario:
                print(f"\n[4/4] Transferindo {len(peixes_no_inventario)} peixes:")
                for i, peixe in enumerate(peixes_no_inventario, 1):
                    print(f"   [{i}/{len(peixes_no_inventario)}] Clicando em {peixe['center']}...")
                    pyautogui.click(peixe['center'], button='right')
                    time.sleep(0.3)
            else:
                print("\n[4/4] ‚ö†Ô∏è Nenhum peixe para transferir")

            # Fechar ba√∫ E invent√°rio (apenas 1 TAB fecha ambos)
            print("\nFechando ba√∫ e invent√°rio...")
            print("   Pressionando TAB (fecha ambos simultaneamente)")
            self.close_inventory_with_delay("Auto opera√ß√£o")
            print("   ‚úì Ba√∫ e invent√°rio fechados")

            self.game_state['chest_open'] = False
            self.game_state['inventory_open'] = False

            print("-"*50)
            print(f"‚úÖ Opera√ß√£o conclu√≠da: {len(peixes_no_inventario)} peixes guardados")
            print("-"*50 + "\n")
            return True

        except Exception as e:
            print(f"\n‚ùå ERRO ao guardar peixes: {e}")
            print("   Tentando fechar ba√∫...")
            try:
                pyautogui.press('tab')
            except:
                pass
            return False

    def need_auto_clean(self):
        """Verificar se precisa fazer limpeza autom√°tica"""
        if not self.auto_clean['enabled'] or self.auto_clean['in_progress']:
            return False

        # Verificar se o bot est√° rodando (mas permitir limpeza mesmo se invent√°rio foi aberto manualmente)
        if not self.running:
            return False

        # Verificar se atingiu o intervalo de pescas REAIS
        if self.auto_clean['fish_count_since_last'] >= self.auto_clean['interval']:
            current = self.auto_clean['fish_count_since_last']
            interval = self.auto_clean['interval']
            print(f"üßπ [LIMPEZA] Trigger ativado: {current}/{interval} pescas reais atingidas")
            
            # Limpar flag de abertura manual para permitir limpeza
            if self.game_state.get('manual_inventory_open', False):
                print("‚ö†Ô∏è [LIMPEZA] Limpando flag manual_inventory_open para permitir limpeza autom√°tica")
                self.game_state['manual_inventory_open'] = False
            
            return True

        return False

    def execute_auto_clean(self):
        """Executar limpeza autom√°tica: guardar peixes e pegar iscas COM coordena√ß√£o"""

        # üéØ USAR SISTEMA DE COORDENA√á√ÉO
        return self.request_operation(
            'auto_cleaning',
            self._protected_auto_clean,
            context="Limpeza autom√°tica de invent√°rio"
        )

    def _protected_auto_clean(self):
        """üîí Limpeza autom√°tica protegida pelo sistema de coordena√ß√£o"""
        print("üßπ [LIMPEZA] Iniciando limpeza autom√°tica PROTEGIDA...")
        print("üì¶ A√ß√µes: Parar pesca ‚Üí Abrir invent√°rio ‚Üí Guardar peixes ‚Üí Fazer manuten√ß√£o")
        
        # Marcar que limpeza autom√°tica est√° em progresso
        self.auto_clean['in_progress'] = True
        self.game_state['auto_clean_in_progress'] = True
        
        # Preservar informa√ß√£o da vara atual antes da limpeza
        current_rod = self.get_absolute_rod_number()
        print(f"üé£ [LIMPEZA] Vara atual preservada: {current_rod} (voltar√° para esta ap√≥s limpeza)")

        try:
            # PASSO 1: Garantir que pesca est√° PARADA
            print("üõë [LIMPEZA] Parando pesca temporariamente...")
            self.ensure_game_ready_for_fishing()
            
            # PASSO 2: Ir direto para transfer√™ncia (que j√° cuida de abrir ba√∫ + invent√°rio)
            print("üìã [LIMPEZA] Pulando abertura manual do invent√°rio - transfer_fish_to_chest_improved() j√° cuida disso")
            
            # Marcar como limpeza autom√°tica para n√£o contar detec√ß√µes
            self.game_state['manual_inventory_open'] = False
            
            # PASSO 3: Usar fun√ß√£o de transfer√™ncia melhorada
            print("üßπ [LIMPEZA] Iniciando transfer√™ncia de peixes...")
            fish_transferred = self.transfer_fish_to_chest_improved()

            if fish_transferred == 0:
                print("‚ö†Ô∏è Nenhum peixe foi transferido - invent√°rio pode estar vazio")
            else:
                print(f"‚úÖ Limpeza bem-sucedida: {fish_transferred} peixes transferidos")

            # Estados j√° gerenciados pela fun√ß√£o transfer_fish_to_chest()
            self.game_state['chest_open'] = False
            self.game_state['inventory_open'] = False

            # Resetar contadores
            self.auto_clean['fish_count_since_last'] = 0
            self.auto_clean['real_fish_caught'] = 0  # Resetar contador real tamb√©m
            self.auto_clean['last_clean_time'] = time.time()
            print(f"üîÑ [LIMPEZA] Contadores resetados: fish_count=0, real_fish=0")

            print("‚úÖ [LIMPEZA] Limpeza autom√°tica de invent√°rio conclu√≠da!")
            print(f"üé£ [LIMPEZA] Retornando √† pescaria com vara {current_rod} (posi√ß√£o preservada)")
            
            # üé£ RETORNAR √Ä PESCA: Reativar ciclo de pescaria
            print("üé£ [RETORNO] Retomando ciclo de pesca...")
            self._resume_fishing_after_cleanup(current_rod)

        except Exception as e:
            print(f"‚ùå Erro na limpeza autom√°tica: {e}")
            # Garantir que invent√°rio seja fechado em caso de erro
            try:
                pyautogui.press('tab')
            except:
                pass
        finally:
            # CR√çTICO: Sempre limpar estado ao finalizar
            self.game_state['action_in_progress'] = False
            self.game_state['cleaning_active'] = False
            self.game_state['chest_open'] = False
            self.game_state['inventory_open'] = False
            self.game_state['peixe_detectado_fase_lenta'] = False  # Permitir voltar √† pesca
            self.auto_clean['in_progress'] = False
            print("üßπ Estado de limpeza finalizado - pesca pode continuar")

    def _resume_fishing_after_cleanup(self, target_rod):
        """üé£ Retomar pesca ap√≥s limpeza autom√°tica - SEM TROCAR VARA (ser√° feito pelo fluxo principal)"""
        try:
            print("üé£ [RETORNO] Retomando pesca ap√≥s limpeza...")
            print("üé£ [LIMPEZA] Vara atual preservada: {} (voltar√° para esta ap√≥s limpeza)".format(target_rod))
            
            # ‚úÖ CORRE√á√ÉO: N√ÉO trocar vara aqui - deixar para o fluxo principal fazer
            # A troca ser√° feita pela sequ√™ncia normal ap√≥s process_fish_catch()
            
            # PASSO 1: Reativar sistema de pesca sem trocar vara
            print("üé£ [RETORNO] Reativando estado de pesca...")
            self.game_state['fishing_active'] = True
            self.game_state['action_in_progress'] = False
            self.game_state['peixe_detectado_fase_lenta'] = False  # Permitir voltar √† pesca
            
            print("‚úÖ [RETORNO] Pesca retomada - aguardando fluxo principal para troca de vara!")
            
        except Exception as e:
            print(f"‚ùå [RETORNO] Erro ao retomar pesca: {e}")

    def transfer_fish_to_chest_improved(self):
        """Transferir peixes - VERS√ÉO MELHORADA (igual tecla 0)"""
        print("üêü [TRANSFER√äNCIA] Vers√£o melhorada - usando m√©todo da tecla 0...")

        try:
            # PASSO 1: Abrir ba√∫ usando MESMO M√âTODO DA TECLA 0
            print("üì¶ Abrindo ba√∫ usando m√©todo robusto (open_chest_direct_like_f11)...")
            if not self.game_state.get('chest_open', False):
                success = self.open_chest_direct_like_f11()
                if not success:
                    print("‚ùå Falha ao abrir ba√∫. Tentando m√©todo alternativo...")
                    success = self.open_chest()  # Fallback
                    if not success:
                        print("‚ùå Falha total ao abrir ba√∫")
                        return 0
                time.sleep(0.8)
                print("‚úÖ Ba√∫ aberto com sucesso!")
                
            # PASSO 2: Aguardar carregamento OTIMIZADO 
            print("‚è≥ Aguardando carregamento dos itens...")
            time.sleep(1.5)  # ‚úÖ OTIMIZADO: Reduzido de 3s para 1.5s
            
            # PASSO 3: Limpar cache para detec√ß√µes frescas
            print("üßπ Limpando cache de detec√ß√µes...")
            self.clear_detection_cache()
            time.sleep(0.2)  # ‚úÖ OTIMIZADO: Reduzido de 0.5s para 0.2s

            # PASSO 3: Detectar objetos na tela (agora que ba√∫ est√° aberto)
            print("üîç [DEBUG] Executando detect_objects()...")
            detections = self.detect_objects()
            print(f"üîç [DEBUG] Total de detec√ß√µes: {len(detections)}")
            
            if len(detections) == 0:
                print("‚ùå [DEBUG] PROBLEMA: Nenhuma detec√ß√£o encontrada!")
                print("üí° [DEBUG] Poss√≠vel causa: YOLO desabilitado ou template matching n√£o configurado")
                print("üîß [DEBUG] Tentando usar template matching como fallback...")
                detections = self.template_detect_objects(confidence_threshold=0.6)
                print(f"üîç [DEBUG] Template matching encontrou: {len(detections)} detec√ß√µes")
            
            # LISTA COMPLETA DE PEIXES baseada nos templates dispon√≠veis
            fish_classes = [
                # üêü PEIXES PRINCIPAIS (baseado em templates)
                'anchova',           # anchovy.png
                'salmao_1', 'salmao_2',  # salmon.png, SALMONN.png
                'sardinha',          # sardine.png
                'truta_1', 'truta_2',    # smalltrout.png, TROUTT.png
                'tubarao',           # shark.png
                'arenque',           # herring.png
                'perca_amarela',     # yellowperch.png
                'peixe_cru_1', 'peixe_cru_2',  # peixecru.png, rawfish.png
                
                # üêü ALIASES ANTIGOS (compatibilidade)
                'aranque', 'salmao', 'sardinha', 'truta', 'smalltrout', 'parca', 'file de peixe',
                
                # üêü NOMES EM INGL√äS (para compatibilidade total)
                'shark', 'salmon', 'anchovy', 'herring', 'sardine', 'trout', 'yellowperch',
                
                # üîß OUTROS ITENS VALIOSOS
                'scrap', 'sinalizador', 'cartao_azul', 'flare', 'bluecard',
                'bullet', 'bala', 'municao', 'bone', 'bonefrag', 'osso', 'fat', 'gordura', 'gut'
            ]
            fish_transferred = 0

            # PASSO 4: Transferir peixes da parte ESQUERDA (invent√°rio) para ba√∫
            print("üîç Procurando peixes na parte ESQUERDA (invent√°rio) para transferir...")
            print(f"üîç [DEBUG] Classes de peixe procuradas: {fish_classes}")
            
            found_fish = []
            for detection in detections:
                det_x = detection.get('center_x', detection.get('x', 0))
                det_y = detection.get('center_y', detection.get('y', 0))
                det_class = detection.get('class', 'unknown').lower()
                
                print(f"üîç [DEBUG] Detec√ß√£o: {det_class} em ({det_x}, {det_y})")
                
                # ‚úÖ L√ìGICA MELHORADA: Verificar correspond√™ncia exata OU parcial
                is_fish = False
                
                # 1Ô∏è‚É£ Verifica√ß√£o exata
                if det_class in [f.lower() for f in fish_classes]:
                    is_fish = True
                    print(f"   ‚úÖ Match exato: {det_class}")
                
                # 2Ô∏è‚É£ Verifica√ß√£o parcial (para casos como 'shark' vs 'smallshark')
                if not is_fish:
                    for fish_class in fish_classes:
                        if fish_class.lower() in det_class or det_class in fish_class.lower():
                            is_fish = True
                            print(f"   ‚úÖ Match parcial: {det_class} ‚âà {fish_class}")
                            break
                
                # 3Ô∏è‚É£ Verifica√ß√£o por palavras-chave cr√≠ticas
                if not is_fish:
                    critical_keywords = ['salmon', 'shark', 'fish', 'trout', 'herring', 'sardine', 'anchovy', 'perch']
                    for keyword in critical_keywords:
                        if keyword in det_class:
                            is_fish = True
                            print(f"   ‚úÖ Match por palavra-chave: {det_class} cont√©m '{keyword}'")
                            break
                
                if is_fish and det_x < 1242:  # Invent√°rio (esquerda)
                    found_fish.append(detection)
                    print(f"üêü Transferindo {det_class} para ba√∫ - posi√ß√£o ({det_x}, {det_y})")
                    pyautogui.rightClick(det_x, det_y)
                    time.sleep(0.3)
                    fish_transferred += 1
                elif is_fish and det_x >= 1242:
                    print(f"   ‚ÑπÔ∏è {det_class} detectado no ba√∫ (lado direito), ignorando")
            
            print(f"üîç [DEBUG] Peixes encontrados no invent√°rio: {len(found_fish)}")
            for fish in found_fish:
                print(f"   - {fish.get('class')} em ({fish.get('center_x', fish.get('x'))}, {fish.get('center_y', fish.get('y'))})")

            print(f"‚úÖ {fish_transferred} peixes transferidos para o ba√∫")

            # REMOVIDO: Coletar iscas - desnecess√°rio durante limpeza
            # O objetivo √© apenas limpar o invent√°rio, n√£o pegar iscas

            print(f"üéØ [RESUMO] Limpeza completa: {fish_transferred} peixes guardados no ba√∫")
            
            # üîß OTIMIZA√á√ÉO: Verificar e fazer manuten√ß√£o de varas j√° que ba√∫ est√° aberto
            print("\nüîß [OTIMIZA√á√ÉO] Verificando estado das varas para manuten√ß√£o...")
            maintenance_needed = self.check_and_maintain_rods_after_cleanup()
            
            # PASSO 6: Fechar ba√∫ (ap√≥s manuten√ß√£o)
            time.sleep(1)
            print("üö™ Fechando ba√∫...")
            self.close_inventory_with_delay("Auto opera√ß√£o")
            
            if maintenance_needed:
                print("üîß [OTIMIZA√á√ÉO] Manuten√ß√£o de varas realizada durante limpeza!")
            else:
                print("‚úÖ [OTIMIZA√á√ÉO] Todas as varas est√£o OK, nenhuma manuten√ß√£o necess√°ria")
            
            return fish_transferred

        except Exception as e:
            print(f"‚ùå Erro na transfer√™ncia de peixes: {e}")
            # Garantir que ba√∫ seja fechado em caso de erro
            try:
                pyautogui.press('tab')
            except:
                pass
            return 0


    def check_and_maintain_rods_after_cleanup(self):
        """üîß Verifica√ß√£o e manuten√ß√£o de varas ap√≥s limpeza/alimenta√ß√£o (ba√∫ j√° aberto)"""
        print("üîç [MANUTEN√á√ÉO] Usando sistema completo de manuten√ß√£o (igual tecla 0)...")
        
        try:
            # Executar a mesma l√≥gica da tecla 0, mas sem abrir o ba√∫
            self.auto_rod_maintenance_system_without_chest_opening()
            return True
                
        except Exception as e:
            print(f"‚ùå [MANUTEN√á√ÉO] Erro na verifica√ß√£o: {e}")
            return False
    
    def auto_rod_maintenance_system_without_chest_opening(self):
        """üîß Sistema Completo de Manuten√ß√£o - Vers√£o sem abrir ba√∫ (para usar durante limpeza/alimenta√ß√£o)"""
        print("\n" + "="*70)
        print("üîß SISTEMA DE MANUTEN√á√ÉO AUTOM√ÅTICA DE VARAS")
        print("üì¶ Ba√∫ j√° est√° aberto - pulando abertura")
        print("="*70)

        try:
            # PASSO 0: Limpar cache antes de come√ßar
            print("üßπ PASSO 0: Limpando cache do sistema...")
            self.clear_detection_cache()
            print("‚úÖ Cache limpo!")
            
            # PULAR ABERTURA DO BA√ö - j√° est√° aberto durante limpeza/alimenta√ß√£o
            print("üì¶ Ba√∫ j√° est√° aberto - continuando com manuten√ß√£o...")

            # ‚úÖ OTIMIZADO: Aguardar carregamento 
            print("‚è≥ Aguardando carregamento dos itens no ba√∫...")
            time.sleep(1.5)  # ‚úÖ OTIMIZADO: Reduzido de 3s para 1.5s

            # ‚úÖ CORRE√á√ÉO CR√çTICA: Aguardar Catch Viewer atualizar primeiro
            print("üîç Aguardando Catch Viewer processar invent√°rio aberto...")
            time.sleep(1.0)  # ‚úÖ OTIMIZADO: Reduzido de 2s para 1s

            # ‚úÖ CORRE√á√ÉO: M√∫ltiplas verifica√ß√µes para garantir consist√™ncia
            print("üîç Detectando status das varas nos slots 1-6...")
            print("üìä EXECUTANDO M√öLTIPLAS VERIFICA√á√ïES para garantir consist√™ncia:")

            rod_status = None
            consistent_detections = 0
            max_attempts = 3

            for attempt in range(max_attempts):
                print(f"   üîç Tentativa {attempt + 1}/{max_attempts}: Detectando status...")
                current_detection = self.detect_all_rod_status()

                if attempt == 0:
                    rod_status = current_detection
                    consistent_detections = 1
                else:
                    # Comparar com detec√ß√£o anterior
                    if current_detection == rod_status:
                        consistent_detections += 1
                        print(f"   ‚úÖ Detec√ß√£o consistente ({consistent_detections}/{max_attempts})")
                    else:
                        print(f"   ‚ö†Ô∏è Detec√ß√£o inconsistente - aguardando mais tempo...")
                        rod_status = current_detection  # Usar mais recente
                        consistent_detections = 1

                # Se temos pelo menos 2 detec√ß√µes consistentes, podemos prosseguir
                if consistent_detections >= 2:
                    print(f"   üéØ STATUS CONSISTENTE CONFIRMADO ap√≥s {attempt + 1} tentativas!")
                    break

                # Aguardar entre tentativas
                if attempt < max_attempts - 1:
                    print(f"   ‚è≥ Aguardando 2s antes da pr√≥xima verifica√ß√£o...")
                    time.sleep(2.0)

            if consistent_detections < 2:
                print(f"   ‚ö†Ô∏è Usando √∫ltima detec√ß√£o (confiabilidade: {consistent_detections}/{max_attempts})")

            print(f"üìä STATUS FINAL DETECTADO: {rod_status}")

            # üéØ USAR DIRETAMENTE O STATUS DAS VARAS DETECTADO
            print("\nüéØ USANDO STATUS DAS VARAS DETECTADO:")
            print("="*60)

            # Listas baseadas EXATAMENTE no status detectado
            broken_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "broken"]
            empty_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "empty"]
            no_bait_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "no_bait"]
            with_bait_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "with_bait"]

            # Slots que precisam de VARA = vazios + quebradas
            slots_needing_rods = empty_slots + broken_slots

            print(f"üìä RESULTADO DIRETO DO STATUS:")
            print(f"   ‚ùå Quebradas: {broken_slots}")
            print(f"   ‚ö™ Vazios: {empty_slots}")
            print(f"   ‚ö†Ô∏è Sem isca: {no_bait_slots}")
            print(f"   ‚úÖ Com isca: {with_bait_slots}")
            print(f"")
            print(f"üîÑ PRECISAM DE VARA: {sorted(slots_needing_rods)} = vazios + quebradas")
            print(f"üé£ PRECISAM DE ISCA: {no_bait_slots} = varas sem isca")

            print(f"üîç [DEBUG] slots_needing_rods FINAL: {sorted(slots_needing_rods)}")

            if slots_needing_rods:
                print(f"üîÑ Repor varas em: {sorted(slots_needing_rods)} ({len(slots_needing_rods)} slots precisam de vara)")
            else:
                print(f"üîÑ Repor varas: Todos os slots t√™m varas ‚úì")

            if no_bait_slots:
                print(f"üé£ Recarregar iscas em: {no_bait_slots} ({len(no_bait_slots)} slots precisam de isca)")
            else:
                print(f"üé£ Recarregar iscas: Todas as varas t√™m isca ‚úì")

            print("="*60)

            # Continuar com o resto da l√≥gica da fun√ß√£o auto_rod_maintenance_system()
            # A partir daqui, executar a mesma l√≥gica de reposi√ß√£o de varas e iscas
            
            # CHAMAR A PARTE DE REPOSI√á√ÉO DA FUN√á√ÉO ORIGINAL
            self._execute_rod_maintenance_logic(rod_status, broken_slots, empty_slots, 
                                               no_bait_slots, with_bait_slots, slots_needing_rods)
            
        except Exception as e:
            print(f"‚ùå Erro na manuten√ß√£o autom√°tica: {e}")
            import traceback
            traceback.print_exc()
    
    def transfer_fish_to_chest(self):
        """Transferir todos os peixes do invent√°rio para o ba√∫ - FUN√á√ÉO ORIGINAL"""
        # Redirecionar para vers√£o melhorada
        return self.transfer_fish_to_chest_improved()
    
    def _execute_rod_maintenance_logic(self, rod_status, broken_slots, empty_slots, 
                                      no_bait_slots, with_bait_slots, slots_needing_rods):
        """üîß Executa a l√≥gica de manuten√ß√£o de varas (mesma da tecla 0)"""
        try:
            print("üí° PRIORIDADES:")
            print("   1Ô∏è‚É£ Varas quebradas (PRIORIDADE M√ÅXIMA se detectadas)")
            print("   2Ô∏è‚É£ Slots vazios (reposi√ß√£o de varas)")
            print("   3Ô∏è‚É£ Varas sem isca (recarga de iscas)")

            # üîß FASE 1: MANEJO DE VARAS QUEBRADAS (PRIORIDADE M√ÅXIMA) - CONFIGUR√ÅVEL
            broken_rod_action = self.config.get('broken_rod_action', 'discard')
            action_name = "DESCARTE" if broken_rod_action == 'discard' else "ARMAZENAMENTO"
            print(f"\nüîß FASE 1: {action_name} DE VARAS QUEBRADAS (PRIORIDADE M√ÅXIMA)")
            
            if broken_slots:
                print(f"üö® VARAS QUEBRADAS DETECTADAS: {broken_slots} - EXECUTANDO COM PRIORIDADE!")
                print(f"‚öôÔ∏è MODO CONFIGURADO: {broken_rod_action}")
                print(f"Processando {len(broken_slots)} varas quebradas:")

                for i, slot in enumerate(broken_slots, 1):
                    print(f"\nüö® [{i}/{len(broken_slots)}] PRIORIDADE: Processando vara quebrada no slot {slot}:")
                    
                    if broken_rod_action == 'discard':
                        print(f"   üóëÔ∏è Descartando vara quebrada (como tecla 0)...")
                        self.remove_broken_rod_from_slot(slot)
                    else:  # save
                        print(f"   üì¶ Guardando vara quebrada no ba√∫...")
                        self.save_broken_rod_to_chest(slot)

                action_verb = "descartadas" if broken_rod_action == 'discard' else "guardadas no ba√∫"
                print(f"\n‚úÖ FASE 1 COMPLETA: {len(broken_slots)} varas quebradas foram {action_verb}!")
                print(f"üìä Slots liberados para reposi√ß√£o: {broken_slots}")
            else:
                print("‚ÑπÔ∏è Nenhuma vara quebrada detectada - continuando para pr√≥ximas fases")

            # üîÑ FASE 2: REPOSI√á√ÉO DE VARAS COM L√ìGICA DE PRIORIZA√á√ÉO
            print(f"\nüîÑ FASE 2: REPOSI√á√ÉO DE VARAS COM PRIORIZA√á√ÉO")
            if slots_needing_rods:
                print(f"Slots que precisam de vara: {sorted(slots_needing_rods)} ({len(slots_needing_rods)} total)")

                # ‚úÖ PASSO 1: Escanear varas dispon√≠veis
                print("üìã Escaneando varas dispon√≠veis no ba√∫...")
                chest_rods_cache = self.scan_chest_rods()
                # Inicializar tracking de posi√ß√µes se n√£o existir
                if 'detected_positions' not in chest_rods_cache:
                    chest_rods_cache['detected_positions'] = set()
                varas_com_isca = len(chest_rods_cache['with_bait'])
                varas_sem_isca = len(chest_rods_cache['without_bait'])
                total_varas = varas_com_isca + varas_sem_isca

                print(f"üìä INVENT√ÅRIO DO BA√ö:")
                print(f"   üèÜ Varas COM isca: {varas_com_isca}")
                print(f"   ‚ö†Ô∏è Varas SEM isca: {varas_sem_isca}")
                print(f"   üì¶ Total de varas: {total_varas}")
                print(f"   üéØ Slots que precisam: {len(slots_needing_rods)}")

                # ‚úÖ PASSO 2: Verificar se temos varas suficientes
                if total_varas < len(slots_needing_rods):
                    print(f"‚ö†Ô∏è AVISO: S√≥ temos {total_varas} varas para {len(slots_needing_rods)} slots!")
                    print(f"   üìå Processaremos o m√°ximo poss√≠vel")

                # ‚úÖ PASSO 3: L√ìGICA DE PRIORIZA√á√ÉO IMPLEMENTADA
                print(f"\nüß† ESTRAT√âGIA DE COLOCA√á√ÉO:")
                slots_que_receberao_vara_com_isca = min(varas_com_isca, len(slots_needing_rods))
                slots_que_receberao_vara_sem_isca = min(varas_sem_isca, len(slots_needing_rods) - slots_que_receberao_vara_com_isca)

                print(f"   1Ô∏è‚É£ PRIMEIRA: {slots_que_receberao_vara_com_isca} slots receber√£o varas COM isca")
                print(f"   2Ô∏è‚É£ SEGUNDA: {slots_que_receberao_vara_sem_isca} slots receber√£o varas SEM isca")
                print(f"   üìù RESULTADO: {slots_que_receberao_vara_sem_isca} varas precisar√£o de isca na Fase 3")

                # ‚úÖ PASSO 4: Executar coloca√ß√£o com controle de prioriza√ß√£o
                slots_com_vara_sem_isca = []  # üìù IMPORTANTE: Rastrear quais receberam vara SEM isca

                for i, slot in enumerate(sorted(slots_needing_rods), 1):
                    print(f"\n[{i}/{len(slots_needing_rods)}] Colocando vara no slot {slot}:")

                    # Re-escanear cache periodicamente
                    cache_refresh_needed = False
                    total_cache_rods = len(chest_rods_cache['with_bait']) + len(chest_rods_cache['without_bait'])

                    if i == 1 or (i-1) % 2 == 0 or total_cache_rods <= 1:
                        cache_refresh_needed = True
                        print(f"   üîÑ [CACHE] Re-escaneamento...")

                    if cache_refresh_needed:
                        old_positions = chest_rods_cache.get('detected_positions', set()) if chest_rods_cache else set()
                        chest_rods_cache = self.scan_chest_rods()
                        if old_positions:
                            chest_rods_cache['detected_positions'] = chest_rods_cache.get('detected_positions', set()).union(old_positions)
                        total_cache_rods = len(chest_rods_cache['with_bait']) + len(chest_rods_cache['without_bait'])
                        print(f"   üìä [CACHE] Atualizado: {len(chest_rods_cache['with_bait'])} COM isca, {len(chest_rods_cache['without_bait'])} SEM isca")

                    # Verificar se ainda h√° varas dispon√≠veis
                    if total_cache_rods == 0:
                        print(f"   ‚ùå NENHUMA vara encontrada no ba√∫!")
                        break

                    # Decidir qual tipo de vara usar
                    if chest_rods_cache.get('with_bait') and len(chest_rods_cache['with_bait']) > 0:
                        print(f"   üèÜ DECIS√ÉO: Usar COM isca (restam {len(chest_rods_cache['with_bait'])})")
                        vara_colocada_tem_isca = True
                    elif chest_rods_cache.get('without_bait') and len(chest_rods_cache['without_bait']) > 0:
                        print(f"   ‚ö†Ô∏è DECIS√ÉO: Usar SEM isca (restam {len(chest_rods_cache['without_bait'])})")
                        vara_colocada_tem_isca = False
                        slots_com_vara_sem_isca.append(slot)  # üìù REGISTRAR para Fase 3
                    else:
                        print(f"   ‚ùå Nenhuma vara restante no ba√∫!")
                        break

                    success = self.place_rod_in_empty_slot(slot, chest_rods_cache)
                    if not success:
                        print(f"‚ö†Ô∏è Falha ao colocar vara no slot {slot}")
                        chest_rods_cache = self.scan_chest_rods()
                        if slot in slots_com_vara_sem_isca:
                            slots_com_vara_sem_isca.remove(slot)
                        continue

                    # Registrar sucesso
                    if vara_colocada_tem_isca:
                        print(f"   ‚úÖ Slot {slot}: Vara COM isca colocada")
                    else:
                        print(f"   üìù Slot {slot}: Vara SEM isca colocada - PRECISAR√Å recarga")

                    time.sleep(1.2)  # Delay entre coloca√ß√µes

                print(f"\nüìä RESULTADO DA FASE 2:")
                print(f"   ‚úÖ Slots processados: {len(slots_needing_rods)}")
                print(f"   üìù Slots que PRECISAR√ÉO de isca na Fase 3: {slots_com_vara_sem_isca}")

                # Salvar lista para uso na Fase 3
                self._slots_needing_bait_from_phase2 = slots_com_vara_sem_isca
            else:
                print("‚úÖ Todos os slots j√° t√™m varas - nada para repor")
                self._slots_needing_bait_from_phase2 = []

            # üé£ FASE 3: RECARGA DE ISCAS NAS VARAS SEM ISCA
            print(f"\nüé£ FASE 3: RECARGA DE ISCAS")

            # Limpar cache e aguardar estabiliza√ß√£o
            print("üßπ Limpando caches de detec√ß√£o...")
            self.clear_detection_cache()
            print("‚è≥ Aguardando estabiliza√ß√£o ap√≥s coloca√ß√£o de varas...")
            time.sleep(2.0)  # ‚úÖ OTIMIZADO: Reduzido de 5s para 2s

            # For√ßar nova detec√ß√£o completa
            print("üîÑ For√ßando nova detec√ß√£o completa de status das varas...")
            updated_rod_status = self.detect_all_rod_status()
            print(f"üìä Status atualizado ap√≥s FASE 2: {updated_rod_status}")

            # Usar status atualizado para identificar slots sem isca
            updated_no_bait_slots = [slot for slot in range(1, 7) if updated_rod_status.get(slot) == "no_bait"]
            print(f"üéØ Slots sem isca (detec√ß√£o atualizada): {updated_no_bait_slots}")

            # Combinar com slots que receberam vara sem isca
            slots_que_receberam_vara_sem_isca = getattr(self, '_slots_needing_bait_from_phase2', [])
            confirmed_no_bait_slots = list(set(updated_no_bait_slots + slots_que_receberam_vara_sem_isca))
            print(f"   üéØ TOTAL que precisa de isca: {sorted(confirmed_no_bait_slots)}")

            no_bait_slots = confirmed_no_bait_slots

            if no_bait_slots:
                print(f"\nüèÜ ‚úÖ EXECUTANDO RECARGA DE ISCAS:")
                print(f"   üìã Slots que precisam de isca: {no_bait_slots}")
                print(f"   üìä Total de slots: {len(no_bait_slots)}")

                # Escanear iscas dispon√≠veis
                print(f"\nüìã Escaneando iscas dispon√≠veis no ba√∫...")
                all_baits = self.scan_all_baits_in_chest()

                if not all_baits:
                    print("‚ùå ERRO CR√çTICO: Nenhuma isca encontrada no ba√∫!")
                    return

                # Executar recarga para cada slot
                for i, slot in enumerate(no_bait_slots, 1):
                    print(f"\n[{i}/{len(no_bait_slots)}] Recarregando isca no slot {slot}:")
                    
                    # Re-escanear iscas se necess√°rio
                    if i == 1 or (i-1) % 3 == 0 or not all_baits:
                        print("   üîÑ Re-escaneando iscas...")
                        all_baits = self.scan_all_baits_in_chest()
                        if not all_baits:
                            print("   ‚ùå Nenhuma isca dispon√≠vel!")
                            break

                    # Escolher melhor isca
                    best_bait = self.select_best_bait(all_baits)
                    if not best_bait:
                        print("   ‚ùå Nenhuma isca adequada encontrada!")
                        continue

                    print(f"   üéØ Isca selecionada: {best_bait.get('class', 'unknown')} @ ({best_bait['x']}, {best_bait['y']})")

                    # Aplicar isca na vara
                    success = self.apply_bait_to_rod_slot(slot, best_bait)
                    if success:
                        print(f"   ‚úÖ Isca aplicada com sucesso no slot {slot}!")
                        # Remover isca usada da lista (buscar por coordenadas)
                        for j, bait in enumerate(all_baits):
                            if bait['x'] == best_bait['x'] and bait['y'] == best_bait['y']:
                                removed_bait = all_baits.pop(j)
                                print(f"   üóëÔ∏è Isca {removed_bait['name']} removida da lista (posi√ß√£o {j})")
                                break
                    else:
                        print(f"   ‚ö†Ô∏è Falha ao aplicar isca no slot {slot}")

                    time.sleep(1.5)  # Aguardar entre aplica√ß√µes

                print(f"\n‚úÖ FASE 3 COMPLETA: Iscas recarregadas!")
            else:
                print("‚úÖ Todas as varas j√° t√™m isca - nada para recarregar")

            print("\n" + "="*70)
            print("‚úÖ MANUTEN√á√ÉO COMPLETA!")
            print("="*70)

        except Exception as e:
            print(f"‚ùå Erro na execu√ß√£o da l√≥gica de manuten√ß√£o: {e}")
            import traceback
            traceback.print_exc()

    def clean_broken_rods_maintenance(self, detections):
        """üîß Limpar varas quebradas durante manuten√ß√£o"""
        print("üîß [MANUTEN√á√ÉO] Removendo varas quebradas...")
        
        for detection in detections:
            det_class = detection.get('class', '')
            if 'quebrada' in det_class or 'broken' in det_class:
                det_x = detection.get('center_x', detection.get('x', 0))
                det_y = detection.get('center_y', detection.get('y', 0))
                
                print(f"üóëÔ∏è [MANUTEN√á√ÉO] Removendo vara quebrada em ({det_x}, {det_y})")
                
                # Clique na vara quebrada
                pyautogui.click(det_x, det_y)
                time.sleep(0.3)
                
                # Remove isca se houver (clique direito na regi√£o da isca)
                pyautogui.rightClick(721, 359)  # Posi√ß√£o padr√£o da isca
                time.sleep(0.3)
                
                # Arrasta vara quebrada para fora
                pyautogui.mouseDown(button='left')
                time.sleep(0.3)
                pyautogui.moveTo(1050, 650)  # Regi√£o de descarte
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                time.sleep(0.3)

    def fill_empty_slots_from_chest(self, detections):
        """üé£ Preencher slots vazios com varas do ba√∫"""
        print("üé£ [MANUTEN√á√ÉO] Preenchendo slots vazios...")
        
        # Buscar varas dispon√≠veis no ba√∫ (lado direito)
        available_rods = []
        for detection in detections:
            det_x = detection.get('center_x', detection.get('x', 0))
            det_class = detection.get('class', '')
            
            if det_x > 1242 and ('vara' in det_class.lower() or 'rod' in det_class.lower()):
                available_rods.append(detection)
        
        print(f"üé£ [MANUTEN√á√ÉO] Varas dispon√≠veis no ba√∫: {len(available_rods)}")
        
        # Preencher at√© 3 varas (suficiente para continuar)
        slot_positions = [(690, 615), (742, 615), (794, 615)]  # Slots 1, 2, 3
        
        for i, rod in enumerate(available_rods[:3]):
            if i < len(slot_positions):
                rod_x = rod.get('center_x', rod.get('x', 0))
                rod_y = rod.get('center_y', rod.get('y', 0))
                slot_x, slot_y = slot_positions[i]
                
                print(f"üé£ [MANUTEN√á√ÉO] Movendo vara do ba√∫ ({rod_x}, {rod_y}) para slot {i+1} ({slot_x}, {slot_y})")
                
                # Arrastar vara do ba√∫ para slot
                pyautogui.mouseDown(button='left', x=rod_x, y=rod_y)
                time.sleep(0.3)
                pyautogui.moveTo(slot_x, slot_y)
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                time.sleep(0.3)

    def reload_rods_without_bait(self, detections):
        """ü•© Recarregar varas sem isca"""
        print("ü•© [MANUTEN√á√ÉO] Recarregando varas sem isca...")
        
        # Buscar iscas dispon√≠veis no ba√∫
        available_baits = []
        for detection in detections:
            det_x = detection.get('center_x', detection.get('x', 0))
            det_class = detection.get('class', '')
            
            if det_x > 1242 and det_class in ['carne de urso', 'carne de lobo', 'grub', 'worm']:
                available_baits.append(detection)
        
        print(f"ü•© [MANUTEN√á√ÉO] Iscas dispon√≠veis: {len(available_baits)}")
        
        # Aplicar iscas nas varas vazias (implementa√ß√£o simplificada)
        if available_baits:
            for bait in available_baits[:3]:  # At√© 3 iscas
                bait_x = bait.get('center_x', bait.get('x', 0))
                bait_y = bait.get('center_y', bait.get('y', 0))
                
                print(f"ü•© [MANUTEN√á√ÉO] Coletando isca {bait.get('class')} para invent√°rio")
                pyautogui.rightClick(bait_x, bait_y)
                time.sleep(0.3)

    def increment_fish_count(self, is_real_catch=True):
        """Incrementar contador de pescas para limpeza autom√°tica
        
        Args:
            is_real_catch: True se √© uma captura real do bot, False se √© detec√ß√£o durante abertura manual
        """
        print(f"üêü [DEBUG] increment_fish_count chamada: is_real_catch={is_real_catch}, running={self.running}, manual_open={self.game_state.get('manual_inventory_open', False)}")
        
        # ‚ö° L√ìGICA CORRIGIDA: Captura real sempre conta, mesmo se invent√°rio foi aberto manualmente
        if is_real_catch and self.running:
            self.auto_clean['fish_count_since_last'] += 1
            self.auto_clean['real_fish_caught'] = self.auto_clean.get('real_fish_caught', 0) + 1
            print(f"üßπ Pescas desde √∫ltima limpeza: {self.auto_clean['fish_count_since_last']}/{self.auto_clean['interval']}")
            
            # DEBUG: Verificar se atingiu limite
            if self.auto_clean['fish_count_since_last'] >= self.auto_clean['interval']:
                print(f"üö® [DEBUG] LIMITE ATINGIDO! Deve executar limpeza: {self.auto_clean['fish_count_since_last']}>={self.auto_clean['interval']}")
        else:
            conditions = []
            if not is_real_catch: conditions.append("not_real_catch")
            if not self.running: conditions.append("not_running")
            print(f"‚ö†Ô∏è [LIMPEZA] Ignorando contagem - Motivo: {', '.join(conditions)}")
            
        # ‚ö° LIMPEZA DE FLAG: Limpar flag manual ap√≥s peixe real ser capturado
        if is_real_catch and self.running:
            if self.game_state.get('manual_inventory_open', False):
                print("üßπ [FLAG] Limpando flag manual_inventory_open ap√≥s captura real")
                self.game_state['manual_inventory_open'] = False

    def open_chest(self):
        """Abrir ba√∫ usando macro padr√£o que funciona (M√âTODO PRINCIPAL)"""
        print("\n" + "="*50)
        print("üì¶ ABRINDO BA√ö - SEQU√äNCIA ALT+MOVIMENTO+E")
        print("="*50)

        # Usar configura√ß√µes que funcionam
        chest_side = self.config.get('chest_side', 'left')
        chest_distance = self.config.get('chest_distance', 1200)

        print(f"Config: lado={chest_side}, dist√¢ncia={chest_distance}px")

        try:
            # PASSO 1: Pressionar ALT
            print("\n[1/4] Pressionando ALT...")
            pyautogui.keyDown('alt')
            time.sleep(0.5)
            print("   ‚úì ALT pressionado")

            # PASSO 2: Girar c√¢mera
            print("\n[2/4] Girando c√¢mera para o ba√∫...")
            camera_turn(chest_side, chest_distance)
            time.sleep(0.3)
            print(f"   ‚úì C√¢mera girada para {chest_side}")

            # PASSO 3: Pressionar E (mantendo ALT)
            print("\n[3/4] Pressionando E (com ALT ainda pressionado)...")
            pyautogui.press('e')
            time.sleep(0.5)
            print("   ‚úì E pressionado")

            # PASSO 4: Soltar ALT
            print("\n[4/4] Soltando ALT...")
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')
            print("   ‚úì ALT liberado")

            # IMPORTANTE: ALT+E abre TANTO o ba√∫ QUANTO o invent√°rio
            print("\n‚úÖ Ba√∫ E invent√°rio abertos com sucesso!")
            print("   Nota: ALT+E abre ambos simultaneamente")
            print("="*50 + "\n")

            self.game_state['chest_open'] = True
            self.game_state['inventory_open'] = True
            return True

        except Exception as e:
            print(f"\n‚ùå ERRO ao abrir ba√∫: {e}")
            print("   Tentando liberar ALT...")
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
            except:
                pass
            print("="*50 + "\n")
            return False

    def open_chest_old(self):
        """Abrir ba√∫ conforme configura√ß√£o com detec√ß√£o inteligente"""
        print("üì¶ Abrindo ba√∫...")

        try:
            # Garantir que a janela do jogo est√° ativa primeiro
            print("   üéÆ Ativando janela do jogo...")
            pyautogui.click()  # Clique para ativar janela
            time.sleep(0.2)

            # ALT pressionado
            pyautogui.keyDown('alt')
            time.sleep(0.3)  # Mais tempo para ALT registrar

            chest_found = False

            # M√âTODO 0: Tentar executar macro gravado primeiro (se existir)
            macro_files = ["chest_macro.pmc", "MyScript.ahk", "chest_macro.ahk"]
            macro_file = None

            # Procurar por arquivos de macro na ordem de prefer√™ncia
            for file in macro_files:
                if os.path.exists(file):
                    macro_file = file
                    break

            if macro_file:
                print("   üé¨ Tentando usar macro gravado...")
                if macro_file.endswith('.ahk'):
                    macro_success = run_ahk_script(macro_file)
                elif macro_file.endswith('.pmc'):
                    macro_success = run_pulover_macro(macro_file)
                else:
                    macro_success = False

                if macro_success:
                    print("   ‚úÖ Macro executado! Verificando se abriu...")
                    time.sleep(1.0)
                    chest_found = True
                else:
                    print("   ‚ö†Ô∏è Macro falhou, tentando outros m√©todos...")

            # M√âTODO 1: Tentar detectar ba√∫ com YOLO primeiro
            if self.yolo_model and self.sct:
                print("   üîç Tentando detectar ba√∫ com YOLO...")
                detections = self.detect_objects()

                for detection in detections:
                    # Procurar por ba√∫ fechado ou qualquer indica√ß√£o de ba√∫
                    if 'barril' in detection['class'].lower() or 'chest' in detection['class'].lower():
                        print(f"   üì¶ Ba√∫ detectado: {detection['class']} em {detection['center']}")
                        pyautogui.moveTo(detection['center'][0], detection['center'][1])
                        chest_found = True
                        break

            # M√âTODO 2: Se n√£o encontrou, usar posi√ß√£o configurada
            if not chest_found:
                chest_side = self.config.get('chest_side', 'left')
                chest_absolute = self.config.get('chest_absolute_pos', {})

                # Verificar se tem posi√ß√£o absoluta capturada
                if chest_side in chest_absolute and chest_absolute[chest_side]['x'] != 0:
                    # Usar posi√ß√£o absoluta capturada
                    target_pos = (chest_absolute[chest_side]['x'], chest_absolute[chest_side]['y'])
                    print(f"   üìç Usando posi√ß√£o CAPTURADA do ba√∫ {chest_side}: {target_pos}")
                else:
                    # Usar posi√ß√£o relativa (fallback)
                    print("   üìç Usando posi√ß√£o RELATIVA do ba√∫...")
                    move_distance = self.config.get('chest_distance', 300)
                    current_pos = pyautogui.position()

                    if chest_side == 'left':
                        target_pos = (current_pos.x - move_distance, current_pos.y)
                        print(f"   ‚¨ÖÔ∏è Movendo {move_distance}px para ESQUERDA")
                    else:
                        target_pos = (current_pos.x + move_distance, current_pos.y)
                        print(f"   ‚û°Ô∏è Movendo {move_distance}px para DIREITA")

                # Usar fun√ß√£o robusta de movimento
                movimento_ok = force_mouse_move(target_pos[0], target_pos[1])

                if not movimento_ok:
                    print("   ‚ùå AVISO: Falha no movimento do mouse! Pode afetar abertura do ba√∫.")
                    # Continua mesmo assim - pode funcionar no jogo

            # Confirmar posi√ß√£o final com verifica√ß√£o de movimento
            final_pos = pyautogui.position()
            print(f"   üìç Posi√ß√£o final: {final_pos}")

            # Verificar se o mouse realmente se moveu
            pos_inicial = (960, 540)  # Posi√ß√£o central aproximada
            movimento_realizado = abs(final_pos.x - pos_inicial[0]) + abs(final_pos.y - pos_inicial[1])

            if movimento_realizado < 50:  # Se moveu muito pouco
                print("   ‚ö†Ô∏è AVISO: Mouse pode n√£o ter se movido no jogo!")
                print("   üîÑ Tentando movimento alternativo...")

                # M√©todo alternativo: usar coordenadas relativas em pequenos passos
                for step in range(5):
                    direction = -1 if chest_side == 'left' else 1
                    step_size = 60
                    new_x = pos_inicial[0] + (direction * step_size * (step + 1))

                    pyautogui.moveTo(new_x, pos_inicial[1], duration=0.05)
                    time.sleep(0.05)

                    current_check = pyautogui.position()
                    if abs(current_check.x - new_x) > 5:
                        print(f"   ‚úÖ Movimento detectado na tentativa {step + 1}: {current_check}")
                        break

            time.sleep(0.3)

            # Pressionar E para interagir
            print("   ‚å®Ô∏è Pressionando E para abrir...")
            pyautogui.press('e')
            time.sleep(0.5)  # Mais tempo para garantir abertura

            # Verificar se abriu corretamente (precisa detectar AMBOS)
            if self.yolo_model:
                print("   üîç Verificando abertura com YOLO...")
                time.sleep(0.5)  # Aguardar anima√ß√µes
                detections = self.detect_objects()

                inventario_aberto = False
                barril_aberto = False

                for detection in detections:
                    if detection['class'] == 'inventario aberto':
                        inventario_aberto = True
                        print(f"   üì¶ INVENT√ÅRIO ABERTO detectado! (conf: {detection['confidence']:.2f})")
                    elif detection['class'] == 'barril aberto':
                        barril_aberto = True
                        print(f"   üóÉÔ∏è BARRIL ABERTO detectado! (conf: {detection['confidence']:.2f})")

                if inventario_aberto and barril_aberto:
                    print("   üéâ SUCESSO COMPLETO: Invent√°rio + Barril abertos!")
                    return True
                elif inventario_aberto:
                    print("   ‚ö†Ô∏è PARCIAL: Invent√°rio aberto, mas barril n√£o detectado")
                    return False
                elif barril_aberto:
                    print("   ‚ö†Ô∏è PARCIAL: Barril aberto, mas invent√°rio n√£o detectado")
                    return False
                else:
                    print("   ‚ùå FALHA: Nem invent√°rio nem barril detectados")
                    return False
            else:
                print("   ‚ö†Ô∏è YOLO n√£o dispon√≠vel - n√£o √© poss√≠vel verificar")
                return None

        except Exception as e:
            print(f"   ‚ùå Erro ao abrir ba√∫: {e}")
        finally:
            # Sempre soltar ALT
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')

    def execute_feeding(self):
        """Executar alimenta√ß√£o completa com sistema de 2 slots"""
        print("üçñ Executando alimenta√ß√£o com rota√ß√£o de slots...")

        # CR√çTICO: Marcar a√ß√£o em progresso para bloquear pesca
        self.game_state['action_in_progress'] = True
        self.game_state['feeding_active'] = True

        try:
            # Verificar slot atual e disponibilidade
            current_slot = self.alimentacao['current_slot']
            slot1_uses = self.alimentacao['slot1_uses']
            slot2_uses = self.alimentacao['slot2_uses']
            max_uses = self.alimentacao['max_uses_per_slot']

            print(f"üìä Status: Slot1({slot1_uses}/{max_uses}) | Slot2({slot2_uses}/{max_uses}) | Atual: {current_slot}")

            # Verificar se precisa trocar de slot
            if current_slot == 1 and slot1_uses >= max_uses:
                if slot2_uses < max_uses:
                    self.alimentacao['current_slot'] = 2
                    current_slot = 2
                    print("üîÑ Slot 1 esgotado! Mudando para Slot 2")
                else:
                    print("‚ö†Ô∏è AMBOS SLOTS ESGOTADOS! Precisa reabastecer comida")
                    return
            elif current_slot == 2 and slot2_uses >= max_uses:
                print("‚ö†Ô∏è Slot 2 tamb√©m esgotado! Precisa reabastecer comida")
                return

            # üçñ NOVO: Verificar modo de alimenta√ß√£o selecionado ANTES de abrir ba√∫
            feeding_mode = self.alimentacao.get('feeding_mode', 'slots_fixos')
            print(f"üçñ Modo de alimenta√ß√£o ativo: {feeding_mode}")

            if feeding_mode == 'detecao_auto':
                # MODO AUTOM√ÅTICO - Abrir ba√∫ usando sistema do manual direto
                print("üîç Modo detec√ß√£o autom√°tica - abrindo ba√∫...")

                # Abrir ba√∫ usando sistema do manual (open_chest_direct_like_f11)
                chest_success = self.open_chest_direct_like_f11()
                if not chest_success:
                    print("‚ùå Falha ao abrir ba√∫ para detec√ß√£o autom√°tica")
                    return

                time.sleep(1)  # Aguardar ba√∫ abrir completamente

                print("üîç Executando detec√ß√£o autom√°tica de comida + eat...")
                food_detected = self.find_and_click_food_automatically()
                if not food_detected:
                    print("‚ùå Nenhuma comida encontrada automaticamente! Pulando alimenta√ß√£o...")
                    return

                # No modo autom√°tico, a fun√ß√£o j√° faz tudo (clica comida + clica eat X vezes)
                print("‚úÖ Sequ√™ncia autom√°tica executada - alimenta√ß√£o conclu√≠da!")

                # Atualizar contadores (simular que usamos slot 1)
                current_slot = 1
                feed_count = self.alimentacao.get('feeds_per_session', 5)

                # Pular o resto da l√≥gica - j√° foi executada automaticamente
                skip_manual_feeding = True
            else:
                # MODO MANUAL - Usar l√≥gica original
                # Abrir ba√∫
                self.open_chest()
                time.sleep(1)

                # Obter posi√ß√µes do slot atual
                slot_pos = self.alimentacao['slot_positions'][current_slot]
                eat_pos = self.alimentacao['eat_position']
                feed_count = self.alimentacao['feeds_per_session']
                skip_manual_feeding = False

                # Verificar se h√° comida no slot antes de tentar comer
                print(f"üîç Verificando se h√° comida no Slot {current_slot}: {slot_pos}")
                has_food, food_type = self.detect_food_in_slot(slot_pos)

                if not has_food:
                    print(f"‚ùå Slot {current_slot} est√° vazio! Tentando outro slot...")
                    # Tentar o outro slot
                    other_slot = 2 if current_slot == 1 else 1
                    other_slot_pos = self.alimentacao['slot_positions'][other_slot]
                    print(f"üîç Verificando Slot alternativo {other_slot}: {other_slot_pos}")
                    has_food, food_type = self.detect_food_in_slot(other_slot_pos)

                    if has_food:
                        print(f"‚úÖ Comida encontrada no Slot {other_slot}: {food_type}")
                        current_slot = other_slot
                        slot_pos = other_slot_pos
                    else:
                        print("‚ùå Ambos os slots est√£o vazios! Pulando alimenta√ß√£o...")
                        return
                else:
                    print(f"‚úÖ Comida confirmada no Slot {current_slot}: {food_type}")

                print(f"üéØ Usando Slot {current_slot}: {slot_pos}")

                # Clicar na comida do slot atual - COM FALLBACK
                try:
                    if hasattr(self, 'optimized_click'):
                        self.optimized_click(slot_pos[0], slot_pos[1])
                    else:
                        print("‚ö†Ô∏è [FALLBACK] Usando pyautogui.click ao inv√©s de optimized_click")
                        pyautogui.click(slot_pos[0], slot_pos[1])
                except Exception as e:
                    print(f"‚ùå Erro no clique da comida: {e}")
                    print("üîß [FALLBACK] Tentando com pyautogui.click...")
                    pyautogui.click(slot_pos[0], slot_pos[1])
                time.sleep(0.3)

            # üçñ EXECU√á√ÉO DOS CLIQUES DE ALIMENTA√á√ÉO
            if not skip_manual_feeding:
                # Modo slots fixos - executar cliques manuais
                print("üçΩÔ∏è Executando alimenta√ß√£o manual (slots fixos)...")
                for i in range(feed_count):
                    # Clique para comer - COM FALLBACK
                    try:
                        if hasattr(self, 'optimized_click'):
                            self.optimized_click(eat_pos[0], eat_pos[1])
                        else:
                            print(f"‚ö†Ô∏è [FALLBACK #{i+1}] Usando pyautogui.click para comer")
                            pyautogui.click(eat_pos[0], eat_pos[1])
                    except Exception as e:
                        print(f"‚ùå Erro no clique para comer #{i+1}: {e}")
                        print("üîß [FALLBACK] Tentando com pyautogui.click...")
                        pyautogui.click(eat_pos[0], eat_pos[1])

                    time.sleep(1.5)
                    print(f"   üçñ Comida {i+1}/{feed_count} (Slot {current_slot})")
            else:
                # Modo autom√°tico - cliques j√° foram executados
                print("üîÑ Alimenta√ß√£o autom√°tica j√° executada - pulando cliques manuais")

            # Atualizar contador do slot usado
            if current_slot == 1:
                self.alimentacao['slot1_uses'] += feed_count
            else:
                self.alimentacao['slot2_uses'] += feed_count

            # Atualizar tempo da √∫ltima alimenta√ß√£o
            self.alimentacao['last_feed_time'] = time.time()

            # CORRE√á√ÉO: Aguardar 1 segundo antes de fechar ba√∫ ap√≥s √∫ltima comida
            print("‚è≥ Aguardando 1s ap√≥s √∫ltima comida...")
            time.sleep(1.0)

            # üîß OTIMIZA√á√ÉO: Verificar e fazer manuten√ß√£o de varas j√° que ba√∫ est√° aberto
            print("\nüîß [OTIMIZA√á√ÉO] Verificando estado das varas ap√≥s alimenta√ß√£o...")
            maintenance_needed = self.check_and_maintain_rods_after_cleanup()

            # Fechar ba√∫ (ap√≥s manuten√ß√£o)
            self.close_inventory_with_delay("Auto opera√ß√£o")

            if maintenance_needed:
                print("üîß [OTIMIZA√á√ÉO] Manuten√ß√£o de varas realizada durante alimenta√ß√£o!")
            else:
                print("‚úÖ [OTIMIZA√á√ÉO] Todas as varas est√£o OK, nenhuma manuten√ß√£o necess√°ria")

            print(f"‚úÖ Alimenta√ß√£o conclu√≠da! Slot {current_slot} usado {self.alimentacao[f'slot{current_slot}_uses']}/{max_uses} vezes")

        except Exception as e:
            print(f"‚ùå Erro na alimenta√ß√£o: {e}")
            # Garantir que invent√°rio seja fechado em caso de erro
            try:
                pyautogui.press('tab')
            except:
                pass
        finally:
            # CR√çTICO: Sempre limpar estado ao finalizar
            self.game_state['action_in_progress'] = False
            self.game_state['feeding_active'] = False
            print("üçñ Estado de alimenta√ß√£o finalizado")

    def execute_feeding_and_cleaning_combined(self):
        """üçñüßπ OTIMIZADO: Executar alimenta√ß√£o + limpeza com um s√≥ ba√∫ aberto"""
        print("üçñüßπ [COMBINADO] Iniciando alimenta√ß√£o + limpeza otimizada...")

        # CR√çTICO: Marcar a√ß√£o em progresso para bloquear pesca
        self.game_state['action_in_progress'] = True
        self.game_state['feeding_active'] = True
        self.game_state['cleaning_active'] = True

        try:
            # Garantir que jogo est√° pronto
            self.ensure_game_ready_for_fishing()

            # PASSO 1: Abrir ba√∫ UMA √öNICA VEZ
            print("üì¶ [OTIMIZADO] Abrindo ba√∫ para alimenta√ß√£o + limpeza...")
            success = self.open_chest()

            if not success:
                print("‚ùå Falha ao abrir ba√∫ para opera√ß√£o combinada")
                return

            time.sleep(2)  # Aguardar ba√∫ abrir completamente

            # PASSO 2: ALIMENTA√á√ÉO PRIMEIRO (prioridade)
            print("üçñ [1/2] EXECUTANDO ALIMENTA√á√ÉO...")

            # Verificar modo de alimenta√ß√£o
            feeding_mode = self.alimentacao.get('feeding_mode', 'slots_fixos')

            if feeding_mode == 'detecao_auto':
                print("üîç Modo detec√ß√£o autom√°tica ativo...")
                food_detected = self.find_and_click_food_automatically()
                if food_detected:
                    print("‚úÖ Alimenta√ß√£o autom√°tica conclu√≠da!")
                else:
                    print("‚ö†Ô∏è Nenhuma comida detectada automaticamente")
            else:
                # Modo manual - usar l√≥gica simplificada (ba√∫ j√° est√° aberto)
                print("üéØ Modo slots fixos ativo...")
                current_slot = self.alimentacao['current_slot']
                slot_pos = self.alimentacao['slot_positions'][current_slot]
                eat_pos = self.alimentacao['eat_position']
                feed_count = self.alimentacao['feeds_per_session']

                # Clicar na comida
                pyautogui.click(slot_pos[0], slot_pos[1])
                time.sleep(0.5)

                # Loop de alimenta√ß√£o
                for i in range(feed_count):
                    pyautogui.click(eat_pos[0], eat_pos[1])
                    time.sleep(1.5)
                    print(f"   üçñ Comida {i+1}/{feed_count}")

                # Atualizar contadores
                if current_slot == 1:
                    self.alimentacao['slot1_uses'] += feed_count
                else:
                    self.alimentacao['slot2_uses'] += feed_count

                print(f"‚úÖ Alimenta√ß√£o manual conclu√≠da! Slot {current_slot} usado")

            # PASSO 3: LIMPEZA EM SEGUIDA (ba√∫ ainda aberto)
            print("üßπ [2/2] EXECUTANDO LIMPEZA...")

            # Re-detectar objetos para limpeza
            detections = self.detect_objects()

            # Transferir peixes (esquerda ‚Üí direita)
            fish_classes = ['anchova', 'aranque', 'salmao', 'sardinha', 'truta', 'smalltrout', 'tubarao', 'parca', 'file de peixe',
                           'scrap', 'sinalizador', 'cartao_azul', 'flare', 'bluecard',
                           'bullet', 'bala', 'municao', 'bone', 'bonefrag', 'osso', 'fat', 'gordura']
            fish_transferred = 0

            for detection in detections:
                if detection['class'] in fish_classes and detection['x'] < 1242:
                    print(f"üêü Transferindo {detection['class']} para ba√∫")
                    pyautogui.rightClick(detection['center_x'], detection['center_y'])
                    time.sleep(0.3)
                    fish_transferred += 1

            # REMOVIDO: Coletar iscas - desnecess√°rio durante limpeza
            
            print(f"‚úÖ Limpeza conclu√≠da: {fish_transferred} peixes transferidos para o ba√∫")

            # PASSO 4: Aguardar 1s e fechar ba√∫
            time.sleep(1.0)
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # Atualizar contadores
            self.alimentacao['last_feed_time'] = time.time()
            self.auto_clean['fish_count_since_last'] = 0
            self.auto_clean['real_fish_caught'] = 0  # Resetar contador real tamb√©m
            self.auto_clean['last_clean_time'] = time.time()
            print(f"üîÑ [ALIMENTA√á√ÉO] Contadores resetados: fish_count=0, real_fish=0")

            print("üéâ [OTIMIZADO] Alimenta√ß√£o + Limpeza combinada conclu√≠da com sucesso!")

        except Exception as e:
            print(f"‚ùå Erro na opera√ß√£o combinada: {e}")
            try:
                pyautogui.press('tab')
            except:
                pass
        finally:
            # CR√çTICO: Sempre limpar estados ao finalizar
            self.game_state['action_in_progress'] = False
            self.game_state['feeding_active'] = False
            self.game_state['cleaning_active'] = False
            self.auto_clean['in_progress'] = False
            print("üçñüßπ Estados de alimenta√ß√£o + limpeza finalizados")

    def abrir_interface(self):
        """Abrir interface"""
        if not hasattr(self, 'ui') or not self.ui or not self.ui.is_alive():
            print("üöÄ Abrindo interface...")
            try:
                self.ui = SimpleFishingUI(self)
                # Garantir que a janela seja exibida
                self.ui.main_window.deiconify()
                self.ui.main_window.lift()
                self.ui.main_window.focus_force()
                self.ui.main_window.attributes('-topmost', True)
                self.ui.main_window.attributes('-topmost', False)
                print("‚úÖ Interface aberta!")
            except Exception as e:
                print(f"‚ùå Erro na interface: {e}")
                import traceback
                traceback.print_exc()
                self.ui = None
        else:
            try:
                # Trazer janela para frente
                self.ui.main_window.deiconify()
                self.ui.main_window.lift()
                self.ui.main_window.focus_force()
                print("‚úÖ Interface restaurada!")
            except Exception as e:
                print(f"‚ùå Erro ao restaurar interface: {e}")

    def setup_hotkeys(self):
        """Configurar hotkeys globais"""
        print("üéÆ Configurando hotkeys globais...")
        try:
            # Hotkeys principais
            print("   Registrando F9 (start)...")
            keyboard.add_hotkey('f9', self.start)
            print("   Registrando F2 (pause)...")
            keyboard.add_hotkey('f2', self.pause_bot)
            print("   Registrando F1 (stop)...")
            keyboard.add_hotkey('f1', self.stop)
            keyboard.add_hotkey('f4', self.abrir_interface)

            # Hotkeys de macros
            keyboard.add_hotkey('f8', self.play_recorded_macro)
            keyboard.add_hotkey('f11', self.open_chest_macro)
            keyboard.add_hotkey('f3', self.toggle_macro_recording)

            # Hotkeys de teste
            keyboard.add_hotkey('f12', self.test_mouse_movement)
            keyboard.add_hotkey('f10', self.capture_chest_position)
            keyboard.add_hotkey('f6', self.f6_feeding_handler)
            keyboard.add_hotkey('f5', self.test_auto_clean_hotkey)
            keyboard.add_hotkey('f7', self.test_camera_turn)

            # Hotkeys combinadas
            keyboard.add_hotkey('0', lambda: self.auto_rod_maintenance_system())  # Mudado de shift+f3 para 0
            keyboard.add_hotkey('ctrl+f7', self.calibrate_camera_movement)
            keyboard.add_hotkey('ctrl+f3', self.real_macro_recording)
            keyboard.add_hotkey('ctrl+f11', self.show_yolo_detection_viewer)
            keyboard.add_hotkey('ctrl+f9', self.toggle_anti_detection)  # Alternar anti-detec√ß√£o
            keyboard.add_hotkey('ctrl+f12', self.test_normalization_system)  # Testar normaliza√ß√£o

            # PANIC KEYS - PRIORIDADE M√ÅXIMA
            keyboard.add_hotkey('esc', self.full_emergency_stop)  # ESC pausa TUDO
            keyboard.add_hotkey('alt+tab', self.emergency_complete_stop)  # ALT+TAB para tudo completamente
            keyboard.add_hotkey('home', self.panic_exit)  # HOME fecha o programa
            keyboard.add_hotkey('ctrl+alt+f', lambda: toggle_auto_focus())  # CTRL+ALT+F para alternar foco
            keyboard.add_hotkey('ctrl+tab', lambda: enable_auto_focus())  # CTRL+TAB para reabilitar auto-focus
            keyboard.add_hotkey('del', self.clear_macro_cache)  # DEL limpa TODOS os caches
            keyboard.add_hotkey('ctrl+del', lambda: self.auto_clear_cache_on_error("manual_hotkey"))  # CTRL+DEL auto-limpeza
            keyboard.add_hotkey('ctrl+f10', self.setup_default_macros)  # Reconfigurar macros padr√£o
            keyboard.add_hotkey('ctrl+shift+f10', self.edit_default_macros)  # Editor de macros
            keyboard.add_hotkey('shift+f12', self.test_coordination_system)  # Testar sistema de coordena√ß√£o
            keyboard.add_hotkey('shift+f11', self.test_templates_system)   # Testar sistema de templates
            keyboard.add_hotkey('shift+f10', self.test_rod_in_hand_detection)  # Testar detec√ß√£o vara na m√£o

            print("‚å®Ô∏è Hotkeys configurados:")
            print("   F9 - Iniciar | F2 - Pausar | F1 - Parar | ESC - PARADA DE EMERG√äNCIA")
            print("   F4 - Interface | F5 - Testar Limpeza")
            print("   Shift+F12 - Testar Coordena√ß√£o | Shift+F11 - Testar Templates | Shift+F10 - Testar Vara na M√£o")
            print("   F3 - Macro Inteligente | 0 - Manuten√ß√£o de Varas")
            print("   F6 - Alimenta√ß√£o Manual | F7 - Testar C√¢mera | F8 - Executar Macro")
            print("   F10 - Capturar Ba√∫ | F11 - Testar Ba√∫ | F12 - Testar Mouse")
            print("   Ctrl+F7 - Calibrar Movimento | Ctrl+F9 - Alternar Anti-Detec√ß√£o")
            print("   Ctrl+F10 - Reconfigurar Macros | Ctrl+F11 - Visualizar YOLO")
            print("   Ctrl+F12 - Testar Sistema de Normaliza√ß√£o")
            print("   ALT+TAB - Parada COMPLETA + Desabilita auto-focus")
            print("   CTRL+ALT+F - Alternar foco autom√°tico")
            print("   CTRL+TAB - Reabilitar auto-focus")
            print("   DEL - Limpar TODOS os caches | CTRL+DEL - Auto-limpeza inteligente")
            
            print("‚úÖ Hotkeys configurados com sucesso!")
            print("üß™ TESTE: Pressione F2 para verificar se as hotkeys funcionam...")
            print("üí° DICA: Use ALT+TAB para sair do jogo sem voltar automaticamente")
            print("üí° DICA: Use CTRL+TAB para reabilitar auto-focus ao voltar para o jogo")
            print("üí° DICA: Use DEL se bot estiver falhando (limpa cache) ou CTRL+DEL para auto-limpeza")
            
            # Teste imediato das hotkeys
            import threading
            def hotkey_monitor():
                try:
                    print("üîç Monitor de hotkeys ativo...")
                    keyboard.wait()  # Manter o thread ativo para hotkeys
                except:
                    pass
            
            monitor_thread = threading.Thread(target=hotkey_monitor, daemon=True)
            monitor_thread.start()

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao configurar hotkeys: {e}")
            print("üí° Tente executar como administrador se as hotkeys n√£o funcionarem")

    def open_chest_macro(self):
        """Abrir ba√∫ com macro padr√£o - F11 (COM MOVIMENTO VERTICAL)"""
        print("\n" + "="*50)
        print("üì¶ ABRINDO BA√ö - MACRO MELHORADO F11")
        print("="*50)

        # Carregar configura√ß√µes atuais
        chest_side = self.config.get('chest_side', 'left')
        chest_distance = self.config.get('chest_distance', 1200)
        chest_vertical = self.config.get('chest_vertical_offset', 200)

        print(f"üìã Configura√ß√£o:")
        print(f"   üß≠ Lado: {chest_side}")
        print(f"   üìè Dist√¢ncia horizontal: {chest_distance}px")
        print(f"   üìê Dist√¢ncia vertical: {chest_vertical}px")

        try:
            # Sequ√™ncia melhorada com verifica√ß√£o completa
            print("\n‚ñ∂Ô∏è Executando sequ√™ncia de abertura...")

            # 0. Liberar bot√µes do mouse PRIMEIRO
            release_mouse_buttons()

            # 1. Centralizar c√¢mera - usar posi√ß√£o inicial do F9
            initial_pos = self.config.get('initial_camera_pos')
            if initial_pos:
                center_camera((initial_pos['x'], initial_pos['y']))
            else:
                center_camera()

            # 2. ALT Down
            print("   2Ô∏è‚É£ ALT Down")
            pyautogui.keyDown('alt')
            time.sleep(0.5)

            # 3. Calcular movimento combinado (horizontal + vertical)
            print(f"   3Ô∏è‚É£ Movendo c√¢mera...")

            # Determinar DX baseado no lado
            if chest_side == 'left':
                dx = -chest_distance
            elif chest_side == 'right':
                dx = chest_distance
            else:
                dx = 0

            # DY sempre positivo para baixo (ba√∫ geralmente est√° abaixo)
            dy = abs(chest_vertical)

            print(f"      Movimento: DX={dx}, DY={dy}")

            # Executar movimento combinado
            if dx != 0 or dy != 0:
                camera_turn_in_game(dx, dy)
                print("   ‚úÖ C√¢mera movida com sucesso!")

            time.sleep(0.3)

            # 4. Tecla E
            print("   4Ô∏è‚É£ Pressionando E")
            pyautogui.press('e')
            time.sleep(0.5)

            # 5. ALT Up
            print("   5Ô∏è‚É£ ALT Up")
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')

            print("\n‚úÖ SEQU√äNCIA COMPLETA EXECUTADA!")
            print("üì¶ Ba√∫ deve estar aberto!")

        except Exception as e:
            print(f"‚ùå Erro na execu√ß√£o: {e}")
            # Garantir que ALT seja solto em caso de erro
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
            except:
                pass
        finally:
            print("="*50)

    def test_chest_opening(self):
        """Testar abertura de ba√∫ com logs detalhados (F11)"""
        print("\n" + "="*60)
        print("üß™ TESTE DE ABERTURA DE BA√ö - F11")
        print("="*60)

        try:
            # Logs de configura√ß√£o
            chest_side = self.config.get('chest_side', 'left')
            print(f"üìã Configura√ß√£o atual do ba√∫: {chest_side}")
            print(f"üìã Posi√ß√£o inicial do mouse: {pyautogui.position()}")

            # Contagem regressiva
            print("‚è≥ Iniciando em 3 segundos...")
            for i in range(3, 0, -1):
                print(f"   {i}...")
                time.sleep(1)

            print("üöÄ Iniciando processo de abertura!")

            # PASSO 1: ALT pressionado
            print("üîë PASSO 1: Pressionando ALT...")
            inicio_passo = time.time()
            pyautogui.keyDown('alt')
            print(f"   ‚úÖ ALT pressionado (tecla mantida)")

            time.sleep(0.1)
            tempo_passo1 = time.time() - inicio_passo
            print(f"   ‚è±Ô∏è Tempo do passo 1: {tempo_passo1:.3f}s")

            # PASSO 2: Movimento do mouse
            print(f"\nüñ±Ô∏è PASSO 2: Movendo mouse para {chest_side}...")
            inicio_passo = time.time()
            pos_antes = pyautogui.position()
            print(f"   üìç Posi√ß√£o antes: {pos_antes}")

            # Calcular posi√ß√£o alvo baseada no lado do ba√∫
            move_distance = self.config.get('chest_distance', 300)  # Configur√°vel

            if chest_side == 'left':
                target_pos = (pos_antes.x - move_distance, pos_antes.y)
                print(f"   ‚¨ÖÔ∏è Movendo {move_distance}px para ESQUERDA do personagem")
                print(f"   üéØ Posi√ß√£o alvo calculada: {target_pos}")
            else:
                target_pos = (pos_antes.x + move_distance, pos_antes.y)
                print(f"   ‚û°Ô∏è Movendo {move_distance}px para DIREITA do personagem")
                print(f"   üéØ Posi√ß√£o alvo calculada: {target_pos}")

            # Mover para posi√ß√£o absoluta (n√£o relativa)
            print("   üñ±Ô∏è Executando movimento...")
            pyautogui.moveTo(target_pos[0], target_pos[1])

            pos_depois = pyautogui.position()
            print(f"   üìç Posi√ß√£o depois: {pos_depois}")
            print(f"   üìè Movimento real: ({pos_depois[0] - pos_antes[0]}, {pos_depois[1] - pos_antes[1]})")
            print(f"   ‚úÖ Movimento {'bem-sucedido' if abs(pos_depois[0] - target_pos[0]) < 5 else 'com desvio'}")

            time.sleep(0.1)
            tempo_passo2 = time.time() - inicio_passo
            print(f"   ‚è±Ô∏è Tempo do passo 2: {tempo_passo2:.3f}s")

            # PASSO 3: Pressionar E
            print("\n‚å®Ô∏è PASSO 3: Pressionando tecla E...")
            inicio_passo = time.time()
            print("   üéØ Tentando interagir com ba√∫...")
            pyautogui.press('e')
            print("   ‚úÖ Tecla E pressionada e solta")

            print("   ‚è≥ Aguardando 300ms para ba√∫ abrir...")
            time.sleep(0.3)
            tempo_passo3 = time.time() - inicio_passo
            print(f"   ‚è±Ô∏è Tempo do passo 3: {tempo_passo3:.3f}s")

            # PASSO 4: Soltar ALT
            print("\nüîì PASSO 4: Soltando ALT...")
            inicio_passo = time.time()
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')
            print("   ‚úÖ ALT solto (tecla liberada)")
            tempo_passo4 = time.time() - inicio_passo
            print(f"   ‚è±Ô∏è Tempo do passo 4: {tempo_passo4:.3f}s")

            # PASSO 5: Verifica√ß√£o com YOLO (INVENT√ÅRIO + BARRIL)
            print("\nüîç PASSO 5: Verificando abertura com YOLO...")
            inicio_verificacao = time.time()

            if self.yolo_model and self.sct:
                print("   ü§ñ YOLO ativo - Detectando objetos...")
                print("   ‚è≥ Aguardando anima√ß√µes (500ms)...")
                time.sleep(0.5)

                detections = self.detect_objects()
                print(f"   üìä {len(detections)} objetos detectados")

                # Procurar por AMBOS: inventario aberto + barril aberto
                inventario_aberto = False
                barril_aberto = False

                print("   üîç Analisando detec√ß√µes:")
                for detection in detections:
                    print(f"      ‚Ä¢ {detection['class']} (conf: {detection['confidence']:.2f}) - {detection['center']}")

                    if detection['class'] == 'inventario aberto':
                        inventario_aberto = True
                        print("      ‚úÖ INVENT√ÅRIO ABERTO confirmado!")
                    elif detection['class'] == 'barril aberto':
                        barril_aberto = True
                        print("      ‚úÖ BARRIL ABERTO confirmado!")

                # Avaliar resultado
                print(f"\n   üìã RESULTADO DA DETEC√á√ÉO:")
                print(f"      üì¶ Invent√°rio aberto: {'‚úÖ SIM' if inventario_aberto else '‚ùå N√ÉO'}")
                print(f"      üóÉÔ∏è Barril aberto: {'‚úÖ SIM' if barril_aberto else '‚ùå N√ÉO'}")

                if inventario_aberto and barril_aberto:
                    print("   üèÜ SUCESSO TOTAL: Ambos detectados!")
                    sucesso_completo = True
                elif inventario_aberto or barril_aberto:
                    print("   ‚ö†Ô∏è SUCESSO PARCIAL: Apenas um detectado")
                    sucesso_completo = False
                else:
                    print("   ‚ùå FALHA TOTAL: Nenhum detectado")
                    sucesso_completo = False
                    print("      üí° Poss√≠veis causas:")
                    print("         ‚Ä¢ Ba√∫ n√£o abriu")
                    print("         ‚Ä¢ Confian√ßa muito alta")
                    print("         ‚Ä¢ Posi√ß√£o incorreta")
                    print("         ‚Ä¢ Timing insuficiente")
            else:
                print("   ‚ùå YOLO n√£o dispon√≠vel - n√£o √© poss√≠vel verificar")
                sucesso_completo = None

            tempo_verificacao = time.time() - inicio_verificacao
            print(f"   ‚è±Ô∏è Tempo de verifica√ß√£o: {tempo_verificacao:.3f}s")

            # Resumo final
            tempo_total = time.time() - inicio_passo
            print(f"\nüìä RESUMO DO TESTE:")
            print(f"   ‚è±Ô∏è Tempo total: {tempo_total:.3f}s")
            print(f"   üîß Configura√ß√£o: ba√∫ na {chest_side}")
            print(f"   üìè Dist√¢ncia configurada: {move_distance}px")
            print(f"   üìç Posi√ß√£o final mouse: {pyautogui.position()}")

            if self.yolo_model and sucesso_completo == True:
                print("   üèÜ RESULTADO: SUCESSO COMPLETO! (Invent√°rio + Barril)")
            elif self.yolo_model and sucesso_completo == False:
                print("   ‚ö†Ô∏è RESULTADO: SUCESSO PARCIAL (Apenas 1 detectado)")
            elif self.yolo_model and sucesso_completo is None:
                print("   ‚ùå RESULTADO: FALHA COMPLETA (Nada detectado)")
            else:
                print("   ‚ÑπÔ∏è RESULTADO: PROCESSO EXECUTADO (SEM VERIFICA√á√ÉO YOLO)")

        except Exception as e:
            print(f"‚ùå ERRO durante teste: {e}")
            # Garantir que ALT seja solto em caso de erro
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
                print("üîß ALT for√ßadamente liberado por seguran√ßa")
            except:
                pass

        finally:
            print("="*60)
            print("üèÅ TESTE DE ABERTURA DE BA√ö FINALIZADO")
            print("="*60)

    def test_mouse_movement(self):
        """Testar apenas movimento do mouse (F12)"""
        print("\n" + "="*50)
        print("üñ±Ô∏è TESTE DE MOVIMENTO DO MOUSE - F12")
        print("="*50)

        try:
            # Configura√ß√µes
            chest_side = self.config.get('chest_side', 'left')
            move_distance = self.config.get('chest_distance', 300)

            print(f"üìã Configura√ß√£o: {chest_side} | Dist√¢ncia: {move_distance}px")

            # Posi√ß√£o inicial
            pos_inicial = pyautogui.position()
            print(f"üìç Posi√ß√£o inicial: {pos_inicial}")

            # Contagem
            for i in range(3, 0, -1):
                print(f"   {i}...")
                time.sleep(1)

            # Calcular posi√ß√£o alvo
            if chest_side == 'left':
                target_pos = (pos_inicial.x - move_distance, pos_inicial.y)
                direcao = "ESQUERDA"
            else:
                target_pos = (pos_inicial.x + move_distance, pos_inicial.y)
                direcao = "DIREITA"

            print(f"üéØ Alvo: {target_pos} ({direcao})")

            # TESTE 1: Fun√ß√£o robusta force_mouse_move
            print("\nüß™ TESTE 1: force_mouse_move() - Movimento robusto")
            success = force_mouse_move(target_pos[0], target_pos[1])
            pos_robust = pyautogui.position()
            print(f"   üìç Resultado: {pos_robust}")
            print(f"   üìè Diferen√ßa: ({pos_robust.x - pos_inicial.x}, {pos_robust.y - pos_inicial.y})")
            print(f"   ‚úÖ Status: {'Sucesso' if success else 'Falha'}")

            time.sleep(2)

            # Voltar ao centro para pr√≥ximo teste
            pyautogui.moveTo(pos_inicial.x, pos_inicial.y)
            time.sleep(1)

            # TESTE 2: pyautogui.moveTo normal para compara√ß√£o
            print("\nüß™ TESTE 2: pyautogui.moveTo() - M√©todo tradicional")
            pyautogui.moveTo(target_pos[0], target_pos[1])
            pos_traditional = pyautogui.position()
            print(f"   üìç Resultado: {pos_traditional}")
            print(f"   üìè Diferen√ßa: ({pos_traditional.x - pos_inicial.x}, {pos_traditional.y - pos_inicial.y})")
            traditional_success = abs(pos_traditional.x - target_pos[0]) < 10 and abs(pos_traditional.y - target_pos[1]) < 10
            print(f"   ‚úÖ Status: {'Sucesso' if traditional_success else 'Falha'}")

            time.sleep(2)

            # Voltar √† posi√ß√£o inicial
            pyautogui.moveTo(pos_inicial.x, pos_inicial.y)

            # Resumo
            print(f"\nüìä RESUMO DOS TESTES:")
            print(f"   üéØ Alvo esperado: {target_pos}")
            print(f"   üìç force_mouse_move() chegou em: {pos_robust}")
            print(f"   üìç moveTo() chegou em: {pos_traditional}")

            sucesso_robust = abs(pos_robust.x - target_pos[0]) <= 5
            sucesso_traditional = abs(pos_traditional.x - target_pos[0]) <= 5

            print(f"   ‚úÖ force_mouse_move() funcionou: {'SIM' if sucesso_robust else 'N√ÉO'}")
            print(f"   ‚úÖ moveTo() funcionou: {'SIM' if sucesso_traditional else 'N√ÉO'}")

            if sucesso_robust:
                print("   üí° RECOMENDA√á√ÉO: Usar force_mouse_move() - mais robusto")
            elif sucesso_traditional:
                print("   üí° RECOMENDA√á√ÉO: Usar moveTo() - funcionou")
            else:
                print("   ‚ö†Ô∏è PROBLEMA: Ambos falharam - verificar sistema")

        except Exception as e:
            print(f"‚ùå ERRO no teste: {e}")

        finally:
            print("="*50)
            print("üèÅ TESTE DE MOVIMENTO FINALIZADO")
            print("="*50)

    def capture_chest_position(self):
        """Capturar posi√ß√£o do ba√∫ - F10 (GRAVAR MACRO PERSONALIZADO)"""
        print("\n" + "="*50)
        print("üì¶ F10 - GRAVAR MACRO PERSONALIZADO")
        print("="*50)

        # Verificar lado selecionado na UI
        chest_side = self.config.get('chest_side', 'left')

        print("üìã INSTRU√á√ïES:")
        print(f"   Gravando macro PERSONALIZADO para lado: {chest_side.upper()}")
        print("   Este macro substituir√° o personalizado anterior!")
        print("")
        print(f"üéØ GRAVANDO PARA {chest_side.upper()}...")
        print("   1. Posicione o mouse no CENTRO da tela")
        print("   2. Aguarde 3 segundos")
        print(f"   3. Mova para o ba√∫ da {chest_side.upper()}")

        # Esperar posicionamento inicial
        print("\n‚è≥ Posicione no CENTRO em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        # Capturar posi√ß√£o inicial
        start_pos = pyautogui.position()
        print(f"\nüìç Posi√ß√£o inicial: ({start_pos.x}, {start_pos.y})")

        print(f"\nüéØ MOVA para o BA√ö da {chest_side.upper()} em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        # Capturar posi√ß√£o final
        end_pos = pyautogui.position()
        print(f"üì¶ Posi√ß√£o {chest_side}: ({end_pos.x}, {end_pos.y})")

        # Calcular movimento
        dx = end_pos.x - start_pos.x
        dy = end_pos.y - start_pos.y

        print(f"\nüìπ MOVIMENTO CALCULADO:")
        print(f"   DX = {dx} pixels")
        print(f"   DY = {dy} pixels")
        print(f"   Dist√¢ncia = {int((dx**2 + dy**2)**0.5)} pixels")

        # Criar macro personalizado
        actions = [
            {'type': 'key', 'key': 'alt_down', 'time': 0.0},
            {'type': 'wait', 'duration': 0.5, 'time': 0.5},
            {'type': 'camera_move', 'dx': dx, 'dy': dy, 'time': 1.0},
            {'type': 'wait', 'duration': 0.3, 'time': 1.3},
            {'type': 'key', 'key': 'e', 'time': 1.6},
            {'type': 'wait', 'duration': 0.5, 'time': 2.1},
            {'type': 'key', 'key': 'alt_up', 'time': 2.6}
        ]

        # Salvar macro personalizado
        try:
            with open('recorded_macro.pkl', 'wb') as f:
                pickle.dump(actions, f)

            with open('recorded_macro.txt', 'w', encoding='utf-8') as f:
                f.write("# MACRO PERSONALIZADO - GRAVADO COM F10\n")
                f.write(f"# Lado: {chest_side}\n")
                f.write(f"# Movimento: DX={dx}, DY={dy}\n")
                f.write(f"# Total de a√ß√µes: {len(actions)}\n\n")
                for i, action in enumerate(actions):
                    f.write(f"{i+1:03d}: {action}\n")

            print("\n" + "="*50)
            print("‚úÖ MACRO PERSONALIZADO SALVO!")
            print("üìÅ recorded_macro.pkl - Macro personalizado")
            print("üìÅ recorded_macro.txt - Log do macro")
            print("")
            print("üí° Configure 'Tipo Macro: personalizado' na UI")
            print("üí° Use F8 para executar!")

            # Salvar na config
            self.config['custom_macro_dx'] = dx
            self.config['custom_macro_dy'] = dy
            self.config['custom_macro_side'] = chest_side

            # Salvar no arquivo
            try:
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao salvar configura√ß√£o: {e}")

        except Exception as e:
            print(f"‚ùå Erro ao salvar macro: {e}")

        print("="*50)

    def setup_default_macros(self):
        """Configurar macros padr√£o iniciais - Fun√ß√£o administrativa"""
        print("\n" + "="*50)
        print("‚öôÔ∏è CONFIGURA√á√ÉO INICIAL - MACROS PADR√ÉO")
        print("="*50)

        print("üìã Esta fun√ß√£o grava os macros padr√£o do sistema:")
        print("   üîµ left_macro.pkl - Para ba√∫s √† esquerda")
        print("   üî¥ right_macro.pkl - Para ba√∫s √† direita")
        print("   ‚ö†Ô∏è Estes N√ÉO ser√£o sobrescritos por F10!")
        print("")

        # Gravar macro para ESQUERDA
        print("üîµ GRAVANDO MACRO PADR√ÉO - ESQUERDA...")
        print("   1. Posicione o mouse no CENTRO da tela")
        print("   2. Aguarde 3 segundos")
        print("   3. Mova para o ba√∫ da ESQUERDA")

        print("\n‚è≥ Posicione no CENTRO em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        start_pos = pyautogui.position()
        print(f"\nüìç Posi√ß√£o inicial: ({start_pos.x}, {start_pos.y})")

        print("\nüéØ MOVA para o BA√ö da ESQUERDA em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        end_pos_left = pyautogui.position()
        dx_left = end_pos_left.x - start_pos.x
        dy_left = end_pos_left.y - start_pos.y

        print(f"üîµ Movimento ESQUERDA: DX={dx_left}, DY={dy_left}")

        # Gravar macro para DIREITA
        print("\n" + "="*30)
        print("üî¥ GRAVANDO MACRO PADR√ÉO - DIREITA...")
        print("="*30)

        print("\n‚è≥ Posicione no CENTRO novamente em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        start_pos2 = pyautogui.position()
        print(f"\nüìç Posi√ß√£o inicial: ({start_pos2.x}, {start_pos2.y})")

        print("\nüéØ MOVA para o BA√ö da DIREITA em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        end_pos_right = pyautogui.position()
        dx_right = end_pos_right.x - start_pos2.x
        dy_right = end_pos_right.y - start_pos2.y

        print(f"üî¥ Movimento DIREITA: DX={dx_right}, DY={dy_right}")

        # Criar e salvar macros padr√£o
        left_actions = [
            {'type': 'key', 'key': 'alt_down', 'time': 0.0},
            {'type': 'wait', 'duration': 0.5, 'time': 0.5},
            {'type': 'camera_move', 'dx': dx_left, 'dy': dy_left, 'time': 1.0},
            {'type': 'wait', 'duration': 0.3, 'time': 1.3},
            {'type': 'key', 'key': 'e', 'time': 1.6},
            {'type': 'wait', 'duration': 0.5, 'time': 2.1},
            {'type': 'key', 'key': 'alt_up', 'time': 2.6}
        ]

        right_actions = [
            {'type': 'key', 'key': 'alt_down', 'time': 0.0},
            {'type': 'wait', 'duration': 0.5, 'time': 0.5},
            {'type': 'camera_move', 'dx': dx_right, 'dy': dy_right, 'time': 1.0},
            {'type': 'wait', 'duration': 0.3, 'time': 1.3},
            {'type': 'key', 'key': 'e', 'time': 1.6},
            {'type': 'wait', 'duration': 0.5, 'time': 2.1},
            {'type': 'key', 'key': 'alt_up', 'time': 2.6}
        ]

        try:
            # Salvar macros padr√£o
            with open('left_macro.pkl', 'wb') as f:
                pickle.dump(left_actions, f)

            with open('right_macro.pkl', 'wb') as f:
                pickle.dump(right_actions, f)

            with open('left_macro.txt', 'w', encoding='utf-8') as f:
                f.write("# MACRO PADR√ÉO ESQUERDA\n")
                f.write(f"# Movimento: DX={dx_left}, DY={dy_left}\n")
                f.write(f"# Total de a√ß√µes: {len(left_actions)}\n\n")
                for i, action in enumerate(left_actions):
                    f.write(f"{i+1:03d}: {action}\n")

            with open('right_macro.txt', 'w', encoding='utf-8') as f:
                f.write("# MACRO PADR√ÉO DIREITA\n")
                f.write(f"# Movimento: DX={dx_right}, DY={dy_right}\n")
                f.write(f"# Total de a√ß√µes: {len(right_actions)}\n\n")
                for i, action in enumerate(right_actions):
                    f.write(f"{i+1:03d}: {action}\n")

            print("\n" + "="*50)
            print("‚úÖ MACROS PADR√ÉO CONFIGURADOS!")
            print("üìÅ left_macro.pkl - Macro padr√£o esquerda")
            print("üìÅ right_macro.pkl - Macro padr√£o direita")
            print("")
            print("üîí Estes macros s√£o PROTEGIDOS!")
            print("üí° F10 gravar√° apenas macros personalizados!")
            print("üí° F11 usar√° sempre os macros padr√£o!")

        except Exception as e:
            print(f"‚ùå Erro ao salvar macros padr√£o: {e}")

        print("="*50)

    def edit_default_macros(self):
        """Editar macros padr√£o manualmente - Ctrl+Shift+F10"""
        print("\n" + "="*50)
        print("‚úèÔ∏è EDITOR DE MACROS PADR√ÉO")
        print("="*50)

        # Verificar se macros existem
        left_exists = os.path.exists('left_macro.pkl')
        right_exists = os.path.exists('right_macro.pkl')

        print(f"üìÅ Status dos arquivos:")
        print(f"   left_macro.pkl: {'‚úÖ Existe' if left_exists else '‚ùå N√£o existe'}")
        print(f"   right_macro.pkl: {'‚úÖ Existe' if right_exists else '‚ùå N√£o existe'}")

        if not (left_exists and right_exists):
            print("\n‚ùå Macros padr√£o n√£o encontrados!")
            print("üí° Use Ctrl+F10 para criar os macros padr√£o primeiro!")
            return

        # Carregar macros atuais
        try:
            with open('left_macro.pkl', 'rb') as f:
                left_actions = pickle.load(f)
            with open('right_macro.pkl', 'rb') as f:
                right_actions = pickle.load(f)

            # Encontrar movimento atual
            left_dx = left_dy = right_dx = right_dy = 0
            for action in left_actions:
                if action['type'] == 'camera_move':
                    left_dx, left_dy = action['dx'], action['dy']
                    break
            for action in right_actions:
                if action['type'] == 'camera_move':
                    right_dx, right_dy = action['dx'], action['dy']
                    break

            print(f"\nüìä VALORES ATUAIS:")
            print(f"   üîµ Esquerda: DX={left_dx}, DY={left_dy}")
            print(f"   üî¥ Direita: DX={right_dx}, DY={right_dy}")

            print(f"\nüìù AJUSTES SUGERIDOS:")
            print(f"   Mais √† esquerda: diminuir DX (mais negativo)")
            print(f"   Mais √† direita: aumentar DX (mais positivo)")
            print(f"   Mais para baixo: aumentar DY (mais positivo)")
            print(f"   Mais para cima: diminuir DY (mais negativo)")

            print(f"\n‚úèÔ∏è EXEMPLO DE EDI√á√ÉO:")
            print(f"   Atual esquerda: DX={left_dx}")
            print(f"   Mais √† esquerda: DX={left_dx - 200}")
            print(f"   Atual baixo: DY={left_dy}")
            print(f"   Mais para baixo: DY={left_dy + 100}")

            print(f"\nüí° Para editar:")
            print(f"   1. Abra config.json no editor")
            print(f"   2. Procure por 'chest_distance' e 'chest_vertical_offset'")
            print(f"   3. Ou use Ctrl+F10 para regravar completamente")

        except Exception as e:
            print(f"‚ùå Erro ao carregar macros: {e}")

        print("="*50)

    def test_camera_turn(self):
        """Testar giro de c√¢mera - m√©todo correto para jogos FPS (F7)"""
        print("\n" + "="*50)
        print("üìπ TESTE DE GIRO DE C√ÇMERA - F7")
        print("="*50)

        chest_side = self.config.get('chest_side', 'left')
        intensity = self.config.get('chest_distance', 300)

        print(f"üìã Configura√ß√£o: {chest_side} | Intensidade: {intensity}px")
        print("üí° CONCEITO: Mouse drag simula movimento de c√¢mera em jogos FPS")
        print("üéÆ Personagem fica no centro, c√¢mera gira para os lados")

        print("\n‚è≥ Teste come√ßando em 3 segundos...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        try:
            print(f"\nüß™ TESTE: Girando c√¢mera para {chest_side.upper()}")

            # Teste de giro de c√¢mera
            success = camera_turn(chest_side, intensity)

            if success:
                print("‚úÖ SUCESSO: C√¢mera girou corretamente!")
                print("üí° Este √© o m√©todo correto para jogos!")
            else:
                print("‚ùå FALHA: Problema no giro de c√¢mera")

            time.sleep(2)

            # Teste de volta ao centro
            print(f"\nüß™ TESTE REVERSO: Voltando ao centro")
            reverse_direction = 'right' if chest_side == 'left' else 'left'
            reverse_success = camera_turn(reverse_direction, intensity)

            if reverse_success:
                print("‚úÖ SUCESSO: C√¢mera voltou ao centro!")
            else:
                print("‚ùå FALHA: Problema no retorno")

            print("\nüìä RESUMO DO TESTE:")
            print(f"   üéØ Dire√ß√£o configurada: {chest_side}")
            print(f"   üìè Intensidade: {intensity}px")
            print(f"   ‚úÖ Giro principal: {'OK' if success else 'FALHA'}")
            print(f"   ‚úÖ Retorno: {'OK' if reverse_success else 'FALHA'}")

            if success and reverse_success:
                print("\nüí° RECOMENDA√á√ÉO: Use este m√©todo no open_chest!")
            else:
                print("\n‚ö†Ô∏è PROBLEMA: Verifique configura√ß√µes do jogo")

        except Exception as e:
            print(f"‚ùå ERRO no teste: {e}")

        print("="*50)

    def calibrate_camera_movement(self):
        """Calibrar movimento da c√¢mera - Ctrl+F7"""
        print("\n" + "="*60)
        print("üéØ CALIBRA√á√ÉO DE MOVIMENTO DA C√ÇMERA - Ctrl+F7")
        print("="*60)

        print("üìã CONFIGURA√á√ÉO ATUAL:")
        chest_side = self.config.get('chest_side', 'left')
        current_intensity = self.config.get('chest_distance', 300)
        print(f"   üß≠ Lado do ba√∫: {chest_side}")
        print(f"   üìè Intensidade atual: {current_intensity}px")

        print("\nüéÆ TESTE DE DIFERENTES INTENSIDADES:")
        print("üí° Vamos testar v√°rias intensidades para encontrar a ideal!")

        intensities = [100, 200, 300, 400, 500, 600]

        for i, intensity in enumerate(intensities):
            print(f"\nüß™ TESTE {i+1}/6: Intensidade {intensity}px")
            print("‚è≥ Teste em 3 segundos...")

            for countdown in range(3, 0, -1):
                print(f"   {countdown}...")
                time.sleep(1)

            print(f"‚ñ∂Ô∏è Executando movimento com {intensity}px...")
            success = camera_turn(chest_side, intensity)

            if success:
                print("‚úÖ Movimento executado!")

                # Perguntar ao usu√°rio
                print(f"\n‚ùì Como ficou o movimento com {intensity}px?")
                print("   1 - Muito pouco (precisa mais)")
                print("   2 - Pouco (aumentar um pouco)")
                print("   3 - PERFEITO! (usar este)")
                print("   4 - Muito (diminuir)")
                print("   5 - Excessivo (muito forte)")

                # Aguardar resposta (simulado - em produ√ß√£o seria input)
                print("üí° Observe o movimento e compare com o ba√∫!")
                time.sleep(3)

                # Se for o valor atual, destacar
                if intensity == current_intensity:
                    print(f"‚≠ê Este √© o valor ATUAL configurado ({current_intensity}px)")

            time.sleep(2)  # Pausa entre testes

        print("\nüìä RESUMO DOS TESTES:")
        print("   100px - Movimento m√≠nimo")
        print("   200px - Movimento pequeno")
        print("   300px - Movimento m√©dio (PADR√ÉO)")
        print("   400px - Movimento grande")
        print("   500px - Movimento muito grande")
        print("   600px - Movimento m√°ximo")

        print("\nüîß PARA ALTERAR:")
        print("   1. Abra config.json")
        print("   2. Altere 'chest_distance': XXX")
        print("   3. Salve o arquivo")
        print("   4. Teste com F3 + F8")

        print("\nüí° DICAS:")
        print("   ‚Ä¢ Ba√∫ pr√≥ximo = 100-200px")
        print("   ‚Ä¢ Ba√∫ m√©dio = 300-400px")
        print("   ‚Ä¢ Ba√∫ distante = 500-600px")

        print("="*60)

    def real_macro_recording(self):
        """Grava√ß√£o REAL de suas a√ß√µes - Ctrl+F3"""
        print("\n" + "="*50)
        print("üé¨ GRAVA√á√ÉO REAL DE SUAS A√á√ïES - Ctrl+F3")
        print("="*50)
        print("‚ùå FUNCIONALIDADE EM DESENVOLVIMENTO!")
        print("")
        print("üìã DIFEREN√áAS:")
        print("   F3 = Macro AUTOM√ÅTICO (pr√©-programado)")
        print("   Ctrl+F3 = Grava√ß√£o REAL (suas a√ß√µes)")
        print("   Shift+F3 = Pulover (externa)")
        print("")
        print("üí° ATUALMENTE DISPON√çVEL:")
        print("   ‚Ä¢ F3 = Macro inteligente baseado em config")
        print("   ‚Ä¢ F8 = Executa macro criado")
        print("   ‚Ä¢ Shift+F3 = Pulover para grava√ß√£o real")
        print("")
        print("üîß RECOMENDA√á√ÉO:")
        print("   Use Shift+F3 (Pulover) para grava√ß√£o real")
        print("   Ou ajuste F3 + config.json para suas necessidades")
        print("="*50)

    def toggle_macro_recording(self):
        """Alternar grava√ß√£o de macro - F3 (SIMPLIFICADO E FUNCIONAL)"""
        print("\n" + "="*50)
        print("üî¥ F3 - GRAVAR MACRO PARA BA√ö")
        print("="*50)

        print("üìã INSTRU√á√ïES:")
        print("   1. Posicione o mouse no CENTRO da tela")
        print("   2. Aguarde 3 segundos")
        print("   3. Mova para onde est√° o ba√∫")
        print("   4. Macro ser√° criado automaticamente")

        # Esperar posicionamento inicial
        print("\n‚è≥ Posicione no CENTRO em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        # Capturar posi√ß√£o inicial
        start_pos = pyautogui.position()
        print(f"\nüìç Posi√ß√£o inicial: ({start_pos.x}, {start_pos.y})")

        print("\nüéØ MOVA para o BA√ö em...")
        for i in range(3, 0, -1):
            print(f"   {i}...")
            time.sleep(1)

        # Capturar posi√ß√£o final
        end_pos = pyautogui.position()
        print(f"üì¶ Posi√ß√£o do ba√∫: ({end_pos.x}, {end_pos.y})")

        # Calcular movimento
        dx = end_pos.x - start_pos.x
        dy = end_pos.y - start_pos.y

        print(f"\nüìπ MOVIMENTO CALCULADO:")
        print(f"   DX = {dx} pixels")
        print(f"   DY = {dy} pixels")
        print(f"   Dist√¢ncia = {int((dx**2 + dy**2)**0.5)} pixels")

        # Criar macro
        actions = [
            {'type': 'key', 'key': 'alt_down', 'time': 0.0},
            {'type': 'wait', 'duration': 0.5, 'time': 0.5},
            {'type': 'camera_move', 'dx': dx, 'dy': dy, 'time': 1.0},
            {'type': 'wait', 'duration': 0.3, 'time': 1.3},
            {'type': 'key', 'key': 'e', 'time': 1.6},
            {'type': 'wait', 'duration': 0.5, 'time': 2.1},
            {'type': 'key', 'key': 'alt_up', 'time': 2.6}
        ]

        # Salvar macro
        try:
            with open('recorded_macro.pkl', 'wb') as f:
                pickle.dump(actions, f)

            with open('recorded_macro.txt', 'w', encoding='utf-8') as f:
                f.write("# MACRO GRAVADO COM F3\n")
                f.write(f"# Movimento: DX={dx}, DY={dy}\n")
                f.write(f"# Total de a√ß√µes: {len(actions)}\n\n")
                for i, action in enumerate(actions):
                    f.write(f"{i+1:03d}: {action}\n")

            print("\n‚úÖ MACRO SALVO COM SUCESSO!")
            print("üí° Use F8 para executar!")

            # Salvar na config tamb√©m
            self.config['last_chest_dx'] = dx
            self.config['last_chest_dy'] = dy

            # Salvar no arquivo
            try:
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao salvar configura√ß√£o: {e}")

        except Exception as e:
            print(f"‚ùå Erro ao salvar: {e}")

        print("="*50)

    def play_recorded_macro(self):
        """Executar macro gravado - F8 (COM L√ìGICA DE MACRO PADR√ÉO)"""
        print("\n" + "="*50)
        print("‚ñ∂Ô∏è F8 - EXECUTAR MACRO AUTOM√ÅTICO")
        print("="*50)

        # Verificar configura√ß√µes
        macro_type = self.config.get('macro_type', 'padrao')
        chest_side = self.config.get('chest_side', 'left')

        print(f"üìã CONFIGURA√á√ÉO:")
        print(f"   Tipo Macro: {macro_type}")
        print(f"   Lado do Ba√∫: {chest_side}")
        print("")

        # VERIFICAR SE √â PERSONALIZADO
        if macro_type != 'personalizado':
            print("‚ùå ERRO: F8 s√≥ funciona com 'Tipo Macro: personalizado'!")
            print("üí° Para usar macros padr√£o, use F11 diretamente!")
            print("üí° Configure 'personalizado' na UI e grave com F10!")
            print("="*50)
            return

        # Usar macro personalizado
        macro_file = 'recorded_macro.pkl'
        txt_file = 'recorded_macro.txt'
        print("üé® USANDO MACRO PERSONALIZADO: recorded_macro.pkl")

        # Verificar se arquivo existe
        if not os.path.exists(macro_file):
            print(f"‚ùå ERRO: Arquivo {macro_file} n√£o encontrado!")
            if macro_type == 'padrao':
                print("üí° Use F10 para gravar os macros padr√£o!")
            else:
                print("üí° Use F3 para gravar um macro personalizado!")
            print("="*50)
            return

        # Carregar e mostrar informa√ß√µes do macro
        try:
            with open(macro_file, 'rb') as f:
                actions = pickle.load(f)
            print(f"üìä Macro carregado: {len(actions)} a√ß√µes")

            # Mostrar movimento do macro
            for action in actions:
                if action['type'] == 'camera_move':
                    dx = action['dx']
                    dy = action['dy']
                    distance = int((dx**2 + dy**2)**0.5)
                    print(f"üìπ Movimento: DX={dx}, DY={dy} (dist√¢ncia: {distance}px)")
                    break

        except Exception as e:
            print(f"‚ùå Erro ao ler macro: {e}")
            print("="*50)
            return

        # Executar macro melhorado
        print(f"\nüé¨ EXECUTANDO MACRO...")

        # Prepara√ß√£o inicial
        print("   üßπ Preparando...")
        try:
            # Liberar bot√µes do mouse PRIMEIRO (CR√çTICO!)
            release_mouse_buttons()

            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')  # Garantir ALT solto
            time.sleep(0.2)
            # REMOVIDO: ESC estava causando conflito com hotkey ESC
            # pyautogui.press('escape')  # Causava ativa√ß√£o do emergency stop
            # time.sleep(0.5)
            # Centralizar c√¢mera - usar posi√ß√£o inicial do F9
            initial_pos = self.config.get('initial_camera_pos')
            if initial_pos:
                center_camera((initial_pos['x'], initial_pos['y']))
            else:
                center_camera()
        except:
            pass

        try:
            # Delay inicial
            time.sleep(0.3)

            # Executar cada a√ß√£o
            for i, action in enumerate(actions):
                if action['type'] == 'key':
                    if action['key'] == 'alt_down':
                        print(f"   {i+1}. ALT Down")
                        focus_game_window()  # Garantir foco antes de pressionar ALT
                        pyautogui.keyDown('alt')
                        time.sleep(0.1)
                    elif action['key'] == 'alt_up':
                        print(f"   {i+1}. ALT Up")
                        time.sleep(0.1)
                        focus_game_window()  # Garantir foco
                        pyautogui.keyUp('alt')
                    elif action['key'] == 'e':
                        print(f"   {i+1}. Tecla E")
                        focus_game_window()  # Garantir foco antes de pressionar E
                        pyautogui.press('e')

                elif action['type'] == 'camera_move':
                    dx = action['dx']
                    dy = action['dy']
                    print(f"   {i+1}. Movimento c√¢mera: DX={dx}, DY={dy}")
                    camera_turn_in_game(dx, dy)

                elif action['type'] == 'wait':
                    duration = action['duration']
                    print(f"   {i+1}. Aguardar {duration}s")
                    time.sleep(duration)

            # Finaliza√ß√£o
            time.sleep(0.5)
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')  # Garantir ALT solto
            time.sleep(0.2)

            print("‚úÖ MACRO EXECUTADO COM SUCESSO!")

        except Exception as e:
            print(f"‚ùå ERRO NA EXECU√á√ÉO: {e}")
            # Limpeza de emerg√™ncia
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
            except:
                pass
            import traceback
            traceback.print_exc()

        print("="*50)

    def open_chest(self, purpose="geral"):
        """Abrir ba√∫ usando a configura√ß√£o atual COM coordena√ß√£o"""

        # üéØ USAR SISTEMA DE COORDENA√á√ÉO
        return self.request_operation(
            'chest_opening',
            lambda: self._protected_chest_opening(purpose),
            context=f"Abertura de ba√∫ - {purpose}"
        )

    def _protected_chest_opening(self, purpose="geral"):
        """üîí Abertura de ba√∫ protegida pelo sistema de coordena√ß√£o"""
        print(f"\nüîß ABRINDO BA√ö PROTEGIDO - {purpose.upper()}")

        # 1. PREPARA√á√ÉO - Garantir estado limpo
        print("   üßπ Preparando estado do jogo...")
        try:
            # Liberar bot√µes do mouse PRIMEIRO (CR√çTICO!)
            release_mouse_buttons()

            # Garantir que ALT n√£o est√° preso
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')
            time.sleep(0.2)

            # REMOVIDO: ESC estava causando conflito com hotkey ESC
            # pyautogui.press('escape')  # Causava ativa√ß√£o do emergency stop
            # time.sleep(0.5)

            # Centralizar c√¢mera - usar posi√ß√£o inicial do F9
            initial_pos = self.config.get('initial_camera_pos')
            if initial_pos:
                center_camera((initial_pos['x'], initial_pos['y']))
            else:
                center_camera()

        except Exception as e:
            print(f"   ‚ö†Ô∏è Aviso na prepara√ß√£o: {e}")

        # 2. VERIFICAR CONFIGURA√á√ïES
        macro_type = self.config.get('macro_type', 'padrao')
        chest_side = self.config.get('chest_side', 'left')

        print(f"   üìã Config: {macro_type} | Lado: {chest_side} | Prop√≥sito: {purpose}")

        # 3. ESCOLHER ARQUIVO (SEMPRE USA PADR√ÉO PARA FUNCIONALIDADES INTERNAS)
        if chest_side == 'left':
            macro_file = 'left_macro.pkl'
        else:
            macro_file = 'right_macro.pkl'

        print(f"   üéØ Arquivo macro selecionado: {macro_file}")

        # 4. VERIFICAR ARQUIVO DETALHADAMENTE
        if not os.path.exists(macro_file):
            print(f"‚ùå ERRO: Arquivo {macro_file} N√ÉO ENCONTRADO!")
            print(f"üìÅ Pasta atual: {os.getcwd()}")
            print(f"üìã Arquivos .pkl na pasta:")
            try:
                pkl_files = [f for f in os.listdir('.') if f.endswith('.pkl')]
                if pkl_files:
                    for f in pkl_files:
                        print(f"   ‚Ä¢ {f}")
                else:
                    print(f"   (nenhum arquivo .pkl encontrado)")
            except:
                print(f"   (erro ao listar arquivos)")

            print(f"üí° Use Ctrl+F10 para gravar os macros padr√£o!")
            return False

        # Se chegou aqui, arquivo existe
        try:
            size = os.path.getsize(macro_file)
            print(f"   ‚úÖ Arquivo existe! Tamanho: {size} bytes")

            # Tentar carregar para verificar se est√° v√°lido
            with open(macro_file, 'rb') as f:
                test_actions = pickle.load(f)
                print(f"   ‚úÖ Arquivo v√°lido! {len(test_actions)} a√ß√µes encontradas")
        except Exception as e:
            print(f"   ‚ùå ERRO ao verificar arquivo: {e}")
            return False

        # 5. EXECUTAR MACRO COM MELHORIAS
        try:
            with open(macro_file, 'rb') as f:
                actions = pickle.load(f)

            print(f"   üé¨ Executando {len(actions)} a√ß√µes...")

            # Delay inicial para garantir que jogo est√° pronto
            time.sleep(0.3)

            # Executar cada a√ß√£o com logs
            for i, action in enumerate(actions):
                if action['type'] == 'key':
                    if action['key'] == 'alt_down':
                        print(f"   {i+1}. ALT Down")
                        focus_game_window()  # Garantir foco antes de pressionar ALT
                        pyautogui.keyDown('alt')
                        time.sleep(0.1)  # Pequeno delay para registro

                    elif action['key'] == 'alt_up':
                        print(f"   {i+1}. ALT Up")
                        time.sleep(0.1)  # Garantir que comando anterior foi processado
                        focus_game_window()  # Garantir foco
                        pyautogui.keyUp('alt')

                    elif action['key'] == 'e':
                        print(f"   {i+1}. Tecla E")
                        focus_game_window()  # Garantir foco antes de pressionar E
                        pyautogui.press('e')

                elif action['type'] == 'camera_move':
                    dx = action['dx']
                    dy = action['dy']
                    print(f"   {i+1}. Movimento: DX={dx}, DY={dy}")
                    camera_turn_in_game(dx, dy)

                elif action['type'] == 'wait':
                    duration = action['duration']
                    print(f"   {i+1}. Aguardar {duration}s")
                    time.sleep(duration)

            # 6. FINALIZA√á√ÉO - Garantir limpeza
            time.sleep(0.5)
            print("   üßπ Finalizando...")

            # Garantir que ALT est√° solto
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')
            time.sleep(0.2)

            print(f"‚úÖ Ba√∫ aberto para {purpose}!")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao abrir ba√∫: {e}")
            # Limpeza de emerg√™ncia
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
            except:
                pass
            return False

    def open_chest_direct_like_f11(self):
        """Abrir ba√∫ usando EXATAMENTE o mesmo sistema do F11 para F6"""
        print("üì¶ [F6] Abrindo ba√∫ com sistema F11...")

        # Usar mesmas configura√ß√µes do F11
        chest_side = self.config.get('chest_side', 'left')
        chest_distance = self.config.get('chest_distance', 1200)
        chest_vertical = self.config.get('chest_vertical_offset', 200)

        print(f"   üß≠ Lado: {chest_side}")
        print(f"   üìè Dist√¢ncia horizontal: {chest_distance}px")
        print(f"   üìê Dist√¢ncia vertical: {chest_vertical}px")

        try:
            # EXATAMENTE a mesma sequ√™ncia do F11
            # 0. Liberar bot√µes do mouse (preservando bot√£o direito se pescando)
            fishing_active = self.game_state.get('fishing_active', False)
            release_mouse_buttons(preserve_right_click=fishing_active)

            # 1. Centralizar c√¢mera
            initial_pos = self.config.get('initial_camera_pos')
            if initial_pos:
                center_camera((initial_pos['x'], initial_pos['y']))
            else:
                center_camera()

            # 2. ALT Down
            print("   2Ô∏è‚É£ ALT Down")
            pyautogui.keyDown('alt')
            time.sleep(0.5)

            # 3. Calcular movimento (IGUAL AO F11)
            if chest_side == 'left':
                dx = -chest_distance
            elif chest_side == 'right':
                dx = chest_distance
            else:
                dx = 0

            dy = abs(chest_vertical)

            print(f"   3Ô∏è‚É£ Movendo c√¢mera: DX={dx}, DY={dy}")

            # Executar movimento
            if dx != 0 or dy != 0:
                camera_turn_in_game(dx, dy)
                print("   ‚úÖ C√¢mera movida!")

            time.sleep(0.3)

            # 4. Tecla E
            print("   4Ô∏è‚É£ Pressionando E")
            pyautogui.press('e')
            time.sleep(0.5)

            # 5. ALT Up
            print("   5Ô∏è‚É£ ALT Up")
            focus_game_window()  # Garantir foco
            pyautogui.keyUp('alt')

            print("   ‚úÖ Ba√∫ deve estar aberto!")
            return True

        except Exception as e:
            print(f"   ‚ùå Erro: {e}")
            try:
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
            except:
                pass
            return False

    def f6_feeding_handler(self):
        """Handler F6 - chama fun√ß√£o apropriada baseada na op√ß√£o da UI - CORRIGIDO"""
        print("\n" + "="*50)
        print("üçñ F6 PRESSIONADO - Verificando modo selecionado...")
        print("="*50)

        # CORRE√á√ÉO: Garantir que initial_camera_pos existe
        if not self.config.get('initial_camera_pos'):
            print("üîß [F6 FIX] Definindo posi√ß√£o inicial da c√¢mera automaticamente...")
            current_pos = pyautogui.position()
            self.config['initial_camera_pos'] = {'x': current_pos.x, 'y': current_pos.y}

            # Salvar no config.json
            try:
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                print(f"‚úÖ [F6 FIX] Posi√ß√£o inicial definida: ({current_pos.x}, {current_pos.y})")
            except Exception as e:
                print(f"‚ö†Ô∏è [F6 FIX] Erro ao salvar posi√ß√£o: {e}")

        # Verificar qual modo est√° selecionado na UI
        feeding_mode = self.alimentacao.get('feeding_mode', 'slots_fixos')
        print(f"üîç Modo detectado na configura√ß√£o: {feeding_mode}")

        if feeding_mode == 'detecao_auto':
            print("ü§ñ Executando ALIMENTA√á√ÉO AUTOM√ÅTICA (detec√ß√£o via CATCH viewer)")
            print("   ‚û§ Chamando execute_feeding()...")
            self.execute_feeding()
        else:
            print("üéØ Executando ALIMENTA√á√ÉO MANUAL (slots fixos)")
            print("   ‚û§ Chamando manual_feeding()...")
            self.manual_feeding()

        # Debug: Mostrar configura√ß√£o atual ap√≥s execu√ß√£o
        print(f"üîç DEBUG - Configura√ß√£o p√≥s-execu√ß√£o:")
        print(f"   feeding_mode: {self.alimentacao.get('feeding_mode', 'N√ÉO DEFINIDO')}")
        print(f"   initial_camera_pos: {self.config.get('initial_camera_pos', 'N√ÉO DEFINIDO')}")

    def test_auto_clean_hotkey(self):
        """F5 - Testar limpeza autom√°tica via hotkey - USANDO M√âTODO F11"""
        print("\n" + "="*50)
        print("üßπ F5 - LIMPEZA AUTOM√ÅTICA COM ABERTURA F11")
        print("="*50)
        print("üìã A√ß√µes que ser√£o executadas:")
        print("   ‚Ä¢ Abrir ba√∫ (m√©todo F11)")
        print("   ‚Ä¢ Transferir peixes do invent√°rio para o ba√∫")
        print("   ‚Ä¢ Coletar iscas do ba√∫ para o invent√°rio")
        print("   ‚Ä¢ Fechar ba√∫")

        try:
            # Garantir que MSS esteja inicializado
            if not hasattr(self, 'sct') or not self.sct:
                import mss
                self.sct = mss.mss()
                print("‚úÖ MSS inicializado para detec√ß√£o")

            # Garantir que templates estejam carregados
            if not hasattr(self, 'available_templates') or not self.available_templates:
                print("‚ö†Ô∏è Templates n√£o carregados - inicializando...")
                self._init_template_matching()

            # Usar diretamente o m√©todo de abertura do F11
            print("\nüì¶ Abrindo ba√∫ com m√©todo F11...")
            self.open_chest_macro()  # Mesma fun√ß√£o do F11

            # Aguardar ba√∫ abrir
            time.sleep(2)

            # Executar a limpeza (transfer√™ncia de itens)
            print("\nüêü Iniciando transfer√™ncia de itens...")

            # Usar detec√ß√£o com template matching
            print("üîç Detectando itens no invent√°rio e ba√∫...")
            detections = self.template_detect_objects(confidence_threshold=0.6)

            # üì∏ SALVAR SCREENSHOT DAS DETEC√á√ïES PARA DEBUG
            try:
                import cv2
                import numpy as np
                import mss
                import os
                from datetime import datetime

                # Criar pasta para screenshots se n√£o existir
                debug_folder = "debug_screenshots"
                if not os.path.exists(debug_folder):
                    os.makedirs(debug_folder)

                # Capturar tela atual
                with mss.mss() as sct:
                    screenshot = sct.grab({"top": 0, "left": 0, "width": 1920, "height": 1080})
                    screen = np.array(screenshot)
                    screen_bgr = cv2.cvtColor(screen, cv2.COLOR_BGRA2BGR)

                # Desenhar ret√¢ngulos nas detec√ß√µes
                debug_screen = screen_bgr.copy()

                for detection in detections:
                    # Desenhar ret√¢ngulo na detec√ß√£o
                    x1, y1 = int(detection['x']), int(detection['y'])
                    x2, y2 = int(x1 + (detection['center_x'] - x1) * 2), int(y1 + (detection['center_y'] - y1) * 2)

                    # Cor: Verde para invent√°rio (esquerda), Azul para ba√∫ (direita)
                    color = (0, 255, 0) if detection['x'] < 1242 else (255, 0, 0)

                    cv2.rectangle(debug_screen, (x1, y1), (x2, y2), color, 2)

                    # Label com nome e confian√ßa
                    label = f"{detection['class']} {detection['confidence']:.2f}"
                    cv2.putText(debug_screen, label, (x1, y1 - 10),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

                # Desenhar linha divis√≥ria em x=1242
                cv2.line(debug_screen, (1242, 0), (1242, 1080), (255, 255, 0), 3)
                cv2.putText(debug_screen, "DIVISORIA INVENTARIO/BAU", (1000, 50),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2)

                # Salvar screenshot
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"{debug_folder}/f5_detections_{timestamp}.png"
                cv2.imwrite(filename, debug_screen)

                print(f"üì∏ Screenshot salvo: {filename}")
                print(f"   {len(detections)} detec√ß√µes marcadas")

            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao salvar debug screenshot: {e}")

            if not detections:
                print("‚ö†Ô∏è Nenhuma detec√ß√£o encontrada - verificando se templates est√£o carregados...")
                if hasattr(self, 'available_templates'):
                    print(f"   Templates dispon√≠veis: {list(self.available_templates.keys())[:5]}")
                else:
                    print("   ‚ùå Templates n√£o carregados!")

            # Classes de peixes e itens para transferir para o ba√∫ (nomes em portugu√™s e ingl√™s)
            fish_classes = ['anchova', 'anchovy', 'aranque', 'herring', 'salmao', 'salmon', 'SALMONN',
                           'sardinha', 'sardine', 'truta', 'trout', 'TROUTT', 'smalltrout',
                           'tubarao', 'shark', 'smallshark', 'parca', 'perch', 'yellowperch',
                           'file de peixe', 'file', 'fish', 'filefrito', 'cookedfish', 'peixecru', 'peixe_cru', 'rawfish',
                           'scrap', 'sinalizador', 'flare', 'cartao_azul', 'bluecard',
                           'bullet',  # Muni√ß√£o (template bullet.png)
                           'BONE', 'bone',  # Fragmentos de osso (template BONE.png)
                           'fat', 'gut']  # Gordura animal (template fat.png) e tripas (gut.png)

            print(f"üìã Lista de itens para transferir: {fish_classes}")

            fish_transferred = 0

            # TRANSFERIR PEIXES DO INVENT√ÅRIO (ESQUERDA) PARA O BA√ö
            print(f"\nüì¶ Transferindo peixes do invent√°rio para o ba√∫...")
            print(f"   Total de detec√ß√µes: {len(detections)}")

            for detection in detections:
                # Verificar se est√° no invent√°rio usando limites exatos
                INVENTORY_LEFT = 651
                INVENTORY_RIGHT = 1234
                INVENTORY_TOP = 559
                INVENTORY_BOTTOM = 1052

                x, y = detection['center_x'], detection['center_y']

                # DEBUG: Mostrar todas as detec√ß√µes
                print(f"üîç DETEC√á√ÉO: '{detection['class']}' em ({x}, {y})")

                if (INVENTORY_LEFT <= x <= INVENTORY_RIGHT and INVENTORY_TOP <= y <= INVENTORY_BOTTOM):
                    print(f"   ‚úÖ DENTRO dos limites do invent√°rio")
                else:
                    print(f"   ‚ùå FORA dos limites do invent√°rio (x:{INVENTORY_LEFT}-{INVENTORY_RIGHT}, y:{INVENTORY_TOP}-{INVENTORY_BOTTOM})")
                    continue  # Pular para pr√≥xima detec√ß√£o

                if True:  # Manter indenta√ß√£o
                    # Verificar se √© um peixe - DEBUG MELHORADO
                    detected_class = detection['class'].lower()
                    is_fish = any(fish in detected_class for fish in [f.lower() for f in fish_classes])

                    print(f"   üîç DEBUG: Classe detectada: '{detection['class']}' | √â peixe: {is_fish}")

                    # DEBUG ESPEC√çFICO PARA PEIXE CRU
                    if 'peixe' in detected_class and 'cru' in detected_class:
                        print(f"   üêü PEIXE CRU ESPEC√çFICO detectado!")

                    if is_fish:
                        # Item est√° dentro dos limites corretos do invent√°rio
                        x, y = detection['center_x'], detection['center_y']
                        print(f"   üêü Item v√°lido: {detection['class']} em ({x}, {y}) - DENTRO do invent√°rio")

                        # üì∏ SCREENSHOT ANTES DO CLIQUE
                        try:
                            import mss
                            click_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]

                            # Capturar pequena √°rea ao redor do clique
                            x, y = detection['center_x'], detection['center_y']
                            region_size = 100

                            with mss.mss() as sct:
                                region = {
                                    "top": max(0, y - region_size//2),
                                    "left": max(0, x - region_size//2),
                                    "width": region_size,
                                    "height": region_size
                                }
                                click_screenshot = sct.grab(region)
                                click_screen = np.array(click_screenshot)
                                click_bgr = cv2.cvtColor(click_screen, cv2.COLOR_BGRA2BGR)

                                # Desenhar cruz no centro do clique
                                center = region_size // 2
                                cv2.line(click_bgr, (center-10, center), (center+10, center), (0, 0, 255), 2)
                                cv2.line(click_bgr, (center, center-10), (center, center+10), (0, 0, 255), 2)

                                # Salvar screenshot do clique
                                click_filename = f"{debug_folder}/click_{fish_transferred+1}_{detection['class']}_{click_timestamp}.png"
                                cv2.imwrite(click_filename, click_bgr)

                                print(f"         üì∏ Screenshot do clique: {click_filename}")
                        except Exception as e:
                            print(f"         ‚ö†Ô∏è Erro ao salvar screenshot do clique: {e}")

                        # MOVER mouse para o centro da detec√ß√£o
                        print(f"      ‚Üí Movendo mouse para ({detection['center_x']}, {detection['center_y']})...")
                        pyautogui.moveTo(detection['center_x'], detection['center_y'], duration=0.3)

                        # Aguardar para garantir que o mouse chegou
                        time.sleep(0.5)

                        # CLICAR com bot√£o direito apenas ap√≥s mover
                        print(f"      ‚Üí Clicando com bot√£o direito...")
                        pyautogui.rightClick()

                        # Aguardar entre transfer√™ncias
                        time.sleep(0.8)

                        fish_transferred += 1
                        print(f"      ‚úÖ Transferido!")

            print(f"‚úÖ {fish_transferred} peixes transferidos para o ba√∫")

            # COLETAR ISCAS DO BA√ö (DIREITA) PARA INVENT√ÅRIO
            print(f"\nü•© Coletando iscas do ba√∫ para o invent√°rio...")

            # Classes de iscas
            bait_classes = ['carne de urso', 'bearmeat', 'bear', 'carne de lobo', 'wolfmeat', 'wolf',
                           'grub', 'worm', 'minhoca', 'larva', 'bait', 'isca']

            baits_collected = 0

            for detection in detections:
                # Verificar se est√° no ba√∫ usando limites exatos
                CHEST_LEFT = 1260   # Ap√≥s a divis√≥ria
                CHEST_RIGHT = 1800  # Limite direito estimado do ba√∫
                CHEST_TOP = 559     # Mesmo topo do invent√°rio
                CHEST_BOTTOM = 1052 # Mesmo fundo do invent√°rio

                if (CHEST_LEFT <= detection['center_x'] <= CHEST_RIGHT and
                    CHEST_TOP <= detection['center_y'] <= CHEST_BOTTOM):
                    # Verificar se √© uma isca
                    if any(bait in detection['class'].lower() for bait in [b.lower() for b in bait_classes]):
                        # Isca est√° dentro dos limites corretos do ba√∫
                        x, y = detection['center_x'], detection['center_y']
                        print(f"   ü•© Isca v√°lida: {detection['class']} em ({x}, {y}) - DENTRO do ba√∫")

                        # üì∏ SCREENSHOT ANTES DO CLIQUE DE ISCA
                        try:
                            import mss
                            bait_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]

                            # Capturar pequena √°rea ao redor do clique
                            x, y = detection['center_x'], detection['center_y']
                            region_size = 100

                            with mss.mss() as sct:
                                region = {
                                    "top": max(0, y - region_size//2),
                                    "left": max(0, x - region_size//2),
                                    "width": region_size,
                                    "height": region_size
                                }
                                bait_screenshot = sct.grab(region)
                                bait_screen = np.array(bait_screenshot)
                                bait_bgr = cv2.cvtColor(bait_screen, cv2.COLOR_BGRA2BGR)

                                # Desenhar cruz azul no centro do clique (iscas)
                                center = region_size // 2
                                cv2.line(bait_bgr, (center-10, center), (center+10, center), (255, 0, 0), 2)
                                cv2.line(bait_bgr, (center, center-10), (center, center+10), (255, 0, 0), 2)

                                # Salvar screenshot da isca
                                bait_filename = f"{debug_folder}/bait_{baits_collected+1}_{detection['class']}_{bait_timestamp}.png"
                                cv2.imwrite(bait_filename, bait_bgr)

                                print(f"         üì∏ Screenshot da isca: {bait_filename}")
                        except Exception as e:
                            print(f"         ‚ö†Ô∏è Erro ao salvar screenshot da isca: {e}")

                        # MOVER mouse para o centro da detec√ß√£o
                        print(f"      ‚Üí Movendo mouse para ({detection['center_x']}, {detection['center_y']})...")
                        pyautogui.moveTo(detection['center_x'], detection['center_y'], duration=0.3)

                        # Aguardar para garantir que o mouse chegou
                        time.sleep(0.5)

                        # CLICAR com bot√£o direito apenas ap√≥s mover
                        print(f"      ‚Üí Clicando com bot√£o direito...")
                        pyautogui.rightClick()

                        # Aguardar entre coletas
                        time.sleep(0.8)

                        baits_collected += 1
                        print(f"      ‚úÖ Coletado!")

                        # Limitar quantidade de iscas coletadas
                        if baits_collected >= 10:
                            break

            print(f"‚úÖ {baits_collected} iscas coletadas do ba√∫")

            # Fechar ba√∫
            time.sleep(1)
            print("\nüö™ Fechando ba√∫...")
            pyautogui.press('tab')

            print(f"\n‚úÖ LIMPEZA COMPLETA: {fish_transferred} peixes guardados | {baits_collected} iscas coletadas")
            print("="*50)

        except Exception as e:
            print(f"‚ùå Erro no F5: {e}")
            # Garantir que ba√∫ seja fechado em caso de erro
            try:
                pyautogui.press('tab')
            except:
                pass

    def manual_feeding(self):
        """Alimenta√ß√£o manual - F6"""
        print("\n" + "="*50)
        print("üçñ ALIMENTA√á√ÉO MANUAL - F6")
        print("="*50)

        # üîç DIAGN√ìSTICO: Verificar se initial_camera_pos existe
        initial_pos = self.config.get('initial_camera_pos')
        if initial_pos:
            print(f"‚úÖ Posi√ß√£o inicial encontrada: ({initial_pos['x']}, {initial_pos['y']})")
        else:
            print("‚ö†Ô∏è ATEN√á√ÉO: Posi√ß√£o inicial N√ÉO encontrada!")
            print("üí° SOLU√á√ÉO: Aperte F9 primeiro para definir posi√ß√£o inicial da c√¢mera")
            print("üí° OU: Mova mouse para centro da tela e aperte F6 novamente")

            # Definir posi√ß√£o atual como inicial
            current_pos = pyautogui.position()
            self.config['initial_camera_pos'] = {'x': current_pos.x, 'y': current_pos.y}

            # Salvar no config.json
            try:
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                print(f"‚úÖ Posi√ß√£o inicial definida automaticamente: ({current_pos.x}, {current_pos.y})")
            except:
                print("‚ö†Ô∏è N√£o foi poss√≠vel salvar posi√ß√£o inicial no config.json")

        try:
            # 0. DIAGN√ìSTICO DETALHADO - Verificar macros padr√£o
            chest_side = self.config.get('chest_side', 'left')
            macro_file = 'left_macro.pkl' if chest_side == 'left' else 'right_macro.pkl'

            print(f"üîç DIAGN√ìSTICO F6:")
            print(f"   üìã Configura√ß√£o chest_side: '{chest_side}'")
            print(f"   üìÅ Arquivo esperado: '{macro_file}'")

            # Verificar se AMBOS os arquivos existem
            left_exists = os.path.exists('left_macro.pkl')
            right_exists = os.path.exists('right_macro.pkl')

            print(f"   ‚úÖ left_macro.pkl: {'EXISTE' if left_exists else 'N√ÉO EXISTE'}")
            print(f"   ‚úÖ right_macro.pkl: {'EXISTE' if right_exists else 'N√ÉO EXISTE'}")

            if not os.path.exists(macro_file):
                print(f"\n‚ùå MACRO PADR√ÉO N√ÉO ENCONTRADO: {macro_file}")
                print("üí° SOLU√á√ÉO: Use Ctrl+F10 para gravar os macros padr√£o primeiro!")
                print(f"   1. Aperte Ctrl+F10")
                print(f"   2. Grave macro para ESQUERDA e DIREITA")
                print(f"   3. Depois use F6 para alimenta√ß√£o")

                # Mostrar tamanho do arquivo se existir mas estiver corrompido
                try:
                    size = os.path.getsize(macro_file)
                    print(f"   ‚ÑπÔ∏è Arquivo existe mas pode estar corrompido (tamanho: {size} bytes)")
                except:
                    pass

                return False
            else:
                # Arquivo existe, mostrar informa√ß√µes
                try:
                    size = os.path.getsize(macro_file)
                    print(f"   ‚úÖ Arquivo encontrado! Tamanho: {size} bytes")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Erro ao verificar arquivo: {e}")

            # 1. Abrir ba√∫ usando SISTEMA DIRETO (igual F11)
            print("üì¶ Abrindo ba√∫ para pegar comida...")
            chest_success = self.open_chest_direct_like_f11()

            if not chest_success:
                print("‚ùå Falha ao abrir ba√∫ - cancelando alimenta√ß√£o")
                return False

            # 2. Aguardar ba√∫ abrir (0.5s conforme solicitado)
            print("‚è≥ Aguardando ba√∫ abrir...")
            time.sleep(0.5)

            # 3. Pegar comida do ba√∫ (COM DELAY) - USAR POSI√á√ïES DA INTERFACE
            print("ü•© Coletando comida do ba√∫...")

            # Usar slot atual do sistema de alimenta√ß√£o (que rotaciona 1->2->1->2)
            current_slot = self.alimentacao['current_slot']
            print(f"   üéØ Slot atual do sistema: {current_slot}")

            # Usar posi√ß√µes configur√°veis da interface
            if hasattr(self, 'alimentacao') and 'slot_positions' in self.alimentacao:
                slot_pos = self.alimentacao['slot_positions'][current_slot]
                food_x, food_y = slot_pos[0], slot_pos[1]
                print(f"   üì¶ Usando slot {current_slot} da interface: ({food_x}, {food_y})")
            else:
                # Fallback para config antigo
                food_chest_coords = self.config.get('food_chest_coords', {'x': 1400, 'y': 600})
                food_x, food_y = food_chest_coords['x'], food_chest_coords['y']
                print(f"   üì¶ Usando config fixo (fallback): ({food_x}, {food_y})")

            print(f"   üì¶ Clicando na comida do ba√∫: ({food_x}, {food_y})")
            pyautogui.click(food_x, food_y)

            # DELAY AP√ìS PEGAR COMIDA
            print("   ‚è≥ Aguardando ap√≥s pegar comida...")
            time.sleep(1.0)  # 1 segundo ap√≥s pegar comida

            # 4. Mover para localiza√ß√£o de comer (COM DELAY ANTES) - USAR POSI√á√ÉO DA INTERFACE
            print("üçñ Preparando para se alimentar...")

            # Usar posi√ß√£o configur√°vel da interface
            if hasattr(self, 'alimentacao') and 'eat_position' in self.alimentacao:
                # üçñ NOVO: Detectar posi√ß√£o din√¢mica do bot√£o eat
                print("   üîç Detectando posi√ß√£o din√¢mica do bot√£o 'eat'...")
                dynamic_eat_pos = self.detect_eat_button_position()
                eat_x, eat_y = dynamic_eat_pos[0], dynamic_eat_pos[1]
            else:
                # Fallback para config antigo com detec√ß√£o din√¢mica
                print("   üîç Detectando posi√ß√£o din√¢mica do bot√£o 'eat' (fallback)...")
                dynamic_eat_pos = self.detect_eat_button_position()
                eat_x, eat_y = dynamic_eat_pos[0], dynamic_eat_pos[1]

            # DELAY ANTES DE COME√áAR A COMER (PELO MENOS 1 SEGUNDO)
            print("   ‚è≥ Aguardando antes de come√ßar a comer...")
            time.sleep(1.0)  # 1 segundo antes de come√ßar a comer

            # üîç DIAGN√ìSTICO: Mostrar todas as configura√ß√µes de alimenta√ß√£o
            print(f"   üîç DIAGN√ìSTICO ALIMENTA√á√ÉO:")
            print(f"   üìÅ 'feeding' em config: {'feeding' in self.config}")

            if 'feeding' in self.config:
                feeding_config = self.config['feeding']
                print(f"   üìã Config feeding: {feeding_config}")
                if 'feeds_per_session' in feeding_config:
                    print(f"   üçñ feeds_per_session: {feeding_config['feeds_per_session']}")

            print(f"   üîß Tem alimentacao: {hasattr(self, 'alimentacao')}")
            if hasattr(self, 'alimentacao'):
                print(f"   üìã Sistema alimentacao: {self.alimentacao}")

            print(f"   ‚öôÔ∏è clicks_per_feeding no config: {self.config.get('clicks_per_feeding', 'N√ÉO ENCONTRADO')}")

            # Determinar quantos cliques fazer (m√°ximo 19)
            clicks_to_eat = None

            # Tentar pegar da configura√ß√£o feeding (interface)
            if 'feeding' in self.config and 'feeds_per_session' in self.config['feeding']:
                clicks_to_eat = self.config['feeding']['feeds_per_session']
                print(f"   ‚úÖ Usando config interface: {clicks_to_eat} comidas")

            # Fallback para alimentacao (sistema antigo)
            elif hasattr(self, 'alimentacao') and 'feeds_per_session' in self.alimentacao:
                clicks_to_eat = self.alimentacao['feeds_per_session']
                print(f"   ‚úÖ Usando sistema alimenta√ß√£o: {clicks_to_eat} comidas")

            # Fallback final
            else:
                clicks_to_eat = self.config.get('clicks_per_feeding', 5)  # Padr√£o 5 em vez de 10
                print(f"   ‚ö†Ô∏è Usando fallback: {clicks_to_eat} comidas")

            # Limitar a m√°ximo 19
            if clicks_to_eat > 19:
                print(f"   ‚ö†Ô∏è Limitando de {clicks_to_eat} para 19 cliques (m√°ximo)")
                clicks_to_eat = 19

            print(f"   üçΩÔ∏è Iniciando alimenta√ß√£o na posi√ß√£o: ({eat_x}, {eat_y})")
            print(f"   üî¢ Cliques programados: {clicks_to_eat} (m√°x 19)")
            print(f"   ‚è±Ô∏è Intervalo entre cliques: 1.5s")

            # COMER COM DELAYS ADEQUADOS
            for i in range(clicks_to_eat):
                print(f"   üçñ Clique {i+1}/{clicks_to_eat}")
                pyautogui.click(eat_x, eat_y)

                # SEMPRE aguardar 1.5s entre TODOS os cliques (inclusive o √∫ltimo)
                if i < clicks_to_eat - 1:
                    print(f"   ‚è≥ Aguardando 1.5s...")
                    time.sleep(1.5)
                else:
                    # Mesmo no √∫ltimo clique, aguardar um pouco para garantir
                    print(f"   ‚è≥ Finalizando alimenta√ß√£o...")
                    time.sleep(1.0)

            print("‚úÖ Alimenta√ß√£o conclu√≠da!")

            # üîÑ ATUALIZAR CONTADORES DO SLOT (como no execute_feeding)
            if hasattr(self, 'alimentacao'):
                print(f"   üìä Atualizando contador do Slot {current_slot} (+{clicks_to_eat})")
                if current_slot == 1:
                    self.alimentacao['slot1_uses'] += clicks_to_eat
                else:
                    self.alimentacao['slot2_uses'] += clicks_to_eat

                # Verificar se precisa trocar de slot para pr√≥xima vez
                max_uses = self.alimentacao['max_uses_per_slot']
                slot1_uses = self.alimentacao['slot1_uses']
                slot2_uses = self.alimentacao['slot2_uses']

                print(f"   üìà Status ap√≥s alimenta√ß√£o: Slot1({slot1_uses}/{max_uses}) | Slot2({slot2_uses}/{max_uses})")

                # Trocar slot se necess√°rio
                if current_slot == 1 and slot1_uses >= max_uses and slot2_uses < max_uses:
                    self.alimentacao['current_slot'] = 2
                    print(f"   üîÑ Slot 1 atingiu {max_uses} usos! Pr√≥xima alimenta√ß√£o usar√° Slot 2")
                elif current_slot == 2 and slot2_uses >= max_uses:
                    print(f"   ‚ö†Ô∏è Slot 2 tamb√©m atingiu {max_uses} usos! Precisa reabastecer comida")

                # Atualizar tempo da √∫ltima alimenta√ß√£o
                self.alimentacao['last_feed_time'] = time.time()

            # 5. Fechar invent√°rio com TAB
            print("üîí Fechando invent√°rio...")
            self.close_inventory_with_delay("Auto opera√ß√£o")

            # 6. Voltar para posi√ß√£o de pescar
            print("üé£ Voltando para posi√ß√£o de pescar...")
            initial_pos = self.config.get('initial_camera_pos')
            if initial_pos:
                print(f"   üìç Retornando para: ({initial_pos['x']}, {initial_pos['y']})")
                pyautogui.moveTo(initial_pos['x'], initial_pos['y'])
                time.sleep(0.3)
                print("‚úÖ Mouse reposicionado para pescar!")
            else:
                print("‚ö†Ô∏è Posi√ß√£o inicial n√£o encontrada - use F9 para definir!")

            print("‚úÖ ALIMENTA√á√ÉO MANUAL CONCLU√çDA!")
            return True

        except Exception as e:
            print(f"‚ùå Erro na alimenta√ß√£o manual: {e}")
            # Limpeza de emerg√™ncia
            try:
                pyautogui.press('tab')  # Fechar invent√°rio
                focus_game_window()  # Garantir foco
                pyautogui.keyUp('alt')
                # Voltar para posi√ß√£o de pescar se poss√≠vel
                initial_pos = self.config.get('initial_camera_pos')
                if initial_pos:
                    pyautogui.moveTo(initial_pos['x'], initial_pos['y'])
            except:
                pass
            return False

    def clear_macro_cache(self):
        """Limpar cache de macro - Del"""
        print("\n" + "="*50)
        print("üóëÔ∏è LIMPANDO CACHE DE MACRO - Del")
        print("="*50)

        files_to_delete = ['recorded_macro.pkl', 'recorded_macro.txt']
        deleted_count = 0

        for file in files_to_delete:
            try:
                if os.path.exists(file):
                    os.remove(file)
                    print(f"‚úÖ Deletado: {file}")
                    deleted_count += 1
                else:
                    print(f"‚ö™ N√£o existe: {file}")
            except Exception as e:
                print(f"‚ùå Erro ao deletar {file}: {e}")

        if deleted_count > 0:
            print(f"\nüßπ {deleted_count} arquivo(s) de cache removido(s)")
            print("üí° Pr√≥ximo F3 criar√° novo macro com config atual!")

            # Mostrar config atual
            current_side = self.config.get('chest_side', 'left')
            current_distance = self.config.get('chest_distance', 300)
            current_vertical = self.config.get('chest_vertical_offset', 0)

            print(f"üìã Config atual que ser√° usado:")
            print(f"   üß≠ Lado: {current_side}")
            print(f"   üìè Dist√¢ncia: {current_distance}px")
            print(f"   üìê Vertical: {current_vertical}px")
        else:
            print("‚ö™ Nenhum arquivo de cache para deletar")

        print("="*50)

    def record_macro_helper(self):
        """Helper para chamar fun√ß√£o de grava√ß√£o de macro Pulover - Shift+F3"""
        record_chest_macro()

    def map_general_detections_to_slots(self, all_detections, slot_positions):
        """üîß Mapear detec√ß√µes gerais (que funcionam) para slots espec√≠ficos"""
        rod_slots = {}

        # Filtrar apenas detec√ß√µes de varas
        vara_detections = []
        for detection in all_detections:
            template_name = detection.get('name', '').lower()
            if any(vara_type in template_name for vara_type in ['vara', 'comisca', 'semisca', 'quebrada']):
                vara_detections.append(detection)

        # Mapear cada detec√ß√£o para o slot mais pr√≥ximo
        for detection in vara_detections:
            det_x = detection.get('x', 0)
            det_y = detection.get('y', 0)

            # Encontrar slot mais pr√≥ximo
            closest_slot = None
            min_distance = float('inf')

            for slot_num, (slot_x, slot_y) in slot_positions.items():
                distance = ((det_x - slot_x) ** 2 + (det_y - slot_y) ** 2) ** 0.5
                if distance < min_distance and distance < 100:  # M√°ximo 100 pixels de dist√¢ncia
                    min_distance = distance
                    closest_slot = slot_num

            if closest_slot:
                # Adicionar ao rod_slots no formato esperado
                rod_slots[closest_slot] = {
                    'detection': detection,
                    'center_x': det_x,
                    'center_y': det_y,
                    'name': detection.get('name', ''),
                    'distance': min_distance,
                    'status': detection.get('status', 'UNKNOWN')
                }

        return rod_slots

    def auto_rod_maintenance_system(self):
        """üîß Sistema Completo de Manuten√ß√£o de Varas - Tecla 0"""
        print("\n" + "="*70)
        print("üîß SISTEMA DE MANUTEN√á√ÉO AUTOM√ÅTICA DE VARAS - INICIADO")
        print("="*70)

        try:
            # PASSO 0: Limpar cache antes de come√ßar
            print("üßπ PASSO 0: Limpando cache do sistema...")
            self.clear_detection_cache()
            print("‚úÖ Cache limpo!")
            # PASSO 1: Abrir ba√∫ primeiro (como especificado)
            print("üì¶ PASSO 1: Abrindo ba√∫ usando mesmo macro do F6...")
            if not self.game_state.get('chest_open', False):
                success = self.open_chest_direct_like_f11()
                if not success:
                    print("‚ùå Falha ao abrir ba√∫. Abortando manuten√ß√£o.")
                    return
                time.sleep(0.8)  # Reduzido para mais fluidez
                print("‚úÖ Ba√∫ aberto!")

            # ‚úÖ OTIMIZADO: Aguardar carregamento 
            print("‚è≥ Aguardando carregamento dos itens no ba√∫...")
            time.sleep(1.5)  # ‚úÖ OTIMIZADO: Reduzido de 3s para 1.5s

            # ‚úÖ CORRE√á√ÉO CR√çTICA: Aguardar Catch Viewer atualizar primeiro
            print("üîç Aguardando Catch Viewer processar invent√°rio aberto...")
            time.sleep(1.0)  # ‚úÖ OTIMIZADO: Reduzido de 2s para 1s

            # ‚úÖ CORRE√á√ÉO: M√∫ltiplas verifica√ß√µes para garantir consist√™ncia
            print("üîç Detectando status das varas nos slots 1-6...")
            print("üìä EXECUTANDO M√öLTIPLAS VERIFICA√á√ïES para garantir consist√™ncia:")

            rod_status = None
            consistent_detections = 0
            max_attempts = 3

            for attempt in range(max_attempts):
                print(f"   üîç Tentativa {attempt + 1}/{max_attempts}: Detectando status...")
                current_detection = self.detect_all_rod_status()

                if attempt == 0:
                    rod_status = current_detection
                    consistent_detections = 1
                else:
                    # Comparar com detec√ß√£o anterior
                    if current_detection == rod_status:
                        consistent_detections += 1
                        print(f"   ‚úÖ Detec√ß√£o consistente ({consistent_detections}/{max_attempts})")
                    else:
                        print(f"   ‚ö†Ô∏è Detec√ß√£o inconsistente - aguardando mais tempo...")
                        rod_status = current_detection  # Usar mais recente
                        consistent_detections = 1

                # Se temos pelo menos 2 detec√ß√µes consistentes, podemos prosseguir
                if consistent_detections >= 2:
                    print(f"   üéØ STATUS CONSISTENTE CONFIRMADO ap√≥s {attempt + 1} tentativas!")
                    break

                # Aguardar entre tentativas
                if attempt < max_attempts - 1:
                    print(f"   ‚è≥ Aguardando 2s antes da pr√≥xima verifica√ß√£o...")
                    time.sleep(2.0)

            if consistent_detections < 2:
                print(f"   ‚ö†Ô∏è Usando √∫ltima detec√ß√£o (confiabilidade: {consistent_detections}/{max_attempts})")

            print(f"üìä STATUS FINAL DETECTADO: {rod_status}")

            # üéØ USAR DIRETAMENTE O STATUS DAS VARAS DETECTADO
            print("\nüéØ USANDO STATUS DAS VARAS DETECTADO:")
            print("="*60)

            # Listas baseadas EXATAMENTE no status detectado
            broken_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "broken"]
            empty_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "empty"]
            no_bait_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "no_bait"]
            with_bait_slots = [slot for slot in range(1, 7) if rod_status.get(slot) == "with_bait"]

            # Slots que precisam de VARA = vazios + quebradas
            slots_needing_rods = empty_slots + broken_slots

            print(f"üìä RESULTADO DIRETO DO STATUS:")
            print(f"   ‚ùå Quebradas: {broken_slots}")
            print(f"   ‚ö™ Vazios: {empty_slots}")
            print(f"   ‚ö†Ô∏è Sem isca: {no_bait_slots}")
            print(f"   ‚úÖ Com isca: {with_bait_slots}")
            print(f"")
            print(f"üîÑ PRECISAM DE VARA: {sorted(slots_needing_rods)} = vazios + quebradas")
            print(f"üé£ PRECISAM DE ISCA: {no_bait_slots} = varas sem isca")

            print(f"üîç [DEBUG] slots_needing_rods FINAL: {sorted(slots_needing_rods)}")

            if slots_needing_rods:
                print(f"üîÑ Repor varas em: {sorted(slots_needing_rods)} ({len(slots_needing_rods)} slots precisam de vara)")
            else:
                print(f"üîÑ Repor varas: Todos os slots t√™m varas ‚úì")

            if no_bait_slots:
                print(f"üé£ Recarregar iscas em: {no_bait_slots} ({len(no_bait_slots)} slots precisam de isca)")
            else:
                print(f"üé£ Recarregar iscas: Todas as varas t√™m iscas ‚úì")

            if with_bait_slots:
                print(f"‚úÖ N√£o mexer: {with_bait_slots} (j√° t√™m vara + isca)")

            print("="*60)
            print("üí° PRIORIDADES:")
            print("   1Ô∏è‚É£ Varas quebradas (PRIORIDADE M√ÅXIMA se detectadas)")
            print("   2Ô∏è‚É£ Slots vazios (reposi√ß√£o de varas)")
            print("   3Ô∏è‚É£ Varas sem isca (recarga de iscas)")

            # üîß FASE 1: MANEJO DE VARAS QUEBRADAS (PRIORIDADE M√ÅXIMA) - CONFIGUR√ÅVEL
            broken_rod_action = self.config.get('broken_rod_action', 'discard')
            action_name = "DESCARTE" if broken_rod_action == 'discard' else "ARMAZENAMENTO"
            print(f"\nüîß FASE 1: {action_name} DE VARAS QUEBRADAS (PRIORIDADE M√ÅXIMA)")
            
            if broken_slots:
                print(f"üö® VARAS QUEBRADAS DETECTADAS: {broken_slots} - EXECUTANDO COM PRIORIDADE!")
                print(f"‚öôÔ∏è MODO CONFIGURADO: {broken_rod_action}")
                print(f"Processando {len(broken_slots)} varas quebradas:")

                for i, slot in enumerate(broken_slots, 1):
                    print(f"\nüö® [{i}/{len(broken_slots)}] PRIORIDADE: Processando vara quebrada no slot {slot}:")
                    
                    if broken_rod_action == 'discard':
                        print(f"   üóëÔ∏è Descartando vara quebrada (como tecla 0)...")
                        self.remove_broken_rod_from_slot(slot)
                    else:  # save
                        print(f"   üì¶ Guardando vara quebrada no ba√∫...")
                        self.save_broken_rod_to_chest(slot)

                action_verb = "descartadas" if broken_rod_action == 'discard' else "guardadas no ba√∫"
                print(f"\n‚úÖ FASE 1 COMPLETA: {len(broken_slots)} varas quebradas foram {action_verb}!")
                print(f"üìä Slots liberados para reposi√ß√£o: {broken_slots}")
            else:
                print("‚ÑπÔ∏è Nenhuma vara quebrada detectada - continuando para pr√≥ximas fases")

            # üîÑ FASE 2: REPOSI√á√ÉO DE VARAS COM L√ìGICA DE PRIORIZA√á√ÉO
            print(f"\nüîÑ FASE 2: REPOSI√á√ÉO DE VARAS COM PRIORIZA√á√ÉO")
            if slots_needing_rods:
                print(f"Slots que precisam de vara: {sorted(slots_needing_rods)} ({len(slots_needing_rods)} total)")

                # ‚úÖ PASSO 1: Escanear varas dispon√≠veis
                print("üìã Escaneando varas dispon√≠veis no ba√∫...")
                chest_rods_cache = self.scan_chest_rods()
                # Inicializar tracking de posi√ß√µes se n√£o existir
                if 'detected_positions' not in chest_rods_cache:
                    chest_rods_cache['detected_positions'] = set()
                varas_com_isca = len(chest_rods_cache['with_bait'])
                varas_sem_isca = len(chest_rods_cache['without_bait'])
                total_varas = varas_com_isca + varas_sem_isca

                print(f"üìä INVENT√ÅRIO DO BA√ö:")
                print(f"   üèÜ Varas COM isca: {varas_com_isca}")
                print(f"   ‚ö†Ô∏è Varas SEM isca: {varas_sem_isca}")
                print(f"   üì¶ Total de varas: {total_varas}")
                print(f"   üéØ Slots que precisam: {len(slots_needing_rods)}")

                # ‚úÖ PASSO 2: Verificar se temos varas suficientes
                if total_varas < len(slots_needing_rods):
                    print(f"‚ö†Ô∏è AVISO: S√≥ temos {total_varas} varas para {len(slots_needing_rods)} slots!")
                    print(f"   üìå Processaremos o m√°ximo poss√≠vel")

                # ‚úÖ PASSO 3: L√ìGICA DE PRIORIZA√á√ÉO IMPLEMENTADA
                print(f"\nüß† ESTRAT√âGIA DE COLOCA√á√ÉO:")
                slots_que_receberao_vara_com_isca = min(varas_com_isca, len(slots_needing_rods))
                slots_que_receberao_vara_sem_isca = min(varas_sem_isca, len(slots_needing_rods) - slots_que_receberao_vara_com_isca)

                print(f"   1Ô∏è‚É£ PRIMEIRA: {slots_que_receberao_vara_com_isca} slots receber√£o varas COM isca")
                print(f"   2Ô∏è‚É£ SEGUNDA: {slots_que_receberao_vara_sem_isca} slots receber√£o varas SEM isca")
                print(f"   üìù RESULTADO: {slots_que_receberao_vara_sem_isca} varas precisar√£o de isca na Fase 3")

                # ‚úÖ PASSO 4: Executar coloca√ß√£o com controle de prioriza√ß√£o
                slots_com_vara_sem_isca = []  # üìù IMPORTANTE: Rastrear quais receberam vara SEM isca

                for i, slot in enumerate(sorted(slots_needing_rods), 1):
                    print(f"\n[{i}/{len(slots_needing_rods)}] Colocando vara no slot {slot}:")

                    # ‚úÖ CORRE√á√ÉO CR√çTICA: Re-escanear cache a cada 2 slots OU quando cache est√° baixo
                    cache_refresh_needed = False
                    total_cache_rods = len(chest_rods_cache['with_bait']) + len(chest_rods_cache['without_bait'])

                    if i == 1:
                        cache_refresh_needed = True
                        print(f"   üîÑ [CACHE] Escaneamento inicial...")
                    elif (i-1) % 2 == 0:
                        cache_refresh_needed = True
                        print(f"   üîÑ [CACHE] Re-escaneamento programado (a cada 2 slots)...")
                    elif total_cache_rods <= 1:
                        cache_refresh_needed = True
                        print(f"   üîÑ [CACHE] Re-escaneamento for√ßado - cache baixo ({total_cache_rods} varas restantes)...")

                    if cache_refresh_needed:
                        # üéØ PRESERVAR posi√ß√µes j√° usadas ao re-escanear
                        old_positions = chest_rods_cache.get('detected_positions', set()) if chest_rods_cache else set()
                        chest_rods_cache = self.scan_chest_rods()
                        # Mesclar posi√ß√µes antigas com novas para evitar reutiliza√ß√£o
                        if old_positions:
                            chest_rods_cache['detected_positions'] = chest_rods_cache.get('detected_positions', set()).union(old_positions)
                            print(f"   üìã [TRACKING] Preservando {len(old_positions)} posi√ß√µes j√° usadas")
                        total_cache_rods = len(chest_rods_cache['with_bait']) + len(chest_rods_cache['without_bait'])
                        print(f"   üìä [CACHE] Atualizado: {len(chest_rods_cache['with_bait'])} COM isca, {len(chest_rods_cache['without_bait'])} SEM isca (Total: {total_cache_rods})")

                    # Verificar se ainda h√° varas dispon√≠veis
                    if total_cache_rods == 0:
                        print(f"   ‚ùå NENHUMA vara encontrada no ba√∫!")
                        print(f"   üîç Tentando re-escaneamento EXTRA com delay...")
                        time.sleep(2.0)  # Aguardar mais tempo
                        chest_rods_cache = self.scan_chest_rods()
                        total_cache_rods = len(chest_rods_cache['with_bait']) + len(chest_rods_cache['without_bait'])

                        if total_cache_rods == 0:
                            print(f"   ‚ùå Cache permanece vazio ap√≥s escaneamento extra! Slot {slot} N√ÉO ser√° processado.")
                            print(f"   üìä Status final: COM isca={len(chest_rods_cache['with_bait'])}, SEM isca={len(chest_rods_cache['without_bait'])}")
                            continue  # Pular este slot e continuar com os pr√≥ximos
                        else:
                            print(f"   ‚úÖ Escaneamento extra encontrou {total_cache_rods} varas! Continuando...")

                    # üî• DEBUG CR√çTICO: Mostrar exatamente o que temos ANTES de decidir
                    print(f"\n   üîç [DEBUG CR√çTICO] Cache ANTES de escolher para slot {slot}:")
                    print(f"      üìä COM isca dispon√≠veis: {len(chest_rods_cache.get('with_bait', []))}")
                    if chest_rods_cache.get('with_bait'):
                        for idx, rod in enumerate(chest_rods_cache['with_bait'][:2]):
                            print(f"         {idx+1}. {rod['template']} @ ({rod['x']},{rod['y']}) conf:{rod.get('confidence', 0):.2f}")
                    print(f"      üìä SEM isca dispon√≠veis: {len(chest_rods_cache.get('without_bait', []))}")
                    if chest_rods_cache.get('without_bait'):
                        for idx, rod in enumerate(chest_rods_cache['without_bait'][:2]):
                            print(f"         {idx+1}. {rod['template']} @ ({rod['x']},{rod['y']}) conf:{rod.get('confidence', 0):.2f}")
                    
                    # ‚úÖ Verificar qual tipo de vara ser√° colocada ANTES de colocar
                    if chest_rods_cache.get('with_bait') and len(chest_rods_cache['with_bait']) > 0:
                        print(f"   üèÜ DECIS√ÉO: Usar COM isca (restam {len(chest_rods_cache['with_bait'])})")
                        print(f"   üéØ Escolhida: {chest_rods_cache['with_bait'][0]['template']}")
                        vara_colocada_tem_isca = True
                    elif chest_rods_cache.get('without_bait') and len(chest_rods_cache['without_bait']) > 0:
                        print(f"   ‚ö†Ô∏è DECIS√ÉO: Usar SEM isca (restam {len(chest_rods_cache['without_bait'])})")
                        print(f"   ‚ö†Ô∏è Escolhida: {chest_rods_cache['without_bait'][0]['template']}")
                        vara_colocada_tem_isca = False
                        slots_com_vara_sem_isca.append(slot)  # üìù REGISTRAR para Fase 3
                    else:
                        print(f"   ‚ùå Nenhuma vara restante no ba√∫!")
                        break

                    success = self.place_rod_in_empty_slot(slot, chest_rods_cache)
                    if not success:
                        print(f"‚ö†Ô∏è Falha ao colocar vara no slot {slot}")
                        # ‚úÖ CORRE√á√ÉO: Re-escanear imediatamente ap√≥s falha
                        print(f"   üîÑ [CACHE] Re-escaneando ap√≥s falha...")
                        chest_rods_cache = self.scan_chest_rods()
                        # Se falhou, remover da lista de slots que precisam de isca
                        if slot in slots_com_vara_sem_isca:
                            slots_com_vara_sem_isca.remove(slot)
                        continue

                    # ‚úÖ Registrar sucesso
                    if vara_colocada_tem_isca:
                        print(f"   ‚úÖ Slot {slot}: Vara COM isca colocada - N√ÉO precisar√° de recarga")
                    else:
                        print(f"   üìù Slot {slot}: Vara SEM isca colocada - PRECISAR√Å de recarga na Fase 3")

                    # ‚úÖ DELAY adequado entre coloca√ß√µes para estabiliza√ß√£o
                    time.sleep(1.2)  # Aumentado para garantir estabiliza√ß√£o

                print(f"\nüìä RESULTADO DA FASE 2:")
                print(f"   ‚úÖ Slots processados: {len(slots_needing_rods)}")
                print(f"   üìù Slots que PRECISAR√ÉO de isca na Fase 3: {slots_com_vara_sem_isca}")

                # ‚úÖ IMPORTANTE: Salvar lista para uso na Fase 3
                self._slots_needing_bait_from_phase2 = slots_com_vara_sem_isca
                print(f"   üîç [DEBUG] Lista salva para Fase 3: {self._slots_needing_bait_from_phase2}")
                print(f"   üîç [DEBUG] Verificando se lista foi salva: {hasattr(self, '_slots_needing_bait_from_phase2')}")

            else:
                print("‚úÖ Todos os slots j√° t√™m varas - nada para repor")
                self._slots_needing_bait_from_phase2 = []

            # üé£ FASE 3: RECARGA DE ISCAS NAS VARAS SEM ISCA (SEMPRE EXECUTA SE NECESS√ÅRIO)
            print(f"\nüé£ FASE 3: RECARGA DE ISCAS")

            # üßπ PASSO 3.0: Limpar TODOS os caches antes de detectar isca (CR√çTICO para evitar conflitos)
            print("üßπ Limpando caches de detec√ß√£o para garantir dados atualizados...")
            self.clear_detection_cache()
            print("‚úÖ Cache limpo - detec√ß√µes ser√£o baseadas em dados frescos")

            # CR√çTICO: Aguardar e for√ßar re-detec√ß√£o completa ap√≥s FASE 2
            print("‚è≥ Aguardando estabiliza√ß√£o ap√≥s coloca√ß√£o de varas...")
            time.sleep(2.0)  # ‚úÖ OTIMIZADO: Reduzido de 5s para 2s  # ‚úÖ AUMENTADO: Aguardar mais tempo para Catch Viewer atualizar

            # ‚úÖ CORRE√á√ÉO: For√ßar nova detec√ß√£o completa ap√≥s coloca√ß√£o das varas
            print("üîÑ For√ßando nova detec√ß√£o completa de status das varas...")
            updated_rod_status = self.detect_all_rod_status()
            print(f"üìä Status atualizado ap√≥s FASE 2: {updated_rod_status}")
            
            # Tentar tamb√©m atualizar catch viewer se dispon√≠vel
            if hasattr(self, 'ui') and self.ui and hasattr(self.ui, 'force_detection_update'):
                print("üîÑ Tentando atualizar Catch Viewer...")
                try:
                    self.ui.force_detection_update()
                    print("‚úÖ Catch Viewer atualizado!")
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao atualizar Catch Viewer: {e}")

            # üéØ CORRE√á√ÉO: Usar status atualizado para identificar slots que precisam de isca
            updated_no_bait_slots = [slot for slot in range(1, 7) if updated_rod_status.get(slot) == "no_bait"]
            print(f"üéØ Slots sem isca (detec√ß√£o atualizada): {updated_no_bait_slots}")
            
            # Usar status atualizado em vez do antigo
            no_bait_slots = updated_no_bait_slots
            
            # üéØ IDENTIFICA√á√ÉO: Slots que precisam de isca INCLUINDO os que acabaram de receber vara
            print("üìä IDENTIFICA√á√ÉO COMPLETA DOS SLOTS QUE PRECISAM DE ISCA:")

            # 1. Slots que j√° tinham vara sem isca (detec√ß√£o inicial)
            slots_sem_isca_inicial = no_bait_slots.copy()
            print(f"   üìù Slots com vara sem isca (inicial): {slots_sem_isca_inicial}")

            # 2. Slots que receberam vara sem isca na Fase 2 (se houver)
            slots_que_receberam_vara_sem_isca = getattr(self, '_slots_needing_bait_from_phase2', [])
            print(f"   üîÑ Slots que receberam vara sem isca (Fase 2): {slots_que_receberam_vara_sem_isca}")

            # 3. COMBINAR as duas listas (sem duplicatas)
            confirmed_no_bait_slots = list(set(slots_sem_isca_inicial + slots_que_receberam_vara_sem_isca))
            print(f"   üéØ TOTAL que precisa de isca: {sorted(confirmed_no_bait_slots)}")

            # Acessar dados do Catch Viewer para valida√ß√£o adicional
            if hasattr(self, 'ui') and self.ui and hasattr(self.ui, 'rod_status_tracking'):
                catch_viewer_data = self.ui.rod_status_tracking
                varas_sem_isca_viewer = catch_viewer_data.get('available_without_bait', [])
                print(f"   üìä Catch Viewer tamb√©m detecta sem isca: {varas_sem_isca_viewer}")

                # Adicionar slots do Catch Viewer que n√£o est√£o na nossa lista
                for slot in varas_sem_isca_viewer:
                    if slot not in confirmed_no_bait_slots:
                        confirmed_no_bait_slots.append(slot)
                        print(f"      ‚ûï Adicionado slot {slot} detectado pelo Catch Viewer")
            else:
                print(f"   ‚ö†Ô∏è Catch Viewer n√£o dispon√≠vel - usando apenas listas iniciais")

            # ‚úÖ PASSO 3: Usar lista confirmada
            no_bait_slots = confirmed_no_bait_slots

            print(f"\nüéØ RESULTADO FINAL:")
            print(f"   üìù Slots que REALMENTE precisam de isca: {no_bait_slots}")
            print(f"   üìä Quantidade: {len(no_bait_slots)} slots")

            print(f"\nüîç [DEBUG FASE 3] Verificando se precisa executar recarga:")
            print(f"   üìù Lista no_bait_slots: {no_bait_slots}")
            print(f"   üìä Comprimento da lista: {len(no_bait_slots)}")
            print(f"   ‚ùì Condi√ß√£o if no_bait_slots: {'True' if no_bait_slots else 'False'}")

            if no_bait_slots:
                print(f"\nüèÜ ‚úÖ EXECUTANDO RECARGA DE ISCAS (condi√ß√£o atendida):")
                print(f"   üìã Slots que precisam de isca: {no_bait_slots}")
                print(f"   üìä Total de slots: {len(no_bait_slots)}")

                # ‚úÖ Escanear iscas com prioridade
                print(f"\nüìã Escaneando iscas dispon√≠veis no ba√∫...")
                all_baits = self.scan_all_baits_in_chest()

                if not all_baits:
                    print("‚ùå ERRO CR√çTICO: Nenhuma isca encontrada no ba√∫!")
                    print("   üí° Verifique se h√° iscas no ba√∫:")
                    print("      ‚Ä¢ Carne de urso (carnedeurso.png)")
                    print("      ‚Ä¢ Carne de lobo (wolfmeat.png)")
                    print("      ‚Ä¢ Larvas (grub.png)")
                    return
                else:
                    print(f"\n‚úÖ ISCAS ENCONTRADAS: {len(all_baits)} dispon√≠veis")
                    print(f"üìä Rela√ß√£o: {len(all_baits)} iscas para {len(no_bait_slots)} slots")

                    if len(all_baits) < len(no_bait_slots):
                        print(f"‚ö†Ô∏è AVISO: Menos iscas ({len(all_baits)}) do que slots ({len(no_bait_slots)})")
                        print(f"   Processaremos at√© onde der...")

                    print(f"\nüìã LISTA DE ISCAS ENCONTRADAS:")
                    for i, bait in enumerate(all_baits):
                        print(f"   {i+1}. {bait['name']} em ({bait['x']}, {bait['y']})")
                        if i >= 4:  # Mostrar m√°ximo 5
                            print(f"   ... e mais {len(all_baits) - 5} iscas")
                            break

                # ‚úÖ Processar cada slot individualmente CONFIANDO NO CATCH VIEWER
                for i, slot in enumerate(no_bait_slots, 1):
                    print(f"\n[{i}/{len(no_bait_slots)}] üé£ APLICANDO ISCA no slot {slot}:")

                    # üéØ CORRE√á√ÉO CR√çTICA: CONFIAR TOTALMENTE NO CATCH VIEWER (n√£o re-validar)
                    print(f"   ‚úÖ CONFIAN√áA TOTAL: Catch Viewer confirma que slot {slot} precisa de isca")
                    print(f"   üéØ SKIP valida√ß√£o real-time para evitar conflito de cache")
                    print(f"   üìù Motivo: Catch Viewer j√° validou que slot tem vara SEM isca")

                    # Comentar a valida√ß√£o real-time que estava causando conflitos
                    # current_status = self.detect_rod_status_in_slot_REALTIME(slot)
                    # - Esta valida√ß√£o estava detectando "with_bait" quando Catch Viewer detecta "no_bait"
                    # - Causa: Cache desatualizado entre sistemas
                    # - Solu√ß√£o: Confiar 100% no Catch Viewer que √© mais confi√°vel
                    print(f"   üîç DEBUG: Iscas restantes no in√≠cio: {len(all_baits)}")

                    if not all_baits:
                        print(f"   ‚ùå CR√çTICO: Sem iscas restantes para o slot {slot}")
                        print(f"   üìã Tentando re-escanear iscas...")
                        all_baits = self.scan_all_baits_in_chest()
                        if not all_baits:
                            print(f"   ‚ùå Re-scan falhou - sem iscas no ba√∫")
                            break
                        else:
                            print(f"   ‚úÖ Re-scan encontrou {len(all_baits)} iscas")

                    # Usar primeira isca dispon√≠vel
                    bait = all_baits[0]
                    print(f"   üéØ [SELECIONADA] Isca: {bait['name']} no BA√ö em ({bait['x']}, {bait['y']})")
                    print(f"   üìç [DESTINO] Slot {slot} em (coordenadas do invent√°rio) - confirmado SEM isca")
                    print(f"   üîÑ [OPERA√á√ÉO] Vai arrastar isca DO ba√∫ PARA o slot {slot}")

                    try:
                        # ‚úÖ DRAG & DROP com debug detalhado
                        print(f"   üöÄ Executando drag & drop...")
                        success = self._execute_drag_drop_bait(slot, bait)
                        print(f"   üìä Resultado drag & drop: {'SUCESSO' if success else 'FALHA'}")

                        if success:
                            print(f"   ‚úÖ DRAG & DROP executado no slot {slot}")
                            print(f"   ‚è≥ Aguardando 2s para estabiliza√ß√£o...")
                            time.sleep(2.0)  # Aguardar mais tempo para aplica√ß√£o

                            # üîç VERIFICA√á√ÉO P√ìS-APLICA√á√ÉO: Confirmar se isca foi realmente aplicada
                            print(f"   üîç Verificando se isca foi aplicada no slot {slot}...")
                            post_status = self.detect_rod_status_in_slot_REALTIME(slot)

                            if post_status == "with_bait":
                                print(f"   ‚úÖ CONFIRMADO: Isca APLICADA com sucesso no slot {slot}!")
                                all_baits.pop(0)  # Remover isca usada apenas se confirmado
                                print(f"   üìä Iscas restantes ap√≥s remo√ß√£o: {len(all_baits)}")
                            else:
                                print(f"   ‚ùå FALHA NA APLICA√á√ÉO: Slot {slot} ainda mostra status '{post_status}'")
                                print(f"   ‚ö†Ô∏è Isca N√ÉO removida da lista - pode tentar novamente")
                                # N√£o remove a isca da lista pois a aplica√ß√£o falhou
                        else:
                            print(f"   ‚ùå FALHA no drag & drop para slot {slot}")
                            print(f"   ‚ö†Ô∏è Isca N√ÉO removida da lista (tentativa novamente)")
                            # Continue para pr√≥ximo slot sem remover a isca

                    except Exception as e:
                        print(f"   üí• EXCE√á√ÉO no slot {slot}: {e}")
                        import traceback
                        traceback.print_exc()
                        print(f"   ‚Ü™Ô∏è Continuando para pr√≥ximo slot...")
                        continue

                    print(f"   ‚úÖ Slot {slot} processado - continuando para pr√≥ximo...")

                print(f"\n‚úÖ FASE 3 COMPLETA: Processamento de iscas finalizado!")
            else:
                print(f"\n‚ùå FASE 3 N√ÉO EXECUTADA: Lista no_bait_slots est√° vazia ou False")
                print(f"   üìù Motivos poss√≠veis:")
                print(f"      ‚Ä¢ Catch Viewer n√£o detectou varas SEM isca")
                print(f"      ‚Ä¢ Todas as varas colocadas na Fase 2 eram COM isca")
                print(f"      ‚Ä¢ Erro na detec√ß√£o do Catch Viewer")
                print(f"   üí° Resultado: Nenhuma isca foi aplicada")

            # ‚úÖ Limpeza final
            if hasattr(self, '_slots_needing_bait_from_phase2'):
                delattr(self, '_slots_needing_bait_from_phase2')

            print("\nüéâ SISTEMA DE MANUTEN√á√ÉO COMPLETO COM PRIORIZA√á√ÉO!")
            print("‚úÖ Resultado: Varas COM isca priorizadas, varas SEM isca recarregadas")
            print("="*70)

        except Exception as e:
            print(f"‚ùå Erro no sistema de manuten√ß√£o: {e}")
            import traceback
            traceback.print_exc()
            # Limpeza em caso de erro
            if hasattr(self, '_slots_needing_bait_from_phase2'):
                delattr(self, '_slots_needing_bait_from_phase2')

    def remove_broken_rod_from_slot(self, slot):
        """üóëÔ∏è PROCESSO CORRETO DE 9 PASSOS para remover vara quebrada"""
        print(f"üóëÔ∏è [INICIANDO] Processo de 9 passos para vara quebrada no slot {slot}...")

        # Coordenadas dos slots (Y=1005 para todos)
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            print(f"‚ùå Slot {slot} inv√°lido!")
            return

        slot_x, slot_y = slot_positions[slot]
        bait_position = (721, 359)  # Posi√ß√£o FIXA da isca
        trash_position = (1400, 1000)  # Posi√ß√£o do lixo

        try:
            print(f"üéØ Vara quebrada detectada no slot {slot} - posi√ß√£o ({slot_x}, {slot_y})")

            # [1/9] Mover mouse para vara quebrada
            print(f"   [1/9] Movendo mouse para vara quebrada ({slot_x}, {slot_y})")
            pyautogui.moveTo(slot_x, slot_y)
            time.sleep(0.3)

            # [2/9] Clicar na vara quebrada (detec√ß√£o)
            print(f"   [2/9] Clicando na vara quebrada")
            pyautogui.click(slot_x, slot_y, button='left')
            time.sleep(0.5)

            # [3/9] Mover para posi√ß√£o FIXA da isca (721,359)
            print(f"   [3/9] Movendo para posi√ß√£o FIXA da isca ({bait_position[0]}, {bait_position[1]})")
            pyautogui.moveTo(bait_position[0], bait_position[1])
            time.sleep(0.3)

            # [4/9] Remover isca (clique direito)
            print(f"   [4/9] Removendo isca (clique direito)")
            pyautogui.click(bait_position[0], bait_position[1], button='right')
            time.sleep(0.5)

            # [5/9] Retornar para vara quebrada
            print(f"   [5/9] Retornando para vara quebrada ({slot_x}, {slot_y})")
            pyautogui.moveTo(slot_x, slot_y)
            time.sleep(0.3)

            # [6/9] Segurar bot√£o esquerdo na vara quebrada
            print(f"   [6/9] Segurando bot√£o esquerdo na vara quebrada")
            pyautogui.mouseDown(button='left')
            time.sleep(0.3)

            # [7/9] Arrastar para lixo (1400,1000)
            print(f"   [7/9] Arrastando para lixo ({trash_position[0]}, {trash_position[1]})")
            pyautogui.moveTo(trash_position[0], trash_position[1], duration=0.7)

            # [8/9] Soltar para descartar vara quebrada
            print(f"   [8/9] Soltando para descartar vara quebrada")
            focus_game_window()  # Garantir foco
            pyautogui.mouseUp(button='left')
            time.sleep(0.5)

            # [9/9] Finalizado
            print(f"   [9/9] ‚úÖ Vara quebrada do slot {slot} descartada com sucesso!")

        except Exception as e:
            # Garantir que o mouse seja liberado em caso de erro
            try:
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
            except:
                pass
            print(f"‚ùå Erro no processo de 9 passos para slot {slot}: {e}")

    def save_broken_rod_to_chest(self, slot):
        """üì¶ Guardar vara quebrada no ba√∫ (clique direito) - NOVA FUNCIONALIDADE"""
        print(f"üì¶ [SAVE_BROKEN] Guardando vara quebrada do slot {slot} no ba√∫...")

        # Coordenadas dos slots (Y=1005 para todos)
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            print(f"‚ùå Slot {slot} inv√°lido!")
            return

        slot_x, slot_y = slot_positions[slot]
        bait_position = (721, 359)  # Posi√ß√£o FIXA da isca

        try:
            print(f"üéØ Vara quebrada detectada no slot {slot} - posi√ß√£o ({slot_x}, {slot_y})")

            # [1/5] Mover mouse para vara quebrada
            print(f"   [1/5] Movendo mouse para vara quebrada ({slot_x}, {slot_y})")
            pyautogui.moveTo(slot_x, slot_y)
            time.sleep(0.3)

            # [2/5] Clicar na vara quebrada (selecionar)
            print(f"   [2/5] Selecionando vara quebrada")
            pyautogui.click(slot_x, slot_y, button='left')
            time.sleep(0.5)

            # [3/5] Mover para posi√ß√£o FIXA da isca e remover
            print(f"   [3/5] Removendo isca da vara quebrada")
            pyautogui.moveTo(bait_position[0], bait_position[1])
            time.sleep(0.3)
            pyautogui.click(bait_position[0], bait_position[1], button='right')
            time.sleep(0.5)

            # [4/5] Retornar para vara quebrada
            print(f"   [4/5] Retornando para vara quebrada ({slot_x}, {slot_y})")
            pyautogui.moveTo(slot_x, slot_y)
            time.sleep(0.3)

            # [5/5] Clique direito para guardar no ba√∫
            print(f"   [5/5] üì¶ Clique direito para guardar vara quebrada no ba√∫")
            pyautogui.click(slot_x, slot_y, button='right')
            time.sleep(0.8)  # Aguardar transfer√™ncia

            print(f"   ‚úÖ Vara quebrada do slot {slot} guardada no ba√∫ com sucesso!")

        except Exception as e:
            print(f"‚ùå Erro ao guardar vara quebrada do slot {slot}: {e}")

    def scan_chest_rods(self):
        """Escanear e mapear varas no ba√∫ - USANDO MESMA L√ìGICA DO CATCH VIEWER"""
        print("üîç Escaneando varas no ba√∫ com l√≥gica do Catch Viewer...")

        chest_rods = {
            'with_bait': [],    # Varas com isca
            'without_bait': [],  # Varas sem isca
            'detected_positions': set()  # üéØ TRACKING: Evitar usar mesma posi√ß√£o 2x
        }

        # RETRY LOGIC - tentar at√© 3 vezes se n√£o encontrar nada
        max_retries = 3
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    print(f"   üîÑ Tentativa {attempt + 1}/{max_retries} (aguardando 1s)...")
                    time.sleep(1.0)

                print("   üîç Escaneando varas no ba√∫...")
                # √Årea do ba√∫ EXPANDIDA para capturar mais varas
                # üéØ √ÅREA EXATA DO BA√ö: Coordenadas fornecidas pelo usu√°rio
                chest_area = (1214, 117, 1834, 928)  # x1, y1, x2, y2 - √°rea exata do ba√∫
                print(f"   üéØ √Årea do ba√∫ CONFIGURADA: {chest_area}")
                print(f"   üìê Dimens√µes: {chest_area[2]-chest_area[0]}x{chest_area[3]-chest_area[1]} pixels")
                print(f"   üìç Superior esquerdo: ({chest_area[0]}, {chest_area[1]})")
                print(f"   üìç Inferior direito: ({chest_area[2]}, {chest_area[3]})")

                # Templates para detectar varas no ba√∫ (PRIORIDADE ABSOLUTA PARA VARAS COM ISCA)
                # üéØ CORRE√á√ÉO CONFIRMADA: VARANOBAUCI = COM ISCA, enbausi = SEM ISCA
                rod_templates = {
                'comisca': ['VARANOBAUCI.png', 'varanobauci.png', 'comiscavara.png', 'namaocomisca.png', 'comiscanamao.png', 'varacomisca.png'],  # Varas COM isca - VARANOBAUCI EST√Å CORRETA AQUI!
                'semisca': ['enbausi.png', 'ENBAUSI.png', 'semiscavara.png', 'namaosemisca.png', 'varasemisca.png', 'semiscanam.png']  # Varas SEM isca - enbausi confirmada
                }

                # ‚úÖ CLASSIFICA√á√ÉO CONFIRMADA PELO USU√ÅRIO:
                print("   ‚úÖ CONFIRMADO: 'VARANOBAUCI.png' = COM ISCA")
                print("   ‚úÖ CONFIRMADO: 'enbausi.png' = SEM ISCA")

                print(f"   üéØ [DEBUG] Templates de varas COM isca: {rod_templates['comisca']}")
                print(f"   üéØ [DEBUG] Templates de varas SEM isca: {rod_templates['semisca']}")
                print(f"   üß† [L√ìGICA DE DIFERENCIA√á√ÉO]:")
                print(f"      üìö COM ISCA = Se template est√° em rod_templates['comisca'] ‚Üí vai para with_bait[]")
                print(f"      üìö SEM ISCA = Se template est√° em rod_templates['semisca'] ‚Üí vai para without_bait[]")

                # Definir pasta de templates
                templates_folder = "templates"

                print(f"   üìÅ Procurando templates na pasta: {templates_folder}")

                # ‚úÖ DEBUG ESPEC√çFICO: Verificar arquivos VARANOBAUCI
                varanobauci_variants = ['VARANOBAUCI.png', 'varanobauci.png', 'VaraNoBauCi.png']
                for variant in varanobauci_variants:
                    variant_path = os.path.join(templates_folder, variant)
                    exists = os.path.exists(variant_path)
                    print(f"   üîç [DEBUG] {variant}: {'‚úÖ EXISTE' if exists else '‚ùå N√ÉO EXISTE'}")
                    if exists:
                        print(f"      üìç Caminho completo: {os.path.abspath(variant_path)}")

                # Capturar tela UMA VEZ para todas as detec√ß√µes (evita mudan√ßas entre capturas)
                with mss.mss() as sct:
                    screenshot = sct.grab({"top": chest_area[1], "left": chest_area[0],
                                         "width": chest_area[2]-chest_area[0],
                                         "height": chest_area[3]-chest_area[1]})
                    img = np.array(screenshot)
                    img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

                print(f"   üì∑ Screenshot √∫nico capturado: {img.shape}")

                # Set para evitar detec√ß√µes duplicadas
                detected_positions = set()

                for rod_type, templates in rod_templates.items():
                    rod_type_desc = "COM ISCA" if rod_type == 'comisca' else "SEM ISCA"
                    print(f"   üîç Procurando varas {rod_type} ({rod_type_desc})...")
                    print(f"      üìã Templates para {rod_type_desc}: {templates}")

                    for template_name in templates:
                        template_path = os.path.join(templates_folder, template_name)
                        print(f"      üìÑ Testando: {template_name}")

                        if not os.path.exists(template_path):
                            print(f"      ‚ùå Template n√£o encontrado: {template_path}")
                            # DEBUG ESPEC√çFICO para VARANOBAUCI
                            if 'varanobauci' in template_name.lower():
                                print(f"      üö® [VARANOBAUCI] ARQUIVO N√ÉO ENCONTRADO: {template_path}")
                                print(f"      üìÇ Verificar se arquivo existe no diret√≥rio templates/")
                            continue

                        # Detectar template no ba√∫
                        template = cv2.imread(template_path)
                        if template is None:
                            print(f"      ‚ùå Erro ao carregar template: {template_name}")
                            continue

                        print(f"      ‚úÖ Template carregado: {template.shape}")

                        # ‚úÖ CORRE√á√ÉO: Validar tamanho do template antes do matching
                        try:
                            # Verificar se o template n√£o √© maior que a imagem capturada
                            if (template.shape[0] > img.shape[0] or template.shape[1] > img.shape[1]):
                                print(f"      ‚ö†Ô∏è Template {template_name} muito grande ({template.shape}) para imagem ({img.shape}) - ignorando")
                                continue

                            # Template matching
                            result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)
                        except cv2.error as cv_err:
                            if "assertion failed" in str(cv_err).lower():
                                print(f"      ‚ùå OpenCV assertion error {template_name}: Template size incompat√≠vel - ignorando")
                            else:
                                print(f"      ‚ùå OpenCV error {template_name}: {cv_err}")
                            continue
                        except Exception as e:
                            print(f"      ‚ùå Erro no template matching {template_name}: {e}")
                            continue

                        # üéØ SEMPRE usar threshold unificado da UI
                        confidence_threshold = self.get_unified_template_threshold(template_name)
                        print(f"      üéØ {template_name} ‚Üí Threshold unificado: {confidence_threshold}")

                        # Verificar melhor match
                        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
                        print(f"      üìä Melhor match: {max_val:.3f} (threshold: {confidence_threshold})")

                        locations = np.where(result >= confidence_threshold)
                        matches_found = len(locations[0])
                        print(f"      üîç Matches encontrados: {matches_found}")

                        for y, x in zip(locations[0], locations[1]):
                            # Converter coordenadas para tela completa
                            screen_x = x + chest_area[0] + template.shape[1]//2  # Centro do template
                            screen_y = y + chest_area[1] + template.shape[0]//2  # Centro do template

                            # Evitar detec√ß√µes duplicadas na mesma posi√ß√£o exata (raio de 15 pixels)
                            position_key = (screen_x // 15, screen_y // 15)  # Agrupamento mais preciso
                            if position_key in detected_positions:
                                continue
                            detected_positions.add(position_key)

                            # Validar se coordenadas est√£o dentro da √°rea v√°lida do ba√∫
                            if screen_x < chest_area[0] or screen_x > chest_area[2] or screen_y < chest_area[1] or screen_y > chest_area[3]:
                                print(f"      ‚ö†Ô∏è Coordenada fora da √°rea v√°lida: ({screen_x}, {screen_y}) - ignorando")
                                continue

                            rod_info = {
                                'x': screen_x,
                                'y': screen_y,
                                'template': template_name,
                                'confidence': result[y, x]
                            }

                            # Priorizar templates de alta qualidade
                            priority_bonus = 0.0
                            if template_name in ['VARANOBAUCI.png', 'enbausi.png']:
                                priority_bonus = 0.1  # Bonus para templates priorit√°rios
                                print(f"      üåü TEMPLATE PRIORIT√ÅRIO: {template_name} - bonus aplicado!")

                            rod_info['confidence'] += priority_bonus

                            print(f"      ‚úÖ Vara detectada em ({screen_x}, {screen_y}) - conf: {result[y, x]:.3f} (final: {rod_info['confidence']:.3f})")

                            if rod_type == 'comisca':
                                chest_rods['with_bait'].append(rod_info)
                                print(f"      ‚ûï [COM ISCA] Template: {template_name} ‚Üí Lista: with_bait ‚Üí Pos: ({screen_x}, {screen_y})")
                                print(f"      üß† [L√ìGICA] Como {template_name} est√° em rod_templates['comisca'] = √â VARA COM ISCA!")
                                # DEBUG ESPEC√çFICO para VARANOBAUCI
                                if 'varanobauci' in template_name.lower():
                                    print(f"      üéâ [VARANOBAUCI] PRIORIT√ÅRIA DETECTADA! Posi√ß√£o: ({screen_x}, {screen_y})")
                            else:
                                chest_rods['without_bait'].append(rod_info)
                                print(f"      ‚ûï [SEM ISCA] Template: {template_name} ‚Üí Lista: without_bait ‚Üí Pos: ({screen_x}, {screen_y})")
                                print(f"      üß† [L√ìGICA] Como {template_name} est√° em rod_templates['semisca'] = √â VARA SEM ISCA!")
                                if template_name == 'enbausi.png':
                                    print(f"      üéØ [IMPORTANTE] enbausi classificado corretamente como SEM isca!")

                # Ordenar por confian√ßa (melhor primeiro)
                chest_rods['with_bait'].sort(key=lambda x: x['confidence'], reverse=True)
                chest_rods['without_bait'].sort(key=lambda x: x['confidence'], reverse=True)

                # L√ìGICA ESPECIAL: Se n√£o encontrou VARANOBAUCI (com isca), procurar especificamente por enbausi
                if len(chest_rods['with_bait']) == 0 and len(chest_rods['without_bait']) == 0:
                    print("   ‚ö†Ô∏è Nenhuma vara detectada com templates padr√£o")
                    print("   üîç Procurando especificamente por enbausi com threshold reduzido...")

                    # Tentar detectar enbausi com threshold mais baixo
                    template_path = os.path.join(templates_folder, 'enbausi.png')
                    if os.path.exists(template_path):
                        template = cv2.imread(template_path)
                        if template is not None:
                            result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)
                            lowered_threshold = 0.6  # Threshold reduzido para enbausi
                            locations = np.where(result >= lowered_threshold)

                            print(f"      üéØ Procurando enbausi com threshold: {lowered_threshold}")

                            for y, x in zip(locations[0], locations[1]):
                                screen_x = x + chest_area[0] + template.shape[1]//2
                                screen_y = y + chest_area[1] + template.shape[0]//2

                                # Verificar se j√° n√£o foi detectado
                                position_key = (screen_x // 40, screen_y // 40)
                                if position_key not in detected_positions:
                                    detected_positions.add(position_key)

                                    confidence = result[y, x]
                                    rod_info = {
                                        'x': screen_x,
                                        'y': screen_y,
                                        'confidence': confidence,
                                        'template': 'enbausi.png'
                                    }
                                    chest_rods['without_bait'].append(rod_info)
                                    print(f"      ‚úÖ enbausi detectado em ({screen_x}, {screen_y}) - conf: {confidence:.3f}")

                            if chest_rods['without_bait']:
                                print(f"   üéØ Encontradas {len(chest_rods['without_bait'])} varas enbausi com threshold reduzido!")

                total_rods = len(chest_rods['with_bait']) + len(chest_rods['without_bait'])
                print(f"   ‚úÖ Encontradas {len(chest_rods['with_bait'])} varas COM isca")
                if chest_rods['with_bait']:
                    for i, rod in enumerate(chest_rods['with_bait']):
                        print(f"      {i+1}. {rod['template']} em ({rod['x']}, {rod['y']}) - conf: {rod['confidence']:.3f}")

                print(f"   ‚ö†Ô∏è Encontradas {len(chest_rods['without_bait'])} varas SEM isca")
                if chest_rods['without_bait']:
                    for i, rod in enumerate(chest_rods['without_bait']):
                        print(f"      {i+1}. {rod['template']} em ({rod['x']}, {rod['y']}) - conf: {rod['confidence']:.3f}")

                print(f"   üéØ [RESUMO DA DIFERENCIA√á√ÉO]:")
                print(f"      üß† Sistema diferencia baseado no NOME DO TEMPLATE detectado")
                print(f"      üìä Templates COM isca detectados: {[rod['template'] for rod in chest_rods['with_bait']]}")
                print(f"      üìä Templates SEM isca detectados: {[rod['template'] for rod in chest_rods['without_bait']]}")
                print(f"      ‚ö° PRIORIDADE: Varas COM isca sempre usadas primeiro!")

                print(f"   üìä Total: {total_rods} varas detectadas")

                # DEBUG CR√çTICO: Verificar se VARANOBAUCI foi detectado
                varanobauci_found = any('varanobauci' in rod['template'].lower() for rod in chest_rods['with_bait'])
                print(f"   üéØ [DEBUG] VARANOBAUCI detectado: {'‚úÖ SIM' if varanobauci_found else '‚ùå N√ÉO'}")

                # Se encontrou pelo menos 1 vara, sucesso!
                if total_rods > 0:
                    print(f"   üéâ Scan bem-sucedido na tentativa {attempt + 1}")
                    return chest_rods
                elif attempt < max_retries - 1:
                    print(f"   ‚ö†Ô∏è Nenhuma vara encontrada, tentando novamente...")
                    continue
                else:
                    print(f"   ‚ùå Nenhuma vara encontrada ap√≥s {max_retries} tentativas")
                    return chest_rods

            except Exception as e:
                print(f"‚ùå Erro na tentativa {attempt + 1}: {e}")
                if attempt == max_retries - 1:
                    print(f"‚ùå Falha final ap√≥s {max_retries} tentativas")
                    return chest_rods

    def place_rod_in_empty_slot(self, slot, existing_chest_rods=None):
        """Colocar vara do ba√∫ em slot vazio (prioriza varas com isca)"""
        print(f"üîÑ Colocando vara no slot {slot}...")

        # Coordenadas dos slots
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            print(f"‚ùå Slot {slot} inv√°lido!")
            return False

        try:
            # ‚úÖ CORRE√á√ÉO: SEMPRE verificar se cache n√£o est√° vazio ou obsoleto
            chest_rods = existing_chest_rods

            if not chest_rods or (not chest_rods['with_bait'] and not chest_rods['without_bait']):
                # Cache vazio ou n√£o existe - precisa escanear
                print(f"   ‚ö†Ô∏è Cache vazio/inv√°lido - escaneando novamente...")
                chest_rods = self.scan_chest_rods()
            else:
                print(f"   üìã Usando cache de varas: {len(chest_rods['with_bait'])} COM isca, {len(chest_rods['without_bait'])} SEM isca")

            # ‚úÖ VALIDA√á√ÉO: Confirmar que h√° varas dispon√≠veis com RETRY
            total_available = len(chest_rods['with_bait']) + len(chest_rods['without_bait'])
            if total_available == 0:
                print(f"   ‚ùå NENHUMA vara encontrada no primeiro scan!")
                print(f"   üîÑ Tentando re-scan com delay para slot {slot}...")
                time.sleep(1.5)
                chest_rods = self.scan_chest_rods()
                total_available = len(chest_rods['with_bait']) + len(chest_rods['without_bait'])

                if total_available == 0:
                    print(f"   ‚ùå Nenhuma vara encontrada ap√≥s retry! Slot {slot} n√£o pode ser preenchido.")
                    return False
                else:
                    print(f"   ‚úÖ Retry encontrou {total_available} varas dispon√≠veis!")

            # ‚úÖ CORRE√á√ÉO: GARANTIR prioriza√ß√£o de varas COM isca
            rod_to_use = None
            rod_index = None

            # üéØ CORRE√á√ÉO CR√çTICA: FOR√áAR prioridade ABSOLUTA de varas COM isca
            with_bait_varas = chest_rods.get('with_bait', [])
            without_bait_varas = chest_rods.get('without_bait', [])

            print(f"   üìä Dispon√≠vel: {len(with_bait_varas)} COM isca, {len(without_bait_varas)} SEM isca")

            # üî• DEBUG: Mostrar exatamente o que temos
            if with_bait_varas:
                print(f"   üé£ Varas COM isca dispon√≠veis:")
                for i, vara in enumerate(with_bait_varas[:3]):  # Mostrar at√© 3
                    print(f"      {i+1}. {vara['template']} (conf: {vara.get('confidence', 0):.3f})")
            if without_bait_varas:
                print(f"   ‚ö†Ô∏è Varas SEM isca dispon√≠veis:")
                for i, vara in enumerate(without_bait_varas[:3]):  # Mostrar at√© 3
                    print(f"      {i+1}. {vara['template']} (conf: {vara.get('confidence', 0):.3f})")

            # üéØ FOR√áAR PRIORIZA√á√ÉO ABSOLUTA: COM isca SEMPRE primeiro
            # Verificar se as listas realmente existem e t√™m conte√∫do
            has_with_bait = with_bait_varas is not None and len(with_bait_varas) > 0
            has_without_bait = without_bait_varas is not None and len(without_bait_varas) > 0
            
            print(f"   üîç [VALIDA√á√ÉO] has_with_bait={has_with_bait}, has_without_bait={has_without_bait}")
            
            if has_with_bait:
                # üèÜ SEMPRE pegar vara COM isca se existir
                rod_to_use = with_bait_varas[0]
                rod_index = ('with_bait', 0)
                print(f"   üèÜ GARANTIDO COM ISCA: {rod_to_use['template']} em ({rod_to_use['x']}, {rod_to_use['y']}) ‚Üí Slot {slot}")
                print(f"   ‚úÖ Esta vara J√Å TEM ISCA - n√£o precisar√° recarga!")
            elif has_without_bait:
                # ‚ö†Ô∏è S√≥ usar SEM isca se REALMENTE n√£o tiver COM isca
                rod_to_use = without_bait_varas[0]
                rod_index = ('without_bait', 0)
                print(f"   ‚ö†Ô∏è SEM OP√á√ÉO - Usando vara SEM ISCA: {rod_to_use['template']} ‚Üí Slot {slot}")
                print(f"   üìå Esta vara PRECISAR√Å de isca na Fase 3")
            else:
                print(f"‚ùå Nenhuma vara encontrada no ba√∫ para o slot {slot}")
                print(f"   üìä Debug: with_bait={with_bait_varas}, without_bait={without_bait_varas}")
                return False

            # Arrastar vara do ba√∫ para o slot
            slot_x, slot_y = slot_positions[slot]
            print(f"   üñ±Ô∏è [ARRASTO] ORIGEM: ({rod_to_use['x']}, {rod_to_use['y']}) [BA√ö] ‚Üí DESTINO: ({slot_x}, {slot_y}) [SLOT {slot}]")
            print(f"   üìç [COORDENADAS] Vara {rod_to_use['template']} localizada no BA√ö em X={rod_to_use['x']}, Y={rod_to_use['y']}")
            print(f"   üéØ [DESTINO] Slot {slot} est√° localizado em X={slot_x}, Y={slot_y}")

            # Desabilitar fail-safe temporariamente para evitar erro
            original_failsafe = pyautogui.FAILSAFE
            pyautogui.FAILSAFE = False

            try:
                # CORRE√á√ÉO ESPECIAL PARA SLOT 1 - precisa de mais tempo e movimento mais cuidadoso
                if slot == 1:
                    print(f"   ‚ö†Ô∏è SLOT 1 DETECTADO - Usando sequ√™ncia especial de arrasto")

                    # Mover para vara primeiro
                    print(f"   üñ±Ô∏è [SLOT 1] Movendo para vara em ({rod_to_use['x']}, {rod_to_use['y']})")
                    pyautogui.moveTo(rod_to_use['x'], rod_to_use['y'])
                    time.sleep(0.3)  # Otimizado para fluidez

                    # Clicar na vara para garantir sele√ß√£o
                    print(f"   üñ±Ô∏è [SLOT 1] Clicando na vara para garantir sele√ß√£o")
                    pyautogui.click()
                    time.sleep(0.2)

                    # Agora sim, segurar para arrastar
                    print(f"   üñ±Ô∏è [SLOT 1] Segurando vara com bot√£o esquerdo")
                    pyautogui.mouseDown(button='left')
                    time.sleep(0.3)  # Otimizado

                    # Arrastar usando dragTo que √© mais confi√°vel
                    print(f"   üñ±Ô∏è [SLOT 1] Arrastando: ({rod_to_use['x']}, {rod_to_use['y']}) ‚Üí ({slot_x}, {slot_y})")
                    pyautogui.dragTo(slot_x, slot_y, duration=0.6, button='left')  # Mais r√°pido

                    # Pequena pausa antes de soltar
                    time.sleep(0.2)

                    # Soltar
                    print(f"   üñ±Ô∏è [SLOT 1] COMPLETADO! Vara {rod_to_use['template']} solta no slot 1 em ({slot_x}, {slot_y})")
                    focus_game_window()  # Garantir foco
                    pyautogui.mouseUp(button='left')
                    time.sleep(0.3)

                else:
                    # Comportamento normal para outros slots
                    print(f"   üñ±Ô∏è [SLOT {slot}] Movendo para vara: BA√ö ({rod_to_use['x']}, {rod_to_use['y']})")
                    pyautogui.moveTo(rod_to_use['x'], rod_to_use['y'])
                    time.sleep(0.2)

                    # Segurar bot√£o esquerdo na vara
                    print(f"   üñ±Ô∏è [SLOT {slot}] Segurando vara {rod_to_use['template']}")
                    pyautogui.mouseDown(button='left')
                    time.sleep(0.2)

                    # Arrastar para o slot
                    print(f"   üñ±Ô∏è [SLOT {slot}] Arrastando: ({rod_to_use['x']}, {rod_to_use['y']}) ‚Üí ({slot_x}, {slot_y})")
                    pyautogui.moveTo(slot_x, slot_y, duration=0.4)  # Mais r√°pido

                    # Soltar vara no slot
                    print(f"   üñ±Ô∏è [SLOT {slot}] COMPLETADO! Vara {rod_to_use['template']} solta em ({slot_x}, {slot_y})")
                    focus_game_window()  # Garantir foco
                    pyautogui.mouseUp(button='left')
                    time.sleep(0.2)  # Mais fluido

            finally:
                # Restaurar fail-safe
                pyautogui.FAILSAFE = original_failsafe

            # üéØ CRITICAL: Remover vara usada do cache E marcar posi√ß√£o como usada
            if rod_index:
                list_type, index = rod_index
                if list_type == 'with_bait' and len(chest_rods['with_bait']) > index:
                    removed_rod = chest_rods['with_bait'].pop(index)
                    # Marcar posi√ß√£o como usada para evitar tentativa de usar de novo
                    if 'detected_positions' in chest_rods:
                        position_key = f"{removed_rod['x']},{removed_rod['y']}"
                        chest_rods['detected_positions'].add(position_key)
                    print(f"   ‚ôªÔ∏è Vara COM isca removida e marcada como usada: {removed_rod['template']} @ ({removed_rod['x']}, {removed_rod['y']})")
                elif list_type == 'without_bait' and len(chest_rods['without_bait']) > index:
                    removed_rod = chest_rods['without_bait'].pop(index)
                    # Marcar posi√ß√£o como usada para evitar tentativa de usar de novo
                    if 'detected_positions' in chest_rods:
                        position_key = f"{removed_rod['x']},{removed_rod['y']}"
                        chest_rods['detected_positions'].add(position_key)
                    print(f"   ‚ôªÔ∏è Vara SEM isca removida e marcada como usada: {removed_rod['template']} @ ({removed_rod['x']}, {removed_rod['y']})")

            print(f"‚úÖ Vara colocada no slot {slot}")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao colocar vara no slot {slot}: {e}")
            return False

    def scan_all_baits_in_chest(self):
        """Escanear TODAS as iscas dispon√≠veis no ba√∫ de uma vez - COM RETRY LOGIC"""
        print("üîç Escaneando todas as iscas no ba√∫...")
        all_baits = []

        # RETRY LOGIC - tentar at√© 3 vezes se n√£o encontrar nada
        max_retries = 3
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    print(f"   üîÑ Tentativa {attempt + 1}/{max_retries} (aguardando 1s)...")
                    time.sleep(1.0)
                    all_baits = []  # Reset da lista para nova tentativa
                # üéØ Usar sistema unificado de prioridade de iscas
                bait_mapping = self.get_bait_template_mapping()
                sorted_bait_names = self.get_sorted_bait_priority()

                # üéØ Mapeamento correto de nomes para exibi√ß√£o
                display_names = {
                    'carne de urso': 'Carne de Urso',
                    'carne de lobo': 'Carne de Lobo',
                    'trout': 'Trout',
                    'grub': 'Grub',
                    'worm': 'Worm'  # üêõ MINHOCA mapeada corretamente
                }

                bait_priority = []
                for bait_name in sorted_bait_names:
                    template_file = bait_mapping.get(bait_name)
                    if template_file:
                        display_name = display_names.get(bait_name, bait_name.title())
                        bait_priority.append({
                            'template': template_file,
                            'name': display_name  # üéØ Nome correto para exibi√ß√£o
                        })

                # üéØ √ÅREA EXATA DO BA√ö: Coordenadas fornecidas pelo usu√°rio
                chest_area = (1214, 117, 1834, 928)  # x1, y1, x2, y2 - √°rea exata do ba√∫

                # Capturar tela UMA VEZ
                with mss.mss() as sct:
                    screenshot = sct.grab({"top": chest_area[1], "left": chest_area[0],
                                         "width": chest_area[2]-chest_area[0],
                                         "height": chest_area[3]-chest_area[1]})
                    img = np.array(screenshot)
                    img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

                # Procurar TODAS as iscas de cada tipo
                for bait in bait_priority:
                    template_path = os.path.join("templates", bait['template'])
                    if not os.path.exists(template_path):
                        continue

                    template = cv2.imread(template_path)
                    if template is None:
                        continue

                    # Template matching
                    result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)

                    # üéØ Usar threshold unificado da UI
                    confidence_threshold = self.get_unified_template_threshold(bait['template'])
                    print(f"      üéØ {bait['name']}: Usando threshold unificado = {confidence_threshold}")

                    # Encontrar TODAS as ocorr√™ncias
                    locations = np.where(result >= confidence_threshold)

                    for y, x in zip(locations[0], locations[1]):
                        # Converter para coordenadas da tela
                        bait_x = x + chest_area[0] + template.shape[1]//2
                        bait_y = y + chest_area[1] + template.shape[0]//2

                        # Evitar duplicatas pr√≥ximas (reduzido de 30 para 20 pixels)
                        is_duplicate = False
                        for existing in all_baits:
                            if abs(existing['x'] - bait_x) < 20 and abs(existing['y'] - bait_y) < 20:
                                is_duplicate = True
                                break

                        if not is_duplicate:
                            all_baits.append({
                                'x': bait_x,
                                'y': bait_y,
                                'name': bait['name'],
                                'confidence': result[y, x]
                            })
                            print(f"   ‚úÖ {bait['name']} encontrada em ({bait_x}, {bait_y})")

                # üéØ Ordenar por prioridade usando configura√ß√£o do config.json
                # Carregar prioridades do config se n√£o estiver carregado
                if not hasattr(self, 'bait_priority'):
                    self.load_bait_priority_config()
                
                # Mapear nomes de exibi√ß√£o para nomes do config
                display_to_config = {
                    'Carne de Urso': 'carne de urso',
                    'Carne de Lobo': 'carne de lobo',
                    'Trout': 'trout',
                    'Grub': 'grub',
                    'Worm': 'worm',
                    'Smalltrout': 'smalltrout'
                }
                
                # Ordenar usando prioridade do config (menor n√∫mero = maior prioridade)
                all_baits.sort(key=lambda x: self.bait_priority.get(
                    display_to_config.get(x['name'], x['name'].lower()), 99
                ))

                print(f"   üìä Total: {len(all_baits)} iscas encontradas")

                # Se encontrou pelo menos 1 isca, sucesso!
                if len(all_baits) > 0:
                    print(f"   üéâ Scan de iscas bem-sucedido na tentativa {attempt + 1}")
                    return all_baits
                elif attempt < max_retries - 1:
                    print(f"   ‚ö†Ô∏è Nenhuma isca encontrada, tentando novamente...")
                    continue
                else:
                    print(f"   ‚ùå Nenhuma isca encontrada ap√≥s {max_retries} tentativas")
                    return []

            except Exception as e:
                print(f"‚ùå Erro na tentativa de scan de iscas {attempt + 1}: {e}")
                if attempt == max_retries - 1:
                    print(f"‚ùå Falha final no scan de iscas ap√≥s {max_retries} tentativas")
                    return []

    def reload_bait_in_slot_with_cache_improved(self, slot, bait_info):
        """Recarregar isca em slot com confirma√ß√£o de sucesso"""
        print(f"üé£ Recarregando isca no slot {slot} com {bait_info['name']}...")

        # ‚úÖ CORRE√á√ÉO: Usar detec√ß√£o direta em tempo real ao inv√©s do Catch Viewer
        print("   üîÑ For√ßando detec√ß√£o em tempo real (ignorando Catch Viewer desatualizado)...")
        initial_status = self.detect_rod_status_in_slot_REALTIME(slot)
        print(f"   üîç Status REAL do slot {slot}: {initial_status}")

        if initial_status == "empty":
            print(f"   ‚ö†Ô∏è Slot {slot} est√° vazio (sem vara) - pulando isca")
            return "skip"  # N√£o pode colocar isca em slot vazio
        elif initial_status == "with_bait":
            print(f"   ‚úÖ Slot {slot} j√° tem isca - pulando")
            return "skip"  # J√° tem isca, n√£o precisa fazer nada
        elif initial_status == "broken":
            print(f"   ‚ö†Ô∏è Slot {slot} tem vara quebrada - pulando isca")
            return "skip"  # N√£o coloca isca em vara quebrada
        elif initial_status != "no_bait":
            print(f"   ‚ö†Ô∏è Slot {slot} status desconhecido ({initial_status}) - pulando")
            return "skip"  # Status desconhecido, n√£o procede

        # Executar drag & drop
        drag_success = self._execute_drag_drop_bait(slot, bait_info)
        if not drag_success:
            print(f"   ‚ùå Falha no drag & drop para slot {slot}")
            return False

        # CONFIRMAR SUCESSO: Verificar se vara agora tem isca
        time.sleep(1.0)  # Aguardar atualiza√ß√£o visual
        final_status = self.detect_rod_status_in_slot(slot)
        print(f"   üîç Status final do slot {slot}: {final_status}")

        success = final_status == "with_bait"
        if success:
            print(f"   ‚úÖ CONFIRMA√á√ÉO: Isca aplicada com sucesso no slot {slot}")
        else:
            print(f"   ‚ùå CONFIRMA√á√ÉO: Falha - slot {slot} ainda sem isca")

        return success

    def reload_bait_in_slot_with_cache(self, slot, bait_info):
        """Recarregar isca em slot usando informa√ß√£o do cache (vers√£o original)"""
        print(f"üé£ Recarregando isca no slot {slot} com {bait_info['name']}...")
        return self._execute_drag_drop_bait(slot, bait_info)

    def _execute_drag_drop_bait(self, slot, bait_info):
        """üé£ Executar opera√ß√£o de drag & drop IGUAL ao sistema da tecla '0'"""

        # Coordenadas dos slots
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            print(f"‚ùå Slot {slot} inv√°lido!")
            return False

        try:
            slot_x, slot_y = slot_positions[slot]

            # Desabilitar fail-safe temporariamente
            original_failsafe = pyautogui.FAILSAFE
            pyautogui.FAILSAFE = False

            try:
                print(f"   üéØ DRAG & DROP IGUAL TECLA '0' - Processo robusto")

                # PASSO 1: Movimento inicial LENTO para isca (igual tecla 0)
                print(f"   1Ô∏è‚É£ [MOVIMENTO] Movendo para ISCA: ({bait_info['x']}, {bait_info['y']})")
                pyautogui.moveTo(bait_info['x'], bait_info['y'], duration=0.5)  # Movimento mais lento
                time.sleep(0.5)  # Aguardar chegada completa

                # PASSO 2: Segurar bot√£o esquerdo FIRME (igual tecla 0)
                print(f"   2Ô∏è‚É£ [PEGAR] Segurando isca FIRMEMENTE")
                pyautogui.mouseDown(button='left')
                time.sleep(0.4)  # Aguardar pegar firme

                # PASSO 3: Arrastar com dura√ß√£o controlada (igual tecla 0)
                print(f"   3Ô∏è‚É£ [ARRASTO] Arrastando para vara slot {slot}: ({slot_x}, {slot_y})")
                pyautogui.moveTo(slot_x, slot_y, duration=1.0)  # Arrasto mais lento e seguro
                time.sleep(0.4)  # Aguardar chegada

                # PASSO 4: Soltar com confirma√ß√£o (igual tecla 0)
                print(f"   4Ô∏è‚É£ [APLICAR] Soltando isca sobre vara - slot {slot}")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                time.sleep(0.4)  # ‚úÖ OTIMIZADO: Reduzido de 0.8s para 0.4s completar

                # PASSO 5: Valida√ß√£o visual (opcional - como tecla 0)
                print(f"   5Ô∏è‚É£ [VALIDAR] Aguardando isca ser aplicada...")
                time.sleep(0.2)  # ‚úÖ OTIMIZADO: Reduzido de 0.5s para 0.2s

                print(f"   ‚úÖ DRAG & DROP COMPLETO: Isca aplicada no slot {slot}")
                return True

            finally:
                # CR√çTICO: Garantir que mouse n√£o fique pressionado
                try:
                    focus_game_window()  # Garantir foco
                    pyautogui.mouseUp(button='left')
                except:
                    pass
                # Restaurar fail-safe
                pyautogui.FAILSAFE = original_failsafe

        except Exception as e:
            print(f"‚ùå Erro no drag & drop para slot {slot}: {e}")
            # CR√çTICO: Garantir que mouse n√£o fique pressionado
            try:
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
            except:
                pass
            return False

    def detect_rod_status_in_slot_REALTIME(self, slot, debug_save=False):
        """‚úÖ Detectar status REAL de um slot em tempo real (ignora Catch Viewer desatualizado)"""
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            return "invalid_slot"

        try:
            slot_x, slot_y = slot_positions[slot]
            
            # ‚úÖ FOR√áA CONVERS√ÉO PARA INT (corre√ß√£o de ROI)
            slot_x, slot_y = int(slot_x), int(slot_y)

            # ‚úÖ Capturar regi√£o ao redor do slot em TEMPO REAL com tamanho maior
            roi_size = 120  # Aumentado de 80 para 120 para acomodar templates maiores
            left = int(max(0, slot_x - roi_size // 2))
            top = int(max(0, slot_y - roi_size // 2))

            print(f"      üì∑ Capturando ROI slot {slot}: pos=({slot_x},{slot_y}), roi=({left},{top},{roi_size}x{roi_size})")

            with mss.mss() as sct:
                region = {"top": int(top), "left": int(left), "width": int(roi_size), "height": int(roi_size)}
                screenshot = sct.grab(region)
                slot_img = np.array(screenshot)

                # ‚úÖ CORRE√á√ÉO: Converter para formato correto do OpenCV
                if slot_img.shape[2] == 4:  # BGRA
                    slot_img = cv2.cvtColor(slot_img, cv2.COLOR_BGRA2BGR)
                elif slot_img.shape[2] == 3:  # J√° BGR
                    pass  # N√£o precisa converter

                # ‚úÖ DEBUG: Salvar screenshot se solicitado
                if debug_save:
                    import datetime
                    timestamp = datetime.datetime.now().strftime("%H%M%S")
                    debug_filename = f"debug_slot{slot}_realtime_{timestamp}.png"
                    cv2.imwrite(debug_filename, slot_img)
                    print(f"      üì∏ Screenshot salvo: {debug_filename}")

            # ‚úÖ ORDEM COM PRIORIDADE: VARANOBAUCI primeiro (m√°xima prioridade)
            templates_priority = [
                # 1. VARAS COM ISCA - PRIORIDADE VARANOBAUCI PRIMEIRO
                ("templates/VARANOBAUCI.png", "VARANOBAUCI", "with_bait"),  # üéØ PRIORIDADE M√ÅXIMA
                ("templates/varacomisca.png", "varacomisca", "with_bait"),
                ("templates/comiscavara.png", "comiscavara", "with_bait"),
                ("templates/namaocomisca.png", "namaocomisca", "with_bait"),
                ("templates/comiscanamao.png", "comiscanamao", "with_bait"),

                # 2. VARAS QUEBRADAS
                ("templates/varaquebrada.png", "varaquebrada", "broken"),

                # 3. VARAS SEM ISCA (todos os 5 conforme especificado pelo usu√°rio)
                ("templates/varasemisca.png", "varasemisca", "no_bait"),
                ("templates/semiscavara.png", "semiscavara", "no_bait"),
                ("templates/semiscanam.png", "semiscanam", "no_bait"),
                ("templates/namaosemisca.png", "namaosemisca", "no_bait"),
                ("templates/enbausi.png", "enbausi", "no_bait")
            ]

            print(f"      üéØ Testando {len(templates_priority)} templates em ordem de prioridade...")

            for template_path, template_key, status_type in templates_priority:
                if os.path.exists(template_path):
                    template = cv2.imread(template_path)
                    if template is not None:
                        # ‚úÖ CORRE√á√ÉO: Validar tamanho antes do template matching
                        try:
                            # Verificar se o template n√£o √© maior que a imagem do slot
                            if (template.shape[0] > slot_img.shape[0] or template.shape[1] > slot_img.shape[1]):
                                print(f"      ‚ö†Ô∏è Template {template_key} muito grande ({template.shape}) para ROI ({slot_img.shape}) - ignorando")
                                continue

                            # ‚úÖ CORRE√á√ÉO: Garantir mesmo formato para ambas as imagens
                            if len(template.shape) == len(slot_img.shape):
                                # Mesmo n√∫mero de dimens√µes - validar tamanho e usar diretamente
                                result = cv2.matchTemplate(slot_img, template, cv2.TM_CCOEFF_NORMED)
                            else:
                                # Diferentes dimens√µes - converter para grayscale e validar
                                slot_img_proc = cv2.cvtColor(slot_img, cv2.COLOR_BGR2GRAY) if len(slot_img.shape) == 3 else slot_img
                                template_proc = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY) if len(template.shape) == 3 else template

                                # Verificar novamente ap√≥s convers√£o
                                if (template_proc.shape[0] > slot_img_proc.shape[0] or template_proc.shape[1] > slot_img_proc.shape[1]):
                                    print(f"      ‚ö†Ô∏è Template {template_key} muito grande ap√≥s convers√£o - ignorando")
                                    continue

                                result = cv2.matchTemplate(slot_img_proc, template_proc, cv2.TM_CCOEFF_NORMED)
                        except cv2.error as cv_err:
                            if "assertion failed" in str(cv_err).lower():
                                print(f"      ‚ùå OpenCV assertion error {template_key}: Template size incompat√≠vel - ignorando")
                            else:
                                print(f"      ‚ùå OpenCV error {template_key}: {cv_err}")
                            continue
                        except Exception as e:
                            print(f"      ‚ùå Erro no template matching {template_key}: {e}")
                            continue
                        _, max_val, _, _ = cv2.minMaxLoc(result)

                        # ‚úÖ USAR THRESHOLD DA UI com fallback seguro
                        if hasattr(self, 'template_confidence_manager') and self.template_confidence_manager:
                            threshold = self.template_confidence_manager.get_template_confidence(template_key)
                        else:
                            # Fallback: usar thresholds mais baixos para detec√ß√£o real-time
                            fallback_thresholds = {
                                'VARANOBAUCI': 0.6, 'varacomisca': 0.6, 'comiscavara': 0.6, 'namaocomisca': 0.6, 'comiscanamao': 0.6,
                                'varaquebrada': 0.6,
                                'varasemisca': 0.6, 'semiscavara': 0.6, 'semiscanam': 0.6, 'namaosemisca': 0.6, 'enbausi': 0.6
                            }
                            threshold = fallback_thresholds.get(template_key, 0.6)  # Default mais baixo para real-time
                            print(f"      ‚ö†Ô∏è Usando threshold fallback para {template_key}: {threshold}")

                        print(f"      üéØ {template_key}: conf={max_val:.3f}, threshold={threshold}")

                        if max_val >= threshold:
                            print(f"      ‚úÖ DETEC√á√ÉO REAL: {os.path.basename(template_path)} (conf: {max_val:.3f}) = {status_type}")
                            return status_type

            # ‚úÖ Se n√£o detectou nada, mostrar detalhes e retornar vazio
            print(f"      üìä RESUMO DETEC√á√ÉO SLOT {slot}:")
            print(f"         ROI capturado: {roi_size}x{roi_size} pixels")
            print(f"         Templates testados: {len(templates_priority)}")
            print(f"         Nenhum template atingiu threshold m√≠nimo")
            print(f"      ‚ö™ DETEC√á√ÉO REAL: Slot {slot} vazio (nenhum template detectado)")
            return "empty"

        except Exception as e:
            print(f"      ‚ùå Erro na detec√ß√£o real do slot {slot}: {e}")
            return "error"

    def detect_rod_status_in_slot(self, slot):
        """Detectar status espec√≠fico de uma vara em um slot"""
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            return "invalid_slot"

        slot_x, slot_y = slot_positions[slot]
        roi = {
            "left": slot_x - 40,
            "top": slot_y - 40,
            "width": 80,
            "height": 80
        }

        # Verificar vara quebrada primeiro
        if self.detect_template_in_roi(roi, ['varaquebrada.png']):
            return "broken"
        # Verificar vara com isca (incluindo VARANOBAUCI)
        elif self.detect_template_in_roi(roi, ['VARANOBAUCI.png', 'comiscavara.png', 'namaocomisca.png', 'comiscanamao.png']):
            return "with_bait"
        # Verificar vara sem isca
        elif self.detect_template_in_roi(roi, ['semiscavara.png', 'namaosemisca.png', 'varasemisca.png', 'semiscanam.png', 'enbausi.png']):
            return "no_bait"
        else:
            return "empty"

    def reload_bait_in_slot(self, slot):
        """Recarregar isca em vara sem isca (prioridade: urso > lobo > larva)"""
        print(f"üé£ Recarregando isca no slot {slot}...")

        # Coordenadas dos slots
        slot_positions = {
            1: (709, 1005), 2: (805, 1005), 3: (899, 1005),
            4: (992, 1005), 5: (1092, 1005), 6: (1188, 1005)
        }

        if slot not in slot_positions:
            print(f"‚ùå Slot {slot} inv√°lido!")
            return

        try:
            # üéØ Usar sistema unificado de prioridade de iscas
            bait_mapping = self.get_bait_template_mapping()
            sorted_bait_names = self.get_sorted_bait_priority()

            bait_priority = []
            for bait_name in sorted_bait_names:
                template_file = bait_mapping.get(bait_name)
                if template_file:
                    bait_priority.append({
                        'template': template_file,
                        'name': bait_name.title()  # Primeira letra mai√∫scula
                    })

            bait_found = None

            # Definir pasta de templates
            templates_folder = "templates"

            # Procurar iscas no ba√∫ por ordem de prioridade
            for bait in bait_priority:
                template_path = os.path.join(templates_folder, bait['template'])
                if not os.path.exists(template_path):
                    continue

                template = cv2.imread(template_path)
                if template is None:
                    continue

                # üéØ √ÅREA EXATA DO BA√ö: Coordenadas fornecidas pelo usu√°rio
                chest_area = (1214, 117, 1834, 928)  # x1, y1, x2, y2 - √°rea exata do ba√∫

                # Capturar tela do ba√∫
                with mss.mss() as sct:
                    screenshot = sct.grab({"top": chest_area[1], "left": chest_area[0],
                                         "width": chest_area[2]-chest_area[0],
                                         "height": chest_area[3]-chest_area[1]})
                    img = np.array(screenshot)
                    img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

                # Template matching
                result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)
                # üéØ Usar threshold unificado com Catch Viewer
                confidence_threshold = self.get_unified_template_threshold(bait['template'])
                print(f"      üéØ Isca: {bait['template']} ‚Üí Threshold unificado: {confidence_threshold}")

                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                if max_val >= confidence_threshold:
                    # Converter coordenadas para tela completa
                    bait_x = max_loc[0] + chest_area[0] + template.shape[1]//2  # Centro do template
                    bait_y = max_loc[1] + chest_area[1] + template.shape[0]//2  # Centro do template

                    bait_found = {
                        'x': bait_x,
                        'y': bait_y,
                        'name': bait['name'],
                        'confidence': max_val
                    }
                    print(f"   üéØ Encontrada {bait['name']} em ({bait_x}, {bait_y}) - confian√ßa: {max_val:.3f}")
                    break

            if not bait_found:
                print(f"‚ùå Nenhuma isca encontrada no ba√∫ para o slot {slot}")
                return

            # Arrastar isca para a vara
            slot_x, slot_y = slot_positions[slot]
            print(f"   üñ±Ô∏è Arrastando {bait_found['name']} para slot {slot}")

            # Desabilitar fail-safe temporariamente para evitar erro
            original_failsafe = pyautogui.FAILSAFE
            pyautogui.FAILSAFE = False

            try:
                # Primeiro mover para a isca e segurar
                print(f"   üñ±Ô∏è Movendo para isca em ({bait_found['x']}, {bait_found['y']})")
                pyautogui.moveTo(bait_found['x'], bait_found['y'])
                time.sleep(0.3)

                # Segurar bot√£o esquerdo na isca
                print(f"   üñ±Ô∏è Segurando isca")
                pyautogui.mouseDown(button='left')
                time.sleep(0.3)

                # Arrastar para o slot da vara
                print(f"   üñ±Ô∏è Arrastando para slot {slot} ({slot_x}, {slot_y})")
                pyautogui.moveTo(slot_x, slot_y, duration=0.7)

                # Soltar isca sobre a vara
                print(f"   üñ±Ô∏è Soltando isca sobre a vara")
                focus_game_window()  # Garantir foco
                pyautogui.mouseUp(button='left')
                time.sleep(0.5)

            finally:
                # Restaurar fail-safe
                pyautogui.FAILSAFE = original_failsafe

            print(f"‚úÖ {bait_found['name']} adicionada ao slot {slot}")

        except Exception as e:
            print(f"‚ùå Erro ao recarregar isca no slot {slot}: {e}")

    def detect_all_rod_status(self):
        """Detectar status de todas as varas nos slots 1-6"""
        print("üìä Detectando status das varas...")

        # Primeiro tentar usar os dados do catch viewer da interface
        print(f"üîç [DEBUG] hasattr(self, 'ui'): {hasattr(self, 'ui')}")
        print(f"üîç [DEBUG] self.ui is not None: {hasattr(self, 'ui') and self.ui is not None}")

        interface_tracking = None
        if hasattr(self, 'ui') and self.ui and hasattr(self.ui, 'rod_status_tracking'):
            interface_tracking = self.ui.rod_status_tracking
            print(f"üîç [DEBUG] Interface rod_status_tracking found!")
            print(f"üîç [DEBUG] available_with_bait: {interface_tracking.get('available_with_bait', [])}")
            print(f"üîç [DEBUG] available_without_bait: {interface_tracking.get('available_without_bait', [])}")
            print(f"üîç [DEBUG] broken_rods: {interface_tracking.get('broken_rods', [])}")
            print(f"üîç [DEBUG] empty_slots: {interface_tracking.get('empty_slots', [])}")

        if interface_tracking and (
            interface_tracking.get('available_with_bait', []) or
            interface_tracking.get('available_without_bait', []) or
            interface_tracking.get('broken_rods', []) or
            interface_tracking.get('empty_slots', [])):
            print("   üìä Usando dados do Catch Viewer...")

            # Obter dados do catch viewer da interface
            with_bait = interface_tracking.get('available_with_bait', [])
            without_bait = interface_tracking.get('available_without_bait', [])
            broken_rods = interface_tracking.get('broken_rods', [])
            empty_slots_list = interface_tracking.get('empty_slots', [])

            # Debug: mostrar o que o catch viewer tem
            print("   üìã Dados do Catch Viewer:")
            print(f"   ‚úÖ Com isca: {with_bait}")
            print(f"   ‚ö†Ô∏è Sem isca: {without_bait}")
            print(f"   ‚ùå Quebradas: {broken_rods}")
            print(f"   ‚ö™ Vazios: {empty_slots_list}")

            # Converter para o formato esperado pelo sistema de manuten√ß√£o
            status = {}

            # Marcar todos os slots como vazios primeiro
            for slot in range(1, 7):
                status[slot] = "empty"

            # Atualizar com dados do catch viewer
            for slot in with_bait:
                status[slot] = "with_bait"
                print(f"   ‚úÖ Slot {slot}: Vara com isca (via Catch Viewer)")

            for slot in without_bait:
                status[slot] = "no_bait"
                print(f"   ‚ö†Ô∏è Slot {slot}: Vara sem isca (via Catch Viewer)")

            for slot in broken_rods:
                status[slot] = "broken"
                print(f"   ‚ùå Slot {slot}: Vara quebrada (via Catch Viewer)")

            # Usar lista de slots vazios do catch viewer
            for slot in empty_slots_list:
                status[slot] = "empty"
                print(f"   ‚ö™ Slot {slot}: Vazio (via Catch Viewer)")

            print(f"‚úÖ RETORNANDO dados do Catch Viewer: {status}")
            return status

        # Fallback: usar detec√ß√£o direta se o catch viewer n√£o estiver dispon√≠vel
        print("   ‚ö†Ô∏è FALLBACK: Usando detec√ß√£o direta (Catch Viewer n√£o dispon√≠vel)...")

        # Posi√ß√µes dos slots no invent√°rio (coordenadas corretas)
        rod_slots = {
            1: [709, 1005],
            2: [805, 1005],
            3: [899, 1005],
            4: [992, 1005],
            5: [1092, 1005],
            6: [1188, 1005]
        }

        status = {}

        # Capturar tela uma vez para todas as detec√ß√µes
        with mss.mss() as sct:
            screenshot = sct.grab({"top": 0, "left": 0, "width": 1920, "height": 1080})
            screen = np.array(screenshot)
            screen_gray = cv2.cvtColor(screen, cv2.COLOR_BGRA2GRAY)

        # Usar template matching para detectar varas
        for slot, pos in rod_slots.items():
            # üîç DEBUG ESPECIAL PARA SLOT 3
            if slot == 3:
                print(f"\n   üîç [DEBUG SLOT 3] ===== INICIANDO DETEC√á√ÉO SLOT 3 =====")
            print(f"   Verificando slot {slot} na posi√ß√£o {pos}...")
            
            # ‚úÖ FOR√áA CONVERS√ÉO PARA INT (evitar erro de ROI)
            pos_x, pos_y = int(pos[0]), int(pos[1])
            
            # üîç DEBUG ESPECIAL PARA SLOT 3
            if slot == 3:
                print(f"   üîç [DEBUG SLOT 3] Coordenadas: ({pos_x}, {pos_y})")
                print(f"   üîç [DEBUG SLOT 3] ROI ser√°: x1={max(0, pos_x - 30)}, y1={max(0, pos_y - 30)}, x2={min(1920, pos_x + 30)}, y2={min(1080, pos_y + 30)}")

            # Criar regi√£o de interesse ao redor da posi√ß√£o do slot
            roi_size = 60
            x1 = max(0, pos_x - roi_size//2)
            y1 = max(0, pos_y - roi_size//2)
            x2 = min(1920, pos_x + roi_size//2)
            y2 = min(1080, pos_y + roi_size//2)

            # Criar ROI para MSS (dicion√°rio) e para NumPy (slice)
            roi_mss = {"top": int(y1), "left": int(x1), "width": int(x2-x1), "height": int(y2-y1)}
            roi_numpy = screen_gray[int(y1):int(y2), int(x1):int(x2)]

            # Detectar vara quebrada
            broken_found = self.detect_template_in_roi(roi_mss, 'varaquebrada.png')
            if broken_found:
                status[slot] = "broken"
                print(f"   ‚ùå Slot {slot}: Vara quebrada detectada")
            else:
                # Detectar vara sem isca
                no_bait_found = self.detect_template_in_roi(roi_mss, ['semiscavara.png', 'semiscanam.png', 'varasemisca.png', 'namaosemisca.png', 'enbausi.png'])
                if no_bait_found:
                    status[slot] = "no_bait"
                    print(f"   ‚ö†Ô∏è Slot {slot}: Vara sem isca")
                else:
                    # Detectar vara com isca (TODOS OS 5 templates)
                    with_bait_found = self.detect_template_in_roi(roi_mss, ['VARANOBAUCI.png', 'varacomisca.png', 'comiscavara.png', 'namaocomisca.png', 'comiscanamao.png'])
                    if with_bait_found:
                        status[slot] = "with_bait"
                        print(f"   ‚úÖ Slot {slot}: Vara com isca")
                    else:
                        status[slot] = "empty"
                        print(f"   ‚ö™ Slot {slot}: Vazio")
            
            # üîç DEBUG ESPECIAL PARA SLOT 3
            if slot == 3:
                print(f"   üîç [DEBUG SLOT 3] Resultado final: {status[slot]}")
                print(f"   üîç [DEBUG SLOT 3] broken={broken_found}, no_bait={no_bait_found if 'no_bait_found' in locals() else 'N/A'}, with_bait={with_bait_found if 'with_bait_found' in locals() else 'N/A'}")

        return status


    def detect_template_in_roi(self, roi, templates):
        """Detectar template(s) em uma regi√£o de interesse"""
        if isinstance(templates, str):
            templates = [templates]

        # Capturar a regi√£o da tela
        try:
            with mss.mss() as sct:
                screenshot = sct.grab(roi)
                roi_img = np.array(screenshot)
                roi_gray = cv2.cvtColor(roi_img, cv2.COLOR_BGRA2GRAY)
        except Exception as e:
            print(f"   ‚ö†Ô∏è Erro ao capturar ROI: {e}")
            return False

        for template_name in templates:
            try:
                template_path = os.path.join("templates", template_name)
                if not os.path.exists(template_path):
                    continue

                template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
                if template is None:
                    continue

                # Verificar se o template cabe no ROI
                if template.shape[0] > roi_gray.shape[0] or template.shape[1] > roi_gray.shape[1]:
                    continue

                result = cv2.matchTemplate(roi_gray, template, cv2.TM_CCOEFF_NORMED)
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                # SEMPRE usar threshold da UI (configura√ß√£o salva na interface)
                template_key = template_name.replace('.png', '')
                threshold = self.template_confidence_manager.get_template_confidence(template_key)
                if max_val >= threshold:
                    return True

            except Exception as e:
                print(f"   ‚ö†Ô∏è Erro ao detectar {template_name}: {e}")

        return False

    def auto_discard_broken_rods(self, rod_status):
        """üîß Manejo autom√°tico de varas quebradas (respeitando configura√ß√£o do usu√°rio)"""
        broken_slots = [slot for slot, status in rod_status.items() if status == "broken"]

        if not broken_slots:
            print("   ‚úÖ Nenhuma vara quebrada encontrada")
            return

        # ‚ö° VERIFICAR CONFIGURA√á√ÉO DO USU√ÅRIO
        broken_rod_action = self.config.get('broken_rod_action', 'discard')
        action_name = "DESCARTE" if broken_rod_action == 'discard' else "ARMAZENAMENTO"
        
        print(f"   üîß {action_name}: Encontradas {len(broken_slots)} varas quebradas nos slots: {broken_slots}")
        print(f"   ‚öôÔ∏è MODO CONFIGURADO: {broken_rod_action}")
        
        if broken_rod_action == 'save':
            print("   üì¶ Modo armazenamento ativo - varas quebradas ser√£o tratadas durante manuten√ß√£o")
            print("   üí° Sistema aguardar√° limpeza/alimenta√ß√£o para processar varas quebradas")
            return

        rod_positions = {
            1: [709, 1005],
            2: [805, 1005],
            3: [899, 1005],
            4: [992, 1005],
            5: [1092, 1005],
            6: [1188, 1005]
        }

        bait_removal_pos = [721, 359]  # Posi√ß√£o para remover isca
        trash_pos = [1400, 1000]  # Posi√ß√£o do lixo

        for slot in broken_slots:
            try:
                print(f"\n   üìç Processando vara quebrada no slot {slot}...")
                rod_pos = rod_positions[slot]

                # 1. Mover para vara quebrada
                print(f"   [1/7] Movendo para vara no slot {slot}: {rod_pos}")
                force_mouse_move(rod_pos[0], rod_pos[1])
                time.sleep(0.5)

                # 2. Clicar na vara quebrada
                print(f"   [2/7] Clicando na vara quebrada")
                pyautogui.click()
                time.sleep(0.5)

                # 3. Mover para posi√ß√£o de remo√ß√£o de isca
                print(f"   [3/7] Movendo para posi√ß√£o de isca: {bait_removal_pos}")
                force_mouse_move(bait_removal_pos[0], bait_removal_pos[1])
                time.sleep(0.5)

                # 4. Remover isca (clique direito)
                print(f"   [4/7] Removendo isca (clique direito)")
                pyautogui.rightClick()
                time.sleep(0.5)

                # 5. Retornar para vara quebrada
                print(f"   [5/7] Retornando para vara quebrada: {rod_pos}")
                force_mouse_move(rod_pos[0], rod_pos[1])
                time.sleep(0.5)

                # 6. Segurar e arrastar para lixo
                print(f"   [6/7] Arrastando vara para lixo")
                pyautogui.mouseDown()
                time.sleep(0.3)
                force_mouse_move(trash_pos[0], trash_pos[1])
                time.sleep(0.5)

                # 7. Soltar no lixo
                print(f"   [7/7] Soltando vara no lixo")
                pyautogui.mouseUp()
                time.sleep(0.5)

                print(f"   ‚úÖ Vara do slot {slot} descartada com sucesso!")
                rod_status[slot] = "empty"  # Atualizar status

            except Exception as e:
                print(f"   ‚ùå Erro ao descartar vara do slot {slot}: {e}")

    def auto_refill_empty_slots(self, rod_status):
        """Preencher slots vazios com varas do ba√∫"""
        empty_slots = [slot for slot, status in rod_status.items() if status == "empty"]

        if not empty_slots:
            print("   ‚úÖ Nenhum slot vazio encontrado")
            return

        print(f"   üì¶ Encontrados {len(empty_slots)} slots vazios: {empty_slots}")

        rod_positions = {
            1: [709, 1005],
            2: [805, 1005],
            3: [899, 1005],
            4: [992, 1005],
            5: [1092, 1005],
            6: [1188, 1005]
        }

        # Buscar varas no ba√∫
        chest_rods = self.search_rods_in_chest()

        if not chest_rods:
            print("   ‚ùå Nenhuma vara encontrada no ba√∫")
            return

        # Preencher slots vazios
        for i, slot in enumerate(empty_slots):
            if i >= len(chest_rods):
                print(f"   ‚ö†Ô∏è Sem varas suficientes para slot {slot}")
                break

            try:
                rod_info = chest_rods[i]
                rod_pos = rod_positions[slot]

                print(f"\n   üìç Preenchendo slot {slot}...")

                # 1. Mover para vara no ba√∫
                print(f"   [1/3] Movendo para vara no ba√∫: {rod_info['position']}")
                force_mouse_move(rod_info['position'][0], rod_info['position'][1])
                time.sleep(0.5)

                # 2. Arrastar para slot vazio
                print(f"   [2/3] Arrastando vara para slot {slot}")
                pyautogui.mouseDown()
                time.sleep(0.3)
                force_mouse_move(rod_pos[0], rod_pos[1])
                time.sleep(0.5)

                # 3. Soltar no slot
                print(f"   [3/3] Soltando vara no slot")
                pyautogui.mouseUp()
                time.sleep(0.5)

                print(f"   ‚úÖ Slot {slot} preenchido com {rod_info['type']}")
                rod_status[slot] = rod_info['type']  # Atualizar status

            except Exception as e:
                print(f"   ‚ùå Erro ao preencher slot {slot}: {e}")

    def auto_reload_rods_without_bait(self, rod_status):
        """Recarregar iscas nas varas sem isca"""
        no_bait_slots = [slot for slot, status in rod_status.items() if status == "no_bait"]

        if not no_bait_slots:
            print("   ‚úÖ Todas as varas j√° t√™m isca")
            return

        print(f"   üé£ Encontradas {len(no_bait_slots)} varas sem isca: {no_bait_slots}")

        rod_positions = {
            1: [709, 1005],
            2: [805, 1005],
            3: [899, 1005],
            4: [992, 1005],
            5: [1092, 1005],
            6: [1188, 1005]
        }

        # Buscar iscas dispon√≠veis
        baits = self.search_baits_in_inventory()

        if not baits:
            print("   ‚ùå Nenhuma isca encontrada no invent√°rio")
            return

        # Recarregar varas
        for i, slot in enumerate(no_bait_slots):
            if i >= len(baits):
                print(f"   ‚ö†Ô∏è Sem iscas suficientes para slot {slot}")
                break

            try:
                bait_info = baits[i]
                rod_pos = rod_positions[slot]

                print(f"\n   üìç Recarregando vara no slot {slot}...")

                # 1. Mover para isca
                print(f"   [1/3] Movendo para isca: {bait_info['type']} em {bait_info['position']}")
                force_mouse_move(bait_info['position'][0], bait_info['position'][1])
                time.sleep(0.5)

                # 2. Arrastar para vara
                print(f"   [2/3] Arrastando isca para vara no slot {slot}")
                pyautogui.mouseDown()
                time.sleep(0.3)
                force_mouse_move(rod_pos[0], rod_pos[1])
                time.sleep(0.5)

                # 3. Soltar na vara
                print(f"   [3/3] Soltando isca na vara")
                pyautogui.mouseUp()
                time.sleep(0.5)

                print(f"   ‚úÖ Vara do slot {slot} recarregada com {bait_info['type']}")
                rod_status[slot] = "with_bait"  # Atualizar status

            except Exception as e:
                print(f"   ‚ùå Erro ao recarregar vara do slot {slot}: {e}")

    def search_rods_in_chest(self):
        """Buscar varas dispon√≠veis no ba√∫"""
        print("   üîç Buscando varas no ba√∫...")

        # Primeiro tentar usar o cache se dispon√≠vel
        if hasattr(self, 'full_detection_cache') and self.full_detection_cache.get('rods_in_chest'):
            cached_rods = self.full_detection_cache['rods_in_chest']
            if cached_rods:
                time_since_cache = time.time() - self.full_detection_cache['cached_at']
                print(f"   üì¶ Usando cache de varas no ba√∫ ({time_since_cache:.1f}s atr√°s)")

                rods_found = []
                for rod_info in cached_rods:
                    template = rod_info['template']
                    # VARANOBAUCI = com isca (outros templates detectam sem isca)
                    rod_type = 'with_bait' if 'CI' in template else 'no_bait'
                    rods_found.append({
                        'type': rod_type,
                        'position': [rod_info['x'], rod_info['y']],
                        'template': template
                    })

                print(f"   üìä Encontradas {len(rods_found)} varas no ba√∫ (do cache)")
                return rods_found

        # Fallback: detec√ß√£o direta se n√£o houver cache
        print("   ‚ö†Ô∏è Cache n√£o dispon√≠vel, usando detec√ß√£o direta...")

        # Usar template matching para encontrar varas
        # üéØ √ÅREA EXATA DO BA√ö: Coordenadas fornecidas pelo usu√°rio
        chest_area = {"left": 1214, "top": 117, "width": 620, "height": 811}  # width=1834-1214, height=928-117

        rods_found = []

        # Procurar varas com isca primeiro (prioridade - VARANOBAUCI primeiro!)
        with_bait_templates = ['VARANOBAUCI.png', 'varacomisca.png', 'comiscavara.png', 'namaocomisca.png', 'comiscanamao.png']
        for template in with_bait_templates:
            detections = self.detect_template_in_area(template, chest_area)
            for detection in detections:
                rods_found.append({
                    'type': 'with_bait',
                    'position': [detection['x'], detection['y']],
                    'template': template
                })

        # Depois procurar varas sem isca
        without_bait_templates = ['semiscavara.png', 'semiscanam.png', 'varasemisca.png', 'namaosemisca.png', 'enbausi.png']  # Todos templates sem isca
        for template in without_bait_templates:
            detections = self.detect_template_in_area(template, chest_area)
            for detection in detections:
                rods_found.append({
                    'type': 'no_bait',
                    'position': [detection['x'], detection['y']],
                    'template': template
                })

        print(f"   üìä Encontradas {len(rods_found)} varas no ba√∫")
        return rods_found

    def get_bait_template_mapping(self):
        """üéØ SISTEMA UNIFICADO: Mapeamento entre nomes da UI e templates"""
        return {
            'carne de urso': 'carneurso.png',
            'carne de lobo': 'wolfmeat.png',
            'trout': 'smalltrout.png',  # Peixe cozido usado como isca
            'grub': 'grub.png',
            'worm': 'worm.png'  # üêõ MINHOCA CORRIGIDA!
        }

    def get_sorted_bait_priority(self):
        """üéØ Obter lista ordenada de iscas por prioridade"""
        if not hasattr(self, 'bait_priority'):
            self.load_bait_priority_config()

        # Ordenar por prioridade (menor n√∫mero = maior prioridade)
        sorted_baits = sorted(self.bait_priority.items(), key=lambda x: x[1])
        return [bait_name for bait_name, priority in sorted_baits if self.bait_enabled.get(bait_name, True)]

    def search_baits_in_inventory(self):
        """Buscar iscas dispon√≠veis no invent√°rio"""
        print("   üîç Buscando iscas no invent√°rio...")

        # üéØ SISTEMA UNIFICADO: Usar mapeamento correto de templates
        bait_mapping = self.get_bait_template_mapping()
        sorted_bait_names = self.get_sorted_bait_priority()

        print(f"   üéØ Prioridade de iscas: {sorted_bait_names}")

        # Primeiro tentar usar o cache se dispon√≠vel
        if hasattr(self, 'full_detection_cache') and self.full_detection_cache.get('baits_in_inventory'):
            cached_baits = self.full_detection_cache['baits_in_inventory']
            if cached_baits:
                time_since_cache = time.time() - self.full_detection_cache['cached_at']
                print(f"   üì¶ Usando cache de iscas ({time_since_cache:.1f}s atr√°s)")

                baits_found = []

                # Organizar por prioridade usando mapeamento unificado
                for bait_name in sorted_bait_names:
                    template_file = bait_mapping.get(bait_name)
                    if not template_file:
                        continue

                    for bait_info in cached_baits:
                        if bait_info['template'] == template_file:
                            baits_found.append({
                                'type': bait_name,
                                'position': [bait_info['x'], bait_info['y']],
                                'template': template_file
                            })
                            print(f"   ‚úÖ Cache: {bait_name} ({template_file}) encontrada")

                print(f"   üìä Encontradas {len(baits_found)} iscas no invent√°rio (do cache)")
                return baits_found

        # Fallback: detec√ß√£o direta se n√£o houver cache
        print("   ‚ö†Ô∏è Cache n√£o dispon√≠vel, usando detec√ß√£o direta...")

        # √Årea do invent√°rio (lado esquerdo)
        # üéØ √ÅREA EXATA DO INVENT√ÅRIO: Coordenadas fornecidas pelo usu√°rio
        inventory_area = {"left": 633, "top": 541, "width": 600, "height": 412}  # width=1233-633, height=953-541

        baits_found = []

        # üéØ Usar sistema unificado de prioridade e mapeamento
        for bait_name in sorted_bait_names:
            template_file = bait_mapping.get(bait_name)
            if not template_file:
                print(f"   ‚ö†Ô∏è Template n√£o encontrado para isca: {bait_name}")
                continue

            print(f"   üîç Procurando {bait_name} ({template_file})...")
            detections = self.detect_template_in_area(template_file, inventory_area)
            for detection in detections:
                baits_found.append({
                    'type': bait_name,
                    'position': [detection['x'], detection['y']],
                    'template': template_file
                })
                print(f"   ‚úÖ Direto: {bait_name} ({template_file}) encontrada em {detection}")

        print(f"   üìä Encontradas {len(baits_found)} iscas no invent√°rio")
        return baits_found

    def detect_broken_rod_at_position(self, x, y):
        """Detectar se h√° vara quebrada na posi√ß√£o especificada"""
        # Usar template matching em √°rea pequena ao redor da posi√ß√£o
        area = {"left": int(x-30), "top": int(y-30), "width": 60, "height": 60}
        detections = self.detect_template_in_area('varaquebrada.png', area)
        return len(detections) > 0

    def detect_rod_without_bait_at_position(self, x, y):
        """Detectar se h√° vara sem isca na posi√ß√£o especificada"""
        area = {"left": int(x-30), "top": int(y-30), "width": 60, "height": 60}
        templates = ['semiscavara.png', 'semiscanam.png', 'varasemisca.png', 'namaosemisca.png', 'enbausi.png']
        for template in templates:
            detections = self.detect_template_in_area(template, area)
            if detections:
                return True
        return False

    def detect_rod_with_bait_at_position(self, x, y):
        """Detectar se h√° vara com isca na posi√ß√£o especificada usando sistema unificado"""
        try:
            # Usar o mesmo sistema de detec√ß√£o da interface para consist√™ncia
            if hasattr(self, 'ui') and self.ui and hasattr(self.ui, 'rod_status_tracking'):
                # Mapear posi√ß√£o para slot
                slot_positions = {
                    709: 1, 805: 2, 899: 3, 992: 4, 1092: 5, 1188: 6
                }

                # Encontrar slot mais pr√≥ximo
                closest_slot = None
                min_distance = float('inf')
                for pos, slot in slot_positions.items():
                    distance = abs(pos - x)
                    if distance < min_distance:
                        min_distance = distance
                        closest_slot = slot

                # Verificar status via Catch Viewer se dispon√≠vel
                if closest_slot and hasattr(self.ui.rod_status_tracking, 'available_with_bait'):
                    return closest_slot in self.ui.rod_status_tracking.available_with_bait

            # Fallback: usar detec√ß√£o por template (m√©todo original melhorado)
            area = {"left": int(x-60), "top": int(y-60), "width": 120, "height": 120}

            # Templates para vara COM isca (mesmos do sistema principal)
            with_bait_templates = ['VARANOBAUCI.png', 'varanobauci.png', 'comiscavara.png',
                                   'namaocomisca.png', 'comiscanamao.png', 'varacomisca.png']

            for template in with_bait_templates:
                try:
                    # üéØ Usar threshold unificado com UI
                    unified_threshold = self.get_unified_template_threshold(template)
                    if self.detect_template_in_area(template, area, threshold=unified_threshold):
                        return True
                except:
                    continue

            return False

        except Exception as e:
            print(f"   ‚ùå Erro na detec√ß√£o de vara com isca: {e}")
            return False

    def detect_template_in_area(self, template_name, area, threshold=0.8):
        """Detectar template em √°rea espec√≠fica da tela"""
        try:
            # Capturar √°rea espec√≠fica
            with mss.mss() as sct:
                screenshot = sct.grab({
                    "top": area["top"],
                    "left": area["left"],
                    "width": area["width"],
                    "height": area["height"]
                })
                screen = np.array(screenshot)
                screen_gray = cv2.cvtColor(screen, cv2.COLOR_BGRA2GRAY)

            # Carregar template
            template_path = os.path.join("templates", template_name)
            if not os.path.exists(template_path):
                return []

            template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
            if template is None:
                return []

            # Match template
            result = cv2.matchTemplate(screen_gray, template, cv2.TM_CCOEFF_NORMED)

            # üéØ Usar threshold unificado com UI (ignora par√¢metro threshold)
            threshold = self.get_unified_template_threshold(template_name)

            # Encontrar todas as correspond√™ncias
            locations = np.where(result >= threshold)

            detections = []
            for pt in zip(*locations[::-1]):
                detections.append({
                    'x': area["left"] + pt[0] + template.shape[1]//2,
                    'y': area["top"] + pt[1] + template.shape[0]//2,
                    'confidence': result[pt[1], pt[0]]
                })

            return detections

        except Exception as e:
            print(f"   ‚ö†Ô∏è Erro ao detectar template {template_name}: {e}")
            return []

    def analyze_f5_macro(self):
        """Analisar o macro F5 - MyScript.ahk (An√°lise detalhada)"""
        print("\n" + "="*60)
        print("üîç AN√ÅLISE DO MACRO F5 - MyScript.ahk")
        print("="*60)

        print("üìä ESTRUTURA DO MACRO GRAVADO:")
        print("   ‚è∞ Sleep inicial: 1188ms")
        print("   ‚å®Ô∏è LAlt Down + Sleep 484ms")
        print("   üñ±Ô∏è ~80 movimentos micro em (959-960, 539-540)")
        print("   ‚å®Ô∏è Send {E}")
        print("   ‚è∞ Sleep final: 985ms")
        print("   ‚å®Ô∏è LAlt Up")

        print("\nüö® PROBLEMA IDENTIFICADO:")
        print("   ‚ùå Macro gravou CLIQUES no centro ao inv√©s de MOVIMENTO para ba√∫")
        print("   ‚ùå Posi√ß√£o (960, 540) = centro da tela, n√£o ba√∫")
        print("   ‚ùå 80+ cliques micro n√£o abrem ba√∫")

        print("\nüí° SOLU√á√ÉO SUGERIDA:")
        print("   1. Regravar macro movendo PARA O BA√ö (n√£o clicando no centro)")
        print("   2. Usar F10 para capturar posi√ß√£o correta do ba√∫")
        print("   3. Ou criar macro simplificado:")

        chest_side = self.config.get('chest_side', 'left')
        chest_pos = self.config.get('chest_absolute_pos', {})

        if chest_side in chest_pos and chest_pos[chest_side]['x'] != 0:
            target_x = chest_pos[chest_side]['x']
            target_y = chest_pos[chest_side]['y']
            print(f"      ‚Ä¢ ALT + Mover para ({target_x}, {target_y}) + E + soltar ALT")
        else:
            print("      ‚Ä¢ ALT + Mover para ba√∫ + E + soltar ALT")

        print("\nüß™ TESTES DISPON√çVEIS:")
        print("   F5 - Executar macro atual (Python)")
        print("   F11 - Testar abertura completa")
        print("   F12 - Testar movimento de mouse")

        print("\nüìù RECOMENDA√á√ïES:")
        print("   1. Use F10 para capturar posi√ß√£o correta do ba√∫ primeiro")
        print("   2. Regrave o macro movendo PARA O BA√ö (n√£o clicando)")
        print("   3. Ou simplifique para: ALT > Movimento > E > Soltar ALT")
        print("="*60)

    def show_yolo_detection_viewer(self):
        """Mostrar interface de visualiza√ß√£o das detec√ß√µes YOLO - Ctrl+F11"""
        print("\nüîç Abrindo Visualizador de Detec√ß√µes YOLO...")

        if not self.yolo_model or not self.sct:
            print("‚ùå Sistema YOLO n√£o inicializado!")
            return

        try:
            import tkinter as tk
            from tkinter import ttk
            from PIL import Image, ImageTk, ImageDraw, ImageFont

            # Criar janela de visualiza√ß√£o
            viewer_window = tk.Toplevel()
            viewer_window.title("üîç YOLO Detection Viewer")
            viewer_window.geometry("800x600")

            # Frame principal
            main_frame = ttk.Frame(viewer_window)
            main_frame.pack(fill="both", expand=True, padx=10, pady=10)

            # Frame de controles
            control_frame = ttk.Frame(main_frame)
            control_frame.pack(fill="x", pady=(0, 10))

            # Vari√°veis
            self.viewer_running = False

            # Labels de informa√ß√£o
            info_label = ttk.Label(control_frame, text="Detec√ß√µes YOLO em tempo real")
            info_label.pack(side="left")

            detection_count_var = tk.StringVar(value="Detec√ß√µes: 0")
            count_label = ttk.Label(control_frame, textvariable=detection_count_var)
            count_label.pack(side="right")

            # Canvas para mostrar a imagem
            canvas = tk.Canvas(main_frame, bg="black", width=760, height=480)
            canvas.pack(fill="both", expand=True)

            # Lista de detec√ß√µes
            list_frame = ttk.Frame(main_frame)
            list_frame.pack(fill="x", pady=(10, 0))

            ttk.Label(list_frame, text="Detec√ß√µes encontradas:").pack(anchor="w")

            detection_listbox = tk.Listbox(list_frame, height=8)
            detection_listbox.pack(fill="x")

            def update_detection_view():
                """Atualizar visualiza√ß√£o das detec√ß√µes"""
                if not self.viewer_running:
                    return

                try:
                    # Capturar tela
                    monitor_region = {"top": 0, "left": 0, "width": 1920, "height": 1080}
                    screenshot = self.sct.grab(monitor_region)
                    img_array = np.array(screenshot)
                    img_rgb = cv2.cvtColor(img_array, cv2.COLOR_BGRA2RGB)

                    # Fazer detec√ß√µes
                    detections = self.detect_objects_main_thread_only(monitor_region)

                    # Criar imagem PIL para desenhar
                    pil_img = Image.fromarray(img_rgb)
                    draw = ImageDraw.Draw(pil_img)

                    # Desenhar detec√ß√µes
                    detection_listbox.delete(0, tk.END)

                    for detection in detections:
                        x1, y1, x2, y2 = detection['bbox']
                        class_name = detection['class']
                        confidence = detection['confidence']

                        # Desenhar ret√¢ngulo
                        draw.rectangle([x1, y1, x2, y2], outline="red", width=2)

                        # Texto da detec√ß√£o
                        text = f"{class_name}: {confidence:.2f}"
                        draw.text((x1, y1-20), text, fill="red")

                        # Adicionar √† lista
                        list_text = f"{class_name} ({confidence:.2f}) - ({x1},{y1})"
                        detection_listbox.insert(tk.END, list_text)

                    # Redimensionar imagem para caber no canvas
                    display_width = 760
                    display_height = 480
                    pil_img = pil_img.resize((display_width, display_height), Image.Resampling.LANCZOS)

                    # Converter para Tkinter
                    photo = ImageTk.PhotoImage(pil_img)

                    # Mostrar no canvas
                    canvas.delete("all")
                    canvas.create_image(display_width//2, display_height//2, image=photo)
                    canvas.image = photo  # Manter refer√™ncia

                    # Atualizar contador
                    detection_count_var.set(f"Detec√ß√µes: {len(detections)}")

                except Exception as e:
                    print(f"‚ùå Erro na visualiza√ß√£o: {e}")

                # Agendar pr√≥xima atualiza√ß√£o
                if self.viewer_running:
                    viewer_window.after(500, update_detection_view)

            def start_viewer():
                """Iniciar visualiza√ß√£o"""
                self.viewer_running = True
                start_btn.config(state="disabled")
                stop_btn.config(state="normal")
                update_detection_view()

            def stop_viewer():
                """Parar visualiza√ß√£o"""
                self.viewer_running = False
                start_btn.config(state="normal")
                stop_btn.config(state="disabled")
                canvas.delete("all")
                detection_listbox.delete(0, tk.END)
                detection_count_var.set("Detec√ß√µes: 0")

            def on_closing():
                """Ao fechar janela"""
                stop_viewer()
                viewer_window.destroy()

            # Bot√µes de controle
            button_frame = ttk.Frame(control_frame)
            button_frame.pack(side="left", padx=(20, 0))

            start_btn = ttk.Button(button_frame, text="‚ñ∂Ô∏è Iniciar", command=start_viewer)
            start_btn.pack(side="left", padx=(0, 5))

            stop_btn = ttk.Button(button_frame, text="‚èπÔ∏è Parar", command=stop_viewer, state="disabled")
            stop_btn.pack(side="left")

            # Configurar fechamento
            viewer_window.protocol("WM_DELETE_WINDOW", on_closing)

            print("‚úÖ Visualizador YOLO aberto!")
            print("üí° Use os bot√µes Iniciar/Parar para controlar a visualiza√ß√£o")

        except ImportError:
            print("‚ùå PIL (Pillow) n√£o instalado. Execute: pip install Pillow")
        except Exception as e:
            print(f"‚ùå Erro ao criar visualizador: {e}")

    # =============================================================================
    # üé£ SISTEMA AVAN√áADO DE RASTREAMENTO DE VARA NA M√ÉO
    # =============================================================================

    def track_rod_in_hand(self, rod_number):
        """üéØ Rastrear qual vara est√° atualmente na m√£o"""
        try:
            previous_rod = self.rod_hand_tracking['current_rod']
            self.rod_hand_tracking['current_rod'] = rod_number
            self.rod_hand_tracking['last_switch_time'] = time.time()
            self.game_state['current_rod_in_hand'] = rod_number

            print(f"üéØ [TRACKING] Vara na m√£o: {previous_rod} ‚Üí {rod_number}")

            # Adicionar ao hist√≥rico
            self.rod_hand_tracking['detection_history'].append({
                'rod': rod_number,
                'timestamp': time.time(),
                'confidence': 1.0  # Manual tracking = 100% confian√ßa
            })

            # Manter apenas √∫ltimas 10 detec√ß√µes
            if len(self.rod_hand_tracking['detection_history']) > 10:
                self.rod_hand_tracking['detection_history'].pop(0)

        except Exception as e:
            print(f"‚ùå Erro no tracking de vara: {e}")

    def get_current_rod_in_hand(self):
        """üîç Obter vara atualmente na m√£o"""
        return self.rod_hand_tracking.get('current_rod', 1)

    def detect_rod_in_hand_visual(self):
        """üéØ Detectar visualmente se h√° vara na m√£o usando template matching"""
        try:
            detections = self.detect_objects()

            for detection in detections:
                if detection['class'] == 'namao.png' and detection['confidence'] >= 0.7:
                    print(f"üé£ Vara detectada na m√£o - Confian√ßa: {detection['confidence']:.2f}")
                    return True

            return False

        except Exception as e:
            print(f"‚ùå Erro ao detectar vara na m√£o: {e}")
            return False

    def remove_rod_from_hand_before_check(self):
        """üîÑ Remover vara da m√£o antes de verificar varas no invent√°rio"""
        try:
            print("üîç Verificando se h√° vara na m√£o...")

            # Verificar visualmente se h√° vara na m√£o
            if self.detect_rod_in_hand_visual():
                print("üé£ Vara detectada na m√£o - removendo...")

                # Obter slot da vara atual
                current_rod = self.get_current_rod_in_hand()

                # Clicar no slot da vara para remov√™-la da m√£o
                if 1 <= current_rod <= 6:
                    rod_positions = self.rod_system.get('rod_positions', [])
                    if current_rod-1 < len(rod_positions):
                        rod_pos = rod_positions[current_rod-1]
                        print(f"üìç Clicando no slot {current_rod} para remover vara da m√£o: {rod_pos}")

                        pyautogui.click(rod_pos[0], rod_pos[1])
                        time.sleep(0.5)

                        print("‚úÖ Vara removida da m√£o")
                        return True

            print("‚úÖ Nenhuma vara na m√£o ou j√° removida")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao remover vara da m√£o: {e}")
            return False

    def check_rods_with_hand_management(self):
        """üéØ Verificar varas com gerenciamento inteligente da vara na m√£o"""
        try:
            print("\nüîç INICIANDO VERIFICA√á√ÉO DE VARAS COM GERENCIAMENTO DE M√ÉO")

            # Abrir invent√°rio se n√£o estiver aberto
            if not self.game_state.get('inventory_open', False):
                print("üì¶ Abrindo invent√°rio...")
                pyautogui.press('tab')
                time.sleep(0.8)
                self.game_state['inventory_open'] = True

            # Remover vara da m√£o antes da verifica√ß√£o
            self.remove_rod_from_hand_before_check()

            # Aguardar estabiliza√ß√£o para melhor detec√ß√£o
            print("‚è≥ Aguardando estabiliza√ß√£o para detec√ß√£o precisa...")
            time.sleep(2.0)  # Delay importante para detec√ß√£o correta

            # Executar detec√ß√£o normal de varas
            result = self.detect_available_rods()

            print("‚úÖ Verifica√ß√£o de varas conclu√≠da com gerenciamento de m√£o")
            return result

        except Exception as e:
            print(f"‚ùå Erro na verifica√ß√£o com gerenciamento de m√£o: {e}")
            return False

    def safe_switch_to_rod(self, target_rod):
        """üîí Troca segura para vara espec√≠fica (evita trocar para vara j√° na m√£o)"""
        current_rod = self.get_current_rod_in_hand()

        if current_rod == target_rod:
            print(f"‚ö†Ô∏è [SAFE_SWITCH] Vara {target_rod} j√° est√° na m√£o - ignorando troca")
            return True

        print(f"üîÑ [SAFE_SWITCH] Trocando: vara {current_rod} ‚Üí vara {target_rod}")

        # Executar troca
        pyautogui.press(str(target_rod))
        time.sleep(0.5)  # Aguardar troca

        # Atualizar tracking
        self.track_rod_in_hand(target_rod)

        return True

    def ensure_different_rod_in_hand(self, avoid_rod):
        """üö® Garantir que uma vara DIFERENTE est√° na m√£o"""
        current_rod = self.get_current_rod_in_hand()

        if current_rod != avoid_rod:
            print(f"‚úÖ [ENSURE] Vara {current_rod} j√° √© diferente de {avoid_rod}")
            return current_rod

        # Encontrar vara alternativa (preferencialmente no mesmo par)
        rod_pairs = [(1, 2), (3, 4), (5, 6)]

        for pair in rod_pairs:
            if avoid_rod in pair:
                # Usar a outra vara do mesmo par
                alternative = pair[1] if pair[0] == avoid_rod else pair[0]
                print(f"üîÑ [ENSURE] Trocando para vara alternativa {alternative} (mesmo par)")
                self.safe_switch_to_rod(alternative)
                return alternative

        # Fallback: usar vara 1 se n√£o estiver no par
        if avoid_rod != 1:
            print(f"üîÑ [ENSURE] Usando vara 1 como fallback")
            self.safe_switch_to_rod(1)
            return 1
        else:
            print(f"üîÑ [ENSURE] Usando vara 2 como fallback")
            self.safe_switch_to_rod(2)
            return 2

    # =============================================================================
    # üîÑ M√ìDULO DE REPOSI√á√ÉO DE VARAS DO BA√ö
    # =============================================================================

    def replace_empty_rod_slots(self):
        """üéØ NOVO M√ìDULO: Repor varas em slots vazios do ba√∫"""
        print("üîÑ [REPOSI√á√ÉO] Iniciando m√≥dulo de reposi√ß√£o de varas...")

        try:
            # PASSO 1: Detectar slots vazios (sem nenhuma vara detectada)
            empty_slots = self.detect_empty_rod_slots()

            if not empty_slots:
                print("‚úÖ [REPOSI√á√ÉO] Todos os slots t√™m varas - nada a fazer")
                return True

            print(f"üéØ [REPOSI√á√ÉO] Slots vazios detectados: {empty_slots}")

            # PASSO 2: Abrir ba√∫ para pegar novas varas
            print("üì¶ [REPOSI√á√ÉO] Abrindo ba√∫ para pegar varas...")
            if not self.open_chest():
                print("‚ùå [REPOSI√á√ÉO] Falha ao abrir ba√∫")
                return False

            time.sleep(2)  # Aguardar ba√∫ abrir

            # PASSO 3: Detectar varas dispon√≠veis no ba√∫
            available_rods = self.detect_rods_in_chest()

            if not available_rods:
                print("‚ùå [REPOSI√á√ÉO] Nenhuma vara encontrada no ba√∫")
                self.close_inventory_with_delay("Reposi√ß√£o")
                return False

            # PASSO 4: Priorizar varas COM isca, depois SEM isca
            rods_with_bait = [rod for rod in available_rods if rod.get('has_bait', False)]
            rods_without_bait = [rod for rod in available_rods if not rod.get('has_bait', False)]

            print(f"üìä [REPOSI√á√ÉO] Varas com isca: {len(rods_with_bait)} | Sem isca: {len(rods_without_bait)}")

            # PASSO 5: Distribuir varas pelos slots vazios
            rods_collected = 0
            slots_needing_bait = []  # Rastrear quais slots precisar√£o de iscas
            priority_rods = rods_with_bait + rods_without_bait  # COM isca primeiro

            for slot in empty_slots[:6]:  # M√°ximo 6 slots
                if rods_collected >= len(priority_rods):
                    break

                rod = priority_rods[rods_collected]
                print(f"üé£ [REPOSI√á√ÉO] Coletando vara para slot {slot}...")

                # Verificar se a vara tem isca para rastreamento
                has_bait = rod.get('has_bait', False)
                if not has_bait:
                    slots_needing_bait.append(slot)
                    print(f"üìù [REPOSI√á√ÉO] Slot {slot} marcado para recarga de isca")

                # Clicar direito na vara (ba√∫ ‚Üí invent√°rio)
                pyautogui.rightClick(rod['center_x'], rod['center_y'])
                time.sleep(0.5)

                # Pressionar n√∫mero do slot para equipar
                focus_game_window()  # Garantir foco antes de pressionar tecla
                pyautogui.press(str(slot))
                time.sleep(0.5)

                rods_collected += 1
                status = "COM ISCA" if has_bait else "SEM ISCA"
                print(f"‚úÖ [REPOSI√á√ÉO] Vara {status} equipada no slot {slot}")

            # PASSO 6: Fechar ba√∫
            self.close_inventory_with_delay("Reposi√ß√£o")

            # PASSO 6.5: Limpar cache e for√ßar atualiza√ß√£o do Catch Viewer
            print("üßπ [REPOSI√á√ÉO] Limpando cache ap√≥s coloca√ß√£o de varas...")
            self.clear_detection_cache()
            time.sleep(1)  # Aguardar limpeza
            print("‚úÖ [REPOSI√á√ÉO] Cache limpo - dados atualizados!")

            # PASSO 7: Recarregar iscas nas varas sem isca que foram repostas
            if slots_needing_bait:
                print(f"üé£ [REPOSI√á√ÉO] Aplicando iscas nos slots que precisam: {slots_needing_bait}")
                time.sleep(1)  # Aguardar interface atualizar

                # Abrir invent√°rio para aplicar iscas
                if not self.game_state.get('inventory_open', False):
                    pyautogui.press('tab')
                    time.sleep(0.8)
                    self.game_state['inventory_open'] = True

                # Criar rod_status for√ßando recarga nos slots necess√°rios
                rod_status = {}
                for i in range(1, 7):
                    if i in slots_needing_bait:
                        rod_status[i] = "no_bait"  # For√ßar recarga
                        print(f"   üéØ Slot {i}: MARCADO para recarga de isca")
                    else:
                        rod_status[i] = "with_bait"  # N√£o mexer nos outros

                # Aplicar iscas nos slots marcados
                self.auto_reload_rods_without_bait(rod_status)

                # Fechar invent√°rio
                if self.game_state.get('inventory_open', False):
                    pyautogui.press('tab')
                    time.sleep(0.5)
                    self.game_state['inventory_open'] = False

                print(f"‚úÖ [REPOSI√á√ÉO] Iscas aplicadas nos slots: {slots_needing_bait}")
            else:
                print("‚úÖ [REPOSI√á√ÉO] Todas as varas colocadas j√° tinham iscas!")

            print(f"‚úÖ [REPOSI√á√ÉO] {rods_collected} varas repostas e iscadas com sucesso!")
            return True

        except Exception as e:
            print(f"‚ùå [REPOSI√á√ÉO] Erro: {e}")
            # Fechar ba√∫ em caso de erro
            try:
                self.close_inventory_with_delay("Reposi√ß√£o - Erro")
            except:
                pass
            return False

    def detect_empty_rod_slots(self):
        """üîç Detectar quais slots n√£o t√™m nenhuma vara"""
        try:
            # Capturar tela atual
            with mss.mss() as sct:
                screenshot = sct.grab(sct.monitors[1])
                img_array = np.array(screenshot)[:, :, :3]  # RGB

            # Detectar todas as varas vis√≠veis
            rod_detections = self.detect_all_rods_on_screen(img_array)

            # Mapear detec√ß√µes para slots (1-6)
            occupied_slots = set()
            for detection in rod_detections:
                slot = self.map_rod_position_to_slot(detection['center_x'], detection['center_y'])
                if slot:
                    occupied_slots.add(slot)

            # Slots vazios = todos os slots - slots ocupados
            all_slots = {1, 2, 3, 4, 5, 6}
            empty_slots = list(all_slots - occupied_slots)

            print(f"üìä [EMPTY_DETECT] Slots ocupados: {sorted(occupied_slots)} | Vazios: {sorted(empty_slots)}")
            return empty_slots

        except Exception as e:
            print(f"‚ùå [EMPTY_DETECT] Erro: {e}")
            return []

    def detect_rods_in_chest(self):
        """üîç Detectar varas dispon√≠veis no ba√∫ (lado direito)"""
        try:
            # Usar detec√ß√£o de objetos existente
            detections = self.detect_objects()

            rod_templates = ['VARANOBAUCI.png', 'varacomisca.png', 'comiscavara.png', 'varasemisca.png', 'semiscavara.png', 'namaocomisca.png', 'semiscanam.png', 'namaosemisca.png', 'comiscanamao.png', 'enbausi.png']  # üéØ VARANOBAUCI primeiro
            available_rods = []

            for detection in detections:
                # Apenas lado direito (ba√∫)
                if detection.get('x', 0) > 1242:
                    template_name = detection.get('template', '')
                    if any(rod_template in template_name for rod_template in rod_templates):
                        # Determinar se tem isca
                        has_bait = 'comisca' in template_name or 'varacomisca' in template_name

                        available_rods.append({
                            'center_x': detection.get('center_x', detection.get('x', 0)),
                            'center_y': detection.get('center_y', detection.get('y', 0)),
                            'has_bait': has_bait,
                            'template': template_name,
                            'confidence': detection.get('confidence', 0.8)
                        })

            print(f"üé£ [CHEST_RODS] {len(available_rods)} varas encontradas no ba√∫")
            return available_rods

        except Exception as e:
            print(f"‚ùå [CHEST_RODS] Erro: {e}")
            return []

    # =============================================================================
    # üîß M√ìDULO DE RECARGA ESPEC√çFICA DE VARA
    # =============================================================================

    def reload_specific_rod_with_bait(self, rod_slot):
        """üîß NOVO M√ìDULO: Recarregar vara espec√≠fica que est√° sem isca COM coordena√ß√£o"""

        # üéØ USAR SISTEMA DE COORDENA√á√ÉO
        return self.request_operation(
            'reloading_rod',
            lambda: self._protected_rod_reload(rod_slot),
            context=f"Recarga de vara slot {rod_slot}"
        )

    def _protected_rod_reload(self, rod_slot):
        """üîí Recarga de vara protegida pelo sistema de coordena√ß√£o"""
        print(f"üîß [RELOAD] Iniciando recarga PROTEGIDA da vara slot {rod_slot}...")

        try:
            # PASSO 1: Garantir que uma vara DIFERENTE est√° na m√£o
            current_rod = self.get_current_rod_in_hand()

            if current_rod == rod_slot:
                print(f"üö® [RELOAD] Vara {rod_slot} est√° na m√£o - trocando para alternativa")
                self.ensure_different_rod_in_hand(rod_slot)
                time.sleep(0.5)

            # PASSO 2: Trocar para a vara sem isca
            print(f"üîÑ [RELOAD] Trocando para vara {rod_slot} que precisa de recarga...")
            self.safe_switch_to_rod(rod_slot)

            # PASSO 3: Abrir invent√°rio
            if not self.game_state.get('inventory_open', False):
                print("üì¶ [RELOAD] Abrindo invent√°rio...")
                pyautogui.press('tab')
                time.sleep(1)
                self.game_state['inventory_open'] = True

            # PASSO 4: Encontrar isca com prioridade
            best_bait = self.find_best_available_bait()

            if not best_bait:
                print("‚ùå [RELOAD] Nenhuma isca dispon√≠vel no invent√°rio")
                return False

            # PASSO 5: Aplicar isca na vara
            print(f"ü•© [RELOAD] Aplicando {best_bait['type']} na vara {rod_slot}...")
            pyautogui.rightClick(best_bait['center_x'], best_bait['center_y'])
            time.sleep(0.5)

            # PASSO 6: Fechar invent√°rio
            print("üö™ [RELOAD] Fechando invent√°rio...")
            pyautogui.press('tab')
            time.sleep(1)
            self.game_state['inventory_open'] = False

            print(f"‚úÖ [RELOAD] Vara {rod_slot} recarregada com sucesso!")
            return True

        except Exception as e:
            print(f"‚ùå [RELOAD] Erro na recarga da vara {rod_slot}: {e}")

            # Cleanup em caso de erro
            try:
                if self.game_state.get('inventory_open', False):
                    pyautogui.press('tab')
                    self.game_state['inventory_open'] = False
            except:
                pass

            return False

    def find_best_available_bait(self):
        """üéØ Encontrar melhor isca dispon√≠vel baseado na prioridade"""
        try:
            # Usar sistema de prioridade existente
            priority_order = getattr(self, 'bait_priority', [
                'carne de urso', 'carne de lobo', 'truta', 'grub', 'worm'
            ])

            # Detectar objetos no invent√°rio
            detections = self.detect_objects()
            bait_detections = []

            for detection in detections:
                # Apenas lado esquerdo (invent√°rio)
                if detection.get('x', 0) < 1242:
                    obj_class = detection.get('class', '').lower()

                    # Mapear classes para nomes de prioridade
                    class_mapping = {
                        'carnedeurso': 'carne de urso',
                        'carneurso': 'carne de urso',
                        'wolfmeat': 'carne de lobo',
                        'carne de lobo': 'carne de lobo',
                        'smalltrout': 'truta',
                        'trout': 'truta',
                        'grub': 'grub',
                        'worm': 'worm'
                    }

                    for template_key, priority_name in class_mapping.items():
                        if template_key in obj_class:
                            bait_detections.append({
                                'type': priority_name,
                                'center_x': detection.get('center_x', detection.get('x', 0)),
                                'center_y': detection.get('center_y', detection.get('y', 0)),
                                'confidence': detection.get('confidence', 0.8),
                                'priority_index': priority_order.index(priority_name) if priority_name in priority_order else 999
                            })
                            break

            if not bait_detections:
                print("‚ùå [BAIT_FIND] Nenhuma isca detectada no invent√°rio")
                return None

            # Ordenar por prioridade (menor √≠ndice = maior prioridade)
            bait_detections.sort(key=lambda x: x['priority_index'])
            best_bait = bait_detections[0]

            print(f"ü•© [BAIT_FIND] Melhor isca: {best_bait['type']} (prioridade {best_bait['priority_index']})")
            return best_bait

        except Exception as e:
            print(f"‚ùå [BAIT_FIND] Erro: {e}")
            return None

    def select_best_bait(self, all_baits):
        """üéØ Selecionar melhor isca dispon√≠vel da lista j√° ordenada por prioridade"""
        try:
            if not all_baits:
                print("‚ùå [SELECT_BAIT] Lista de iscas vazia")
                return None
            
            # Lista j√° vem ordenada por prioridade, pegar a primeira dispon√≠vel
            best_bait = all_baits[0]
            
            print(f"üéØ [SELECT_BAIT] Selecionada: {best_bait.get('name', 'unknown')} @ ({best_bait['x']}, {best_bait['y']}) - Confian√ßa: {best_bait.get('confidence', 0):.2f}")
            
            # Retornar o objeto original com campo 'class' adicionado para compatibilidade
            result = best_bait.copy()
            result['class'] = best_bait.get('name', 'unknown')  # ‚ö° CORRE√á√ÉO: 'name' em vez de 'class'
            return result
            
        except Exception as e:
            print(f"‚ùå [SELECT_BAIT] Erro ao selecionar isca: {e}")
            return None

    def apply_bait_to_rod_slot(self, slot, bait_info):
        """üé£ Aplicar isca na vara usando drag & drop (igual tecla 0)"""
        try:
            bait_name = bait_info.get('name', bait_info.get('class', 'unknown'))
            print(f"üé£ [BAIT_APPLY] Aplicando isca {bait_name} no slot {slot}")
            print(f"   üìç [ORIGEM] Isca localizada em ({bait_info['x']}, {bait_info['y']})")
            
            # Usar a mesma fun√ß√£o de drag & drop do sistema "0"
            success = self._execute_drag_drop_bait(slot, bait_info)
            
            if success:
                print(f"‚úÖ [BAIT_APPLY] Isca {bait_name} aplicada com sucesso no slot {slot}")
                
                # ‚úÖ OTIMIZADO: Aguardar aplica√ß√£o da isca
                time.sleep(0.3)  # ‚úÖ OTIMIZADO: Reduzido de 1s para 0.3s
                
                return True
            else:
                print(f"‚ùå [BAIT_APPLY] Falha ao aplicar isca {bait_name} no slot {slot}")
                return False
                
        except Exception as e:
            print(f"‚ùå [BAIT_APPLY] Erro ao aplicar isca no slot {slot}: {e}")
            return False

# =============================================================================
# üöÄ FUN√á√ÉO PRINCIPAL
# =============================================================================
def main():
    print("üßô‚Äç‚ôÇÔ∏è Iniciando Ultimate Fishing Bot v3.0...")
    
    # Detectar janela do jogo automaticamente
    print("üîç Procurando janela do jogo...")
    hwnd, title = find_game_window()
    if hwnd:
        print(f"‚úÖ Janela do jogo encontrada: {title}")
        focus_game_window()
    else:
        print("‚ö†Ô∏è Janela do jogo n√£o detectada - comandos ser√£o enviados para janela ativa")

    # Configurar pyautogui
    pyautogui.FAILSAFE = True
    pyautogui.PAUSE = 0.01

    try:
        # Criar bot
        if SESSION_LOG:
            SESSION_LOG.info("Inicializando FishingBot...")
        bot = FishingBot()

        if bot.licensed:
            # Configurar hotkeys
            bot.setup_hotkeys()

            # Abrir interface automaticamente ap√≥s um pequeno delay
            print("üé® Inicializando interface...")
            time.sleep(0.5)  # Pequeno delay para garantir inicializa√ß√£o completa
            bot.abrir_interface()

            print("\n" + "="*60)
            print("‚úÖ Bot inicializado e licenciado com sucesso!")
            print("üéÆ Use as teclas de atalho para controlar:")
            print("   F9 - Iniciar Bot")
            print("   F2 - Pausar/Retomar")
            print("   F1 - Parar Bot")
            print("   F4 - Abrir Interface")
            print("   F6 - Alimenta√ß√£o Manual")
            print("   F11 - Testar Abertura de Ba√∫")
            print("   F12 - Testar Movimento do Mouse")
            print("="*60)

            # Loop principal da interface tkinter
            if hasattr(bot, 'ui') and bot.ui and bot.ui.main_window:
                print("üîÑ Iniciando loop principal da interface...")
                bot.ui.main_window.mainloop()
            else:
                # Fallback para loop sem interface
                print("üîÑ Executando sem interface...")
                while True:
                    time.sleep(1)
        else:
            print("‚ùå Bot n√£o foi licenciado corretamente!")

    except KeyboardInterrupt:
        print("\nüõë Encerrando bot...")
        if 'bot' in locals():
            bot.stop()
    except Exception as e:
        error_msg = f"üí• Erro cr√≠tico na inicializa√ß√£o: {e}"
        print(error_msg)
        if SESSION_LOG:
            SESSION_LOG.error(error_msg, exc_info=True)
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
